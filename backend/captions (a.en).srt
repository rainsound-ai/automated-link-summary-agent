1
00:00:00,080 --> 00:00:04,520
the following is a conversation with the

2
00:00:02,280 --> 00:00:08,160
founding members of the cursor team

3
00:00:04,520 --> 00:00:12,639
Michael truell swall oif Arvid lunark

4
00:00:08,160 --> 00:00:15,040
and Aman Sanger cursor is a code editor

5
00:00:12,639 --> 00:00:18,000
based on VSS code that adds a lot of

6
00:00:15,040 --> 00:00:20,119
powerful features for AI assisted coding

7
00:00:18,000 --> 00:00:22,960
it has captivated the attention and

8
00:00:20,119 --> 00:00:25,720
excitement of the programming and AI

9
00:00:22,960 --> 00:00:27,800
communities so I thought this is an

10
00:00:25,720 --> 00:00:31,119
excellent opportunity to dive deep into

11
00:00:27,800 --> 00:00:34,120
the role of AI in programming this is a

12
00:00:31,119 --> 00:00:36,680
super technical conversation that is

13
00:00:34,120 --> 00:00:38,559
bigger than just about one code editor

14
00:00:36,680 --> 00:00:41,079
it's about the future of programming and

15
00:00:38,559 --> 00:00:43,160
in general the future of human AI

16
00:00:41,079 --> 00:00:46,120
collaboration in designing and

17
00:00:43,160 --> 00:00:48,879
Engineering complicated and Powerful

18
00:00:46,120 --> 00:00:50,879
systems this is Le Freedman podcast to

19
00:00:48,879 --> 00:00:53,800
support it please check out our sponsors

20
00:00:50,879 --> 00:00:58,039
in the description and now dear friends

21
00:00:53,800 --> 00:01:00,320
here's Michael suale Arvid and

22
00:00:58,039 --> 00:01:03,879
Aman all right this is awesome we have

23
00:01:00,320 --> 00:01:06,520
Michael Aman suali Arvid here from the

24
00:01:03,879 --> 00:01:09,400
cursor team first up big ridiculous

25
00:01:06,520 --> 00:01:12,040
question what's the point of a code

26
00:01:09,400 --> 00:01:15,159
editor so the the code editor is largely

27
00:01:12,040 --> 00:01:17,320
the place where you build software and

28
00:01:15,159 --> 00:01:19,439
today or for a long time that's meant

29
00:01:17,320 --> 00:01:21,680
the place where you text edit uh a

30
00:01:19,439 --> 00:01:22,960
formal programming language and for

31
00:01:21,680 --> 00:01:24,280
people who aren't programmers the way to

32
00:01:22,960 --> 00:01:27,439
think of a code editor is like a really

33
00:01:24,280 --> 00:01:29,360
souped up word processor for programmers

34
00:01:27,439 --> 00:01:33,040
where the reason it's it's souped up is

35
00:01:29,360 --> 00:01:34,360
code has a lot of structure and so the

36
00:01:33,040 --> 00:01:36,720
the quote unquote word processor the

37
00:01:34,360 --> 00:01:38,920
code editor can actually do a lot for

38
00:01:36,720 --> 00:01:40,000
you that word processors you know sort

39
00:01:38,920 --> 00:01:41,640
of in the writing space haven't been

40
00:01:40,000 --> 00:01:43,880
able to do for for people editing text

41
00:01:41,640 --> 00:01:45,600
there and so you know that's everything

42
00:01:43,880 --> 00:01:47,360
from giving you visual differentiation

43
00:01:45,600 --> 00:01:49,200
of like the actual tokens in the code to

44
00:01:47,360 --> 00:01:50,759
so you can like scan it quickly to

45
00:01:49,200 --> 00:01:51,840
letting you navigate around the code

46
00:01:50,759 --> 00:01:53,079
base sort of like you're navigating

47
00:01:51,840 --> 00:01:54,520
around the internet with like hyperlinks

48
00:01:53,079 --> 00:01:57,920
you're going to sort of definitions of

49
00:01:54,520 --> 00:02:01,520
things you're using to error checking um

50
00:01:57,920 --> 00:02:04,680
to you know to catch rudimentary B

51
00:02:01,520 --> 00:02:08,959
um and so traditionally that's what a

52
00:02:04,680 --> 00:02:10,479
code editor has meant and I think that

53
00:02:08,959 --> 00:02:12,720
what a code editor is is going to change

54
00:02:10,479 --> 00:02:15,200
a lot over the next 10 years um as what

55
00:02:12,720 --> 00:02:17,560
it means to build software maybe starts

56
00:02:15,200 --> 00:02:20,760
to look a bit different I I think also

57
00:02:17,560 --> 00:02:22,239
code edor should just be fun yes that is

58
00:02:20,760 --> 00:02:24,680
very important that is very important

59
00:02:22,239 --> 00:02:27,560
and it's actually sort of an underated

60
00:02:24,680 --> 00:02:30,360
aspect of how we decide what to build

61
00:02:27,560 --> 00:02:32,519
like a lot of the things that we build

62
00:02:30,360 --> 00:02:34,879
and then we we try them out we do an

63
00:02:32,519 --> 00:02:37,360
experiment and then we actually throw

64
00:02:34,879 --> 00:02:39,519
them out because they're not fun and and

65
00:02:37,360 --> 00:02:43,080
so a big part of being fun is like being

66
00:02:39,519 --> 00:02:44,360
fast a lot of the time fast is fun yeah

67
00:02:43,080 --> 00:02:47,080
fast

68
00:02:44,360 --> 00:02:49,120
is uh yeah that should be a

69
00:02:47,080 --> 00:02:50,879
t-shirt like like

70
00:02:49,120 --> 00:02:52,159
fundamentally I think one of the things

71
00:02:50,879 --> 00:02:54,120
that draws a lot of people to to

72
00:02:52,159 --> 00:02:56,599
building stuff on computers is this like

73
00:02:54,120 --> 00:02:57,920
insane integration speed where you know

74
00:02:56,599 --> 00:03:00,159
in other disciplines you might be sort

75
00:02:57,920 --> 00:03:02,120
of gate capped by resources or or the

76
00:03:00,159 --> 00:03:03,680
ability even the ability you know to get

77
00:03:02,120 --> 00:03:04,920
a large group together and coding is

78
00:03:03,680 --> 00:03:07,519
just like amazing thing where it's you

79
00:03:04,920 --> 00:03:08,680
and the computer and uh that alone you

80
00:03:07,519 --> 00:03:10,920
can you can build really cool stuff

81
00:03:08,680 --> 00:03:14,720
really quickly so for people don't know

82
00:03:10,920 --> 00:03:17,640
cursor is this super cool new editor

83
00:03:14,720 --> 00:03:19,599
that's a fork of vs code it would be

84
00:03:17,640 --> 00:03:21,720
interesting to get your kind of

85
00:03:19,599 --> 00:03:24,200
explanation of your own journey of

86
00:03:21,720 --> 00:03:27,200
editors how did you I think all of you

87
00:03:24,200 --> 00:03:30,239
are were big fans of vs code with

88
00:03:27,200 --> 00:03:32,360
co-pilot how did you arrive to VSS code

89
00:03:30,239 --> 00:03:35,400
and how did that lead to your journey

90
00:03:32,360 --> 00:03:38,439
with cursor yeah um

91
00:03:35,400 --> 00:03:40,879
so I think a lot of us well all of us

92
00:03:38,439 --> 00:03:43,400
originally Vim users pure pure VI pure

93
00:03:40,879 --> 00:03:47,400
Vim yeah no neo just pure Vim in a

94
00:03:43,400 --> 00:03:49,640
terminal and at Le at least for myself

95
00:03:47,400 --> 00:03:51,640
it was around the time that C- pilot

96
00:03:49,640 --> 00:03:55,599
came out so

97
00:03:51,640 --> 00:03:57,959
2021 that I really wanted to try it so I

98
00:03:55,599 --> 00:03:59,079
went into vs code the only platform the

99
00:03:57,959 --> 00:04:00,239
only code editor in which it was

100
00:03:59,079 --> 00:04:03,319
available

101
00:04:00,239 --> 00:04:05,840
and even though I you know really

102
00:04:03,319 --> 00:04:08,760
enjoyed using Vim just the experience of

103
00:04:05,840 --> 00:04:10,879
co-pilot with with vs code was more than

104
00:04:08,760 --> 00:04:13,040
good enough to convince me to switch and

105
00:04:10,879 --> 00:04:15,360
so that kind of was the default until we

106
00:04:13,040 --> 00:04:17,440
started working on cursor and uh maybe

107
00:04:15,360 --> 00:04:18,959
we should explain what copala does it's

108
00:04:17,440 --> 00:04:21,199
like a really nice

109
00:04:18,959 --> 00:04:23,040
autocomplete it suggests as you start

110
00:04:21,199 --> 00:04:26,120
writing a thing it suggests one or two

111
00:04:23,040 --> 00:04:29,520
or three lines how to complete the thing

112
00:04:26,120 --> 00:04:30,600
and there's a fun experience in that you

113
00:04:29,520 --> 00:04:32,320
know like when you have a close

114
00:04:30,600 --> 00:04:33,080
friendship and your friend completes

115
00:04:32,320 --> 00:04:35,280
your

116
00:04:33,080 --> 00:04:37,440
sentences like when it's done well

117
00:04:35,280 --> 00:04:38,800
there's an intimate feeling uh there's

118
00:04:37,440 --> 00:04:40,800
probably a better word than intimate but

119
00:04:38,800 --> 00:04:43,160
there's a there's a cool feeling of like

120
00:04:40,800 --> 00:04:45,680
holy it gets

121
00:04:43,160 --> 00:04:48,360
me now and then there's an unpleasant

122
00:04:45,680 --> 00:04:50,560
feeling when it doesn't get you uh and

123
00:04:48,360 --> 00:04:52,320
so there's that that kind of friction

124
00:04:50,560 --> 00:04:54,280
but I would say for a lot of people the

125
00:04:52,320 --> 00:04:56,000
feeling that it gets me over powers that

126
00:04:54,280 --> 00:04:58,199
it doesn't and I think actually one of

127
00:04:56,000 --> 00:04:59,880
the underrated aspects of get up copet

128
00:04:58,199 --> 00:05:01,280
is that even when it's wrong is it's

129
00:04:59,880 --> 00:05:03,199
like a little bit annoying but it's not

130
00:05:01,280 --> 00:05:05,639
that bad because you just type another

131
00:05:03,199 --> 00:05:06,919
character and then maybe then it gets

132
00:05:05,639 --> 00:05:08,680
you or you type another character and

133
00:05:06,919 --> 00:05:10,039
then then it gets you so even when it's

134
00:05:08,680 --> 00:05:11,880
wrong it's not that bad yeah you you can

135
00:05:10,039 --> 00:05:13,759
sort of iterate iterate and fix it I

136
00:05:11,880 --> 00:05:16,039
mean the other underrated part of uh

137
00:05:13,759 --> 00:05:18,560
calot for me sort of was just the first

138
00:05:16,039 --> 00:05:21,600
real real AI product it's like the first

139
00:05:18,560 --> 00:05:24,560
language model consumer product so

140
00:05:21,600 --> 00:05:27,840
copile was kind of like the first killer

141
00:05:24,560 --> 00:05:31,919
app for LMS yeah and like the beta was

142
00:05:27,840 --> 00:05:35,280
out in 2021 right okay mhm uh so what's

143
00:05:31,919 --> 00:05:37,319
the the origin story of cursor so around

144
00:05:35,280 --> 00:05:40,319
2020 the scaling loss papers came out

145
00:05:37,319 --> 00:05:42,600
from from open Ai and that was a moment

146
00:05:40,319 --> 00:05:44,280
where this looked like clear predictable

147
00:05:42,600 --> 00:05:46,280
progress for the field where even if we

148
00:05:44,280 --> 00:05:47,360
didn't have any more ideas looked like

149
00:05:46,280 --> 00:05:49,600
you could make these models a lot better

150
00:05:47,360 --> 00:05:52,520
if you had more computer and more data

151
00:05:49,600 --> 00:05:54,319
uh by the way we'll probably talk uh for

152
00:05:52,520 --> 00:05:58,080
three to four hours on on the topic of

153
00:05:54,319 --> 00:05:59,759
scaling laws but just just to summarize

154
00:05:58,080 --> 00:06:02,039
it's a paper and a set of papers and set

155
00:05:59,759 --> 00:06:04,440
of ideas that say bigger might be better

156
00:06:02,039 --> 00:06:06,199
for model size and data size in the in

157
00:06:04,440 --> 00:06:08,120
the realm of machine learning it's

158
00:06:06,199 --> 00:06:09,919
bigger and better but predictively

159
00:06:08,120 --> 00:06:11,840
better okay this another topic of

160
00:06:09,919 --> 00:06:13,360
conversation but anyway yeah so around

161
00:06:11,840 --> 00:06:15,759
that time for some of us there were like

162
00:06:13,360 --> 00:06:17,639
a lot of conceptual conversations about

163
00:06:15,759 --> 00:06:19,120
what's this going to look like what's

164
00:06:17,639 --> 00:06:20,479
the the story going to be for all these

165
00:06:19,120 --> 00:06:23,160
different knowledge worker Fields about

166
00:06:20,479 --> 00:06:25,400
how they're going to be um made better U

167
00:06:23,160 --> 00:06:27,560
by this technology getting better and

168
00:06:25,400 --> 00:06:29,160
then um I think there were a couple of

169
00:06:27,560 --> 00:06:31,800
moments where like the theoretical gains

170
00:06:29,160 --> 00:06:33,160
predicted in that paper uh started to

171
00:06:31,800 --> 00:06:34,479
feel really concrete and it started to

172
00:06:33,160 --> 00:06:37,120
feel like a moment where you could

173
00:06:34,479 --> 00:06:39,639
actually go and not you know do a PhD if

174
00:06:37,120 --> 00:06:41,319
you wanted to work on uh do useful work

175
00:06:39,639 --> 00:06:42,880
in AI actually felt like now there was

176
00:06:41,319 --> 00:06:45,000
this this whole set of systems one could

177
00:06:42,880 --> 00:06:46,319
built that were really useful and I

178
00:06:45,000 --> 00:06:47,599
think that the first moment we already

179
00:06:46,319 --> 00:06:48,880
talked about a little bit which was

180
00:06:47,599 --> 00:06:51,919
playing with the early bit of copell

181
00:06:48,880 --> 00:06:53,240
like that was awesome and magical um I

182
00:06:51,919 --> 00:06:55,440
think that the next big moment where

183
00:06:53,240 --> 00:06:57,800
everything kind of clicked together was

184
00:06:55,440 --> 00:07:00,800
actually getting early access to gbd4 so

185
00:06:57,800 --> 00:07:03,039
sort of end of 2022 was when we were um

186
00:07:00,800 --> 00:07:06,280
tinkering with that model and the Step

187
00:07:03,039 --> 00:07:07,720
Up in capabilities felt enormous and

188
00:07:06,280 --> 00:07:09,000
previous to that we had been working on

189
00:07:07,720 --> 00:07:12,039
a couple of different projects we had

190
00:07:09,000 --> 00:07:14,000
been um because of co-pilot because of

191
00:07:12,039 --> 00:07:16,000
scaling laws because of our prior

192
00:07:14,000 --> 00:07:17,919
interest in the technology we had been

193
00:07:16,000 --> 00:07:19,720
uh tinkering around with tools for

194
00:07:17,919 --> 00:07:21,520
programmers but things that are like

195
00:07:19,720 --> 00:07:24,080
very specific so you know we were

196
00:07:21,520 --> 00:07:25,080
building tools for uh Financial

197
00:07:24,080 --> 00:07:26,800
professionals who have to work with in a

198
00:07:25,080 --> 00:07:28,080
juper notebook or like you know playing

199
00:07:26,800 --> 00:07:29,919
around with can you do static analysis

200
00:07:28,080 --> 00:07:32,720
with these models and then the Step Up

201
00:07:29,919 --> 00:07:35,840
in gbd4 felt like look that really made

202
00:07:32,720 --> 00:07:37,639
concrete the theoretical gains that um

203
00:07:35,840 --> 00:07:39,759
we had predicted before felt like you

204
00:07:37,639 --> 00:07:42,879
could build a lot more just immediately

205
00:07:39,759 --> 00:07:45,039
at that point in time and

206
00:07:42,879 --> 00:07:46,919
also if we were being consistent it

207
00:07:45,039 --> 00:07:48,199
really felt like um this wasn't just

208
00:07:46,919 --> 00:07:49,560
going to be a point solution thing this

209
00:07:48,199 --> 00:07:50,960
was going to be all of programming was

210
00:07:49,560 --> 00:07:52,960
going to flow through these models it

211
00:07:50,960 --> 00:07:54,280
felt like that demanded a different type

212
00:07:52,960 --> 00:07:56,520
of programming environment to different

213
00:07:54,280 --> 00:07:58,960
type of programming and so we set off to

214
00:07:56,520 --> 00:08:00,680
build that that sort of larger Vision

215
00:07:58,960 --> 00:08:03,639
around then there's one that I

216
00:08:00,680 --> 00:08:06,240
distinctly remember so my roommate is an

217
00:08:03,639 --> 00:08:07,960
IMO gold winner and uh there's a

218
00:08:06,240 --> 00:08:09,680
competition in the US called of putam

219
00:08:07,960 --> 00:08:11,360
which is sort of the IMO for college

220
00:08:09,680 --> 00:08:14,159
people and it's it's this math

221
00:08:11,360 --> 00:08:17,280
competition is he's exceptionally good

222
00:08:14,159 --> 00:08:20,759
so Shang Tong and Aman I remember it

223
00:08:17,280 --> 00:08:25,280
sort of June June of

224
00:08:20,759 --> 00:08:28,000
2022 had this bet on whether the mo like

225
00:08:25,280 --> 00:08:30,400
2024 June or July you were going to win

226
00:08:28,000 --> 00:08:32,680
a gold medal in the Imo with the with

227
00:08:30,400 --> 00:08:34,760
like models IMO is international math

228
00:08:32,680 --> 00:08:36,839
Olympiad uh yeah IMO is international

229
00:08:34,760 --> 00:08:40,000
math Olympiad and so Arvid and I are

230
00:08:36,839 --> 00:08:43,959
both of you know also competed in it so

231
00:08:40,000 --> 00:08:46,200
was sort of personal and uh and I I

232
00:08:43,959 --> 00:08:48,600
remember thinking Matt is just this is

233
00:08:46,200 --> 00:08:51,040
not going to happen this was like it un

234
00:08:48,600 --> 00:08:53,959
like even though I I sort of believed in

235
00:08:51,040 --> 00:08:56,080
progress I thought you know I'm a girl

236
00:08:53,959 --> 00:08:57,800
just like Aman is just delusional that

237
00:08:56,080 --> 00:08:59,880
was the that was the and and to be

238
00:08:57,800 --> 00:09:02,839
honest I mean I I was to be clear it

239
00:08:59,880 --> 00:09:06,200
very wrong but that was maybe the most

240
00:09:02,839 --> 00:09:08,839
preent bet in the group so the the new

241
00:09:06,200 --> 00:09:11,200
results from Deep Mind it turned out

242
00:09:08,839 --> 00:09:13,720
that you were correct that's what well

243
00:09:11,200 --> 00:09:15,680
it technically not technically incorrect

244
00:09:13,720 --> 00:09:17,600
but one point awayan was very

245
00:09:15,680 --> 00:09:20,440
enthusiastic about this stuff back then

246
00:09:17,600 --> 00:09:22,000
and before Aman had this like scaling

247
00:09:20,440 --> 00:09:24,399
loss t-shirt that he would walk around

248
00:09:22,000 --> 00:09:26,600
with where it had like charts and like

249
00:09:24,399 --> 00:09:29,600
the formulas on it oh so you like felt

250
00:09:26,600 --> 00:09:30,920
the AI or you felt the scaling yeah I i

251
00:09:29,600 --> 00:09:33,760
l remember there was this one

252
00:09:30,920 --> 00:09:35,800
conversation uh I had with with Michael

253
00:09:33,760 --> 00:09:38,519
where before I hadn't thought super

254
00:09:35,800 --> 00:09:41,079
deeply and critically about scaling laws

255
00:09:38,519 --> 00:09:43,200
and he kind of posed the question why

256
00:09:41,079 --> 00:09:45,120
isn't scaling all you need or why isn't

257
00:09:43,200 --> 00:09:47,279
scaling going to result in massive gains

258
00:09:45,120 --> 00:09:49,519
in progress and I think I went through

259
00:09:47,279 --> 00:09:51,600
like the like the stages of grief there

260
00:09:49,519 --> 00:09:54,839
is anger denial and then finally at the

261
00:09:51,600 --> 00:10:00,200
end just thinking about it uh acceptance

262
00:09:54,839 --> 00:10:03,279
um and I think I've been quite hopeful

263
00:10:00,200 --> 00:10:05,800
and uh optimistic about progress since I

264
00:10:03,279 --> 00:10:07,240
think one thing I'll caveat is I think

265
00:10:05,800 --> 00:10:08,839
it also depends on like which domains

266
00:10:07,240 --> 00:10:10,959
you're going to see progress like math

267
00:10:08,839 --> 00:10:13,880
is a great domain because especially

268
00:10:10,959 --> 00:10:16,279
like formal theor improving because you

269
00:10:13,880 --> 00:10:18,279
get this fantastic signal of actually

270
00:10:16,279 --> 00:10:20,040
verifying if the thing was correct and

271
00:10:18,279 --> 00:10:22,000
so this means something like RL can work

272
00:10:20,040 --> 00:10:24,360
really really well and I think like you

273
00:10:22,000 --> 00:10:26,079
could have systems that are perhaps very

274
00:10:24,360 --> 00:10:29,079
superhuman in math and still not

275
00:10:26,079 --> 00:10:31,040
technically have ai okay so can we take

276
00:10:29,079 --> 00:10:34,519
it off all the way to cursor mhm and

277
00:10:31,040 --> 00:10:36,920
what is cursor it's a fork of vs code

278
00:10:34,519 --> 00:10:38,560
and VSS code is one of the most popular

279
00:10:36,920 --> 00:10:41,160
editors for a long time like everybody

280
00:10:38,560 --> 00:10:43,519
fell in love with it everybody left Vim

281
00:10:41,160 --> 00:10:45,200
I left dmax for it

282
00:10:43,519 --> 00:10:48,760
sorry

283
00:10:45,200 --> 00:10:52,040
uh uh so it unified in some fun

284
00:10:48,760 --> 00:10:54,200
fundamental way the uh the developer

285
00:10:52,040 --> 00:10:55,600
community and then that you look at the

286
00:10:54,200 --> 00:10:58,959
space of things you look at the scaling

287
00:10:55,600 --> 00:11:00,680
laws AI is becoming amazing and you

288
00:10:58,959 --> 00:11:02,839
decide decided okay it's not enough to

289
00:11:00,680 --> 00:11:04,600
just write an extension Fe vs

290
00:11:02,839 --> 00:11:07,839
code because there's a lot of

291
00:11:04,600 --> 00:11:08,800
limitations to that we we need if AI is

292
00:11:07,839 --> 00:11:10,480
going to keep getting better and better

293
00:11:08,800 --> 00:11:12,720
and better we need to really like

294
00:11:10,480 --> 00:11:14,639
rethink how the the AI is going to be

295
00:11:12,720 --> 00:11:17,839
part of the editing process and so you

296
00:11:14,639 --> 00:11:19,440
decided to Fork vs code and start to

297
00:11:17,839 --> 00:11:22,240
build a lot of the amazing features

298
00:11:19,440 --> 00:11:23,600
we'll be able to to to talk about but

299
00:11:22,240 --> 00:11:26,680
what was that decision like because

300
00:11:23,600 --> 00:11:29,760
there's a lot of extensions including

301
00:11:26,680 --> 00:11:31,560
co-pilot of vs code that are doing so AI

302
00:11:29,760 --> 00:11:34,160
type stuff what was the decision like to

303
00:11:31,560 --> 00:11:37,760
just Fork vs code so the decision to do

304
00:11:34,160 --> 00:11:39,560
an editor seemed kind of self-evident to

305
00:11:37,760 --> 00:11:41,720
us for at least what we wanted to do and

306
00:11:39,560 --> 00:11:43,760
Achieve because when we started working

307
00:11:41,720 --> 00:11:44,519
on the editor the idea was these models

308
00:11:43,760 --> 00:11:45,560
are going to get much better their

309
00:11:44,519 --> 00:11:46,560
capabilities are going to improve and

310
00:11:45,560 --> 00:11:49,079
it's going to entirely change how you

311
00:11:46,560 --> 00:11:50,639
build software both in a you will have

312
00:11:49,079 --> 00:11:52,160
big productivity gains but also radical

313
00:11:50,639 --> 00:11:54,480
in how like the active building software

314
00:11:52,160 --> 00:11:57,200
is going to change a lot and so you're

315
00:11:54,480 --> 00:11:59,000
very limited in the control you have

316
00:11:57,200 --> 00:12:01,920
over a code editor if you're a plugin to

317
00:11:59,000 --> 00:12:03,959
an existing coding environment um and we

318
00:12:01,920 --> 00:12:06,560
didn't want to get locked in by those

319
00:12:03,959 --> 00:12:08,480
limitations we wanted to be able to um

320
00:12:06,560 --> 00:12:10,279
just build the most useful stuff okay

321
00:12:08,480 --> 00:12:13,480
well then the natural question

322
00:12:10,279 --> 00:12:17,320
is you know VSS code is kind of with

323
00:12:13,480 --> 00:12:18,800
copilot a competitor so how do you win

324
00:12:17,320 --> 00:12:20,800
is is it basically just the speed and

325
00:12:18,800 --> 00:12:23,720
the quality of the features yeah I mean

326
00:12:20,800 --> 00:12:27,560
I think this is a space that is quite

327
00:12:23,720 --> 00:12:29,680
interesting perhaps quite unique where

328
00:12:27,560 --> 00:12:31,279
if you look at previous Tech waves

329
00:12:29,680 --> 00:12:33,320
maybe there's kind of one major thing

330
00:12:31,279 --> 00:12:35,399
that happened and unlocked a new wave of

331
00:12:33,320 --> 00:12:38,320
companies but every single year every

332
00:12:35,399 --> 00:12:40,680
single model capability uh or jump you

333
00:12:38,320 --> 00:12:43,880
get model capabilities you now unlock

334
00:12:40,680 --> 00:12:46,920
this new wave of features things that

335
00:12:43,880 --> 00:12:50,160
are possible especially in programming

336
00:12:46,920 --> 00:12:52,120
and so I think in AI programming being

337
00:12:50,160 --> 00:12:55,040
even just a few months ahead let alone a

338
00:12:52,120 --> 00:12:57,040
year ahead makes your product much much

339
00:12:55,040 --> 00:12:58,480
much more useful I think the cursor a

340
00:12:57,040 --> 00:13:00,839
year from now will need to make the

341
00:12:58,480 --> 00:13:04,320
cursor of today look

342
00:13:00,839 --> 00:13:05,839
Obsolete and I think you know Microsoft

343
00:13:04,320 --> 00:13:07,720
has' done a number of like fantastic

344
00:13:05,839 --> 00:13:10,199
things but I don't think they're in a

345
00:13:07,720 --> 00:13:11,399
great place to really keep innovating

346
00:13:10,199 --> 00:13:14,800
and pushing on this in the way that a

347
00:13:11,399 --> 00:13:17,440
startup can just rapidly implementing

348
00:13:14,800 --> 00:13:19,519
features and and push yeah like and and

349
00:13:17,440 --> 00:13:21,079
kind of doing the research

350
00:13:19,519 --> 00:13:24,040
experimentation

351
00:13:21,079 --> 00:13:25,279
necessary um to really push the ceiling

352
00:13:24,040 --> 00:13:26,920
I don't I don't know if I think of it in

353
00:13:25,279 --> 00:13:29,120
terms of features as I think of it in

354
00:13:26,920 --> 00:13:32,680
terms of like capabilities for for

355
00:13:29,120 --> 00:13:35,120
programmers it's that like you know as

356
00:13:32,680 --> 00:13:36,800
you know the new one model came out and

357
00:13:35,120 --> 00:13:38,519
I'm sure there are going to be more more

358
00:13:36,800 --> 00:13:41,040
models of different types like longer

359
00:13:38,519 --> 00:13:44,800
context and maybe faster like there's

360
00:13:41,040 --> 00:13:47,639
all these crazy ideas that you can try

361
00:13:44,800 --> 00:13:49,560
and hopefully 10% of the crazy ideas

362
00:13:47,639 --> 00:13:54,279
will make it into something kind of cool

363
00:13:49,560 --> 00:13:56,800
and useful and uh we want people to have

364
00:13:54,279 --> 00:13:58,320
that sooner to rephrase it's like an

365
00:13:56,800 --> 00:14:01,480
underrated fact is we're making it for

366
00:13:58,320 --> 00:14:03,480
oursel when we started cursor you really

367
00:14:01,480 --> 00:14:05,519
felt this frustration that you know

368
00:14:03,480 --> 00:14:07,959
models you could see models getting

369
00:14:05,519 --> 00:14:11,480
better uh but the coall experience had

370
00:14:07,959 --> 00:14:13,040
not changed it was like man these these

371
00:14:11,480 --> 00:14:14,720
guys like the steing is getting higher

372
00:14:13,040 --> 00:14:16,079
like why are they not making new things

373
00:14:14,720 --> 00:14:17,480
like they should be making new things

374
00:14:16,079 --> 00:14:18,920
they should be like you like like

375
00:14:17,480 --> 00:14:20,240
where's where's where's all the alpha

376
00:14:18,920 --> 00:14:23,759
features there there were no Alpha

377
00:14:20,240 --> 00:14:25,720
features it was like uh I I'm sure it it

378
00:14:23,759 --> 00:14:28,240
was selling well I'm sure it was a great

379
00:14:25,720 --> 00:14:30,399
business but it didn't feel I I'm I'm

380
00:14:28,240 --> 00:14:32,839
one of these people that really want to

381
00:14:30,399 --> 00:14:34,560
try and use new things and was just

382
00:14:32,839 --> 00:14:37,320
there's no new thing for like a very

383
00:14:34,560 --> 00:14:38,759
long while yeah it's interesting uh I

384
00:14:37,320 --> 00:14:40,440
don't know how you put that into words

385
00:14:38,759 --> 00:14:43,600
but when you compare a cursor with

386
00:14:40,440 --> 00:14:45,839
copilot copilot pretty quickly became

387
00:14:43,600 --> 00:14:48,839
started to feel stale for some reason

388
00:14:45,839 --> 00:14:51,839
yeah I think one thing that I think uh

389
00:14:48,839 --> 00:14:54,680
helps us is that we're sort of doing it

390
00:14:51,839 --> 00:14:56,360
all in one where we're developing the

391
00:14:54,680 --> 00:14:59,040
the ux and the way you interact with the

392
00:14:56,360 --> 00:15:01,360
model and at the same time as we're

393
00:14:59,040 --> 00:15:03,440
developing like how we actually make the

394
00:15:01,360 --> 00:15:05,759
model give better answers so like how

395
00:15:03,440 --> 00:15:07,680
you build up the The Prompt or or like

396
00:15:05,759 --> 00:15:09,000
how do you find the context and for a

397
00:15:07,680 --> 00:15:11,560
cursor tab like how do you train the

398
00:15:09,000 --> 00:15:13,560
model um so I think that helps us to

399
00:15:11,560 --> 00:15:16,160
have all of it like sort of like the

400
00:15:13,560 --> 00:15:18,320
same people working on the entire

401
00:15:16,160 --> 00:15:19,839
experience on end yeah it's like the the

402
00:15:18,320 --> 00:15:23,079
person making the UI and the person

403
00:15:19,839 --> 00:15:25,880
training the model like sit to like 18

404
00:15:23,079 --> 00:15:28,360
ft away so often the same person even

405
00:15:25,880 --> 00:15:29,959
yeah often often even the same person so

406
00:15:28,360 --> 00:15:31,680
you you can you create things that that

407
00:15:29,959 --> 00:15:33,519
are sort of not possible if you're not

408
00:15:31,680 --> 00:15:35,399
you're not talking you're not

409
00:15:33,519 --> 00:15:37,959
experimenting and you're using like you

410
00:15:35,399 --> 00:15:40,040
said cursor to write cursor of course oh

411
00:15:37,959 --> 00:15:42,720
yeah yeah well let's talk about some of

412
00:15:40,040 --> 00:15:45,480
these features let's talk about the all-

413
00:15:42,720 --> 00:15:49,199
knowing the all powerful praise B to the

414
00:15:45,480 --> 00:15:51,680
tab so the you know autocomplete on

415
00:15:49,199 --> 00:15:53,600
steroids basically so what how does tab

416
00:15:51,680 --> 00:15:55,319
work what is tab to highlight and

417
00:15:53,600 --> 00:15:58,000
summarize it a high level I'd say that

418
00:15:55,319 --> 00:15:59,360
there are two things that curser is

419
00:15:58,000 --> 00:16:02,360
pretty good at right now there there are

420
00:15:59,360 --> 00:16:05,079
other things that it does um but two

421
00:16:02,360 --> 00:16:07,440
things it it helps programmers with one

422
00:16:05,079 --> 00:16:09,759
is this idea of looking over your

423
00:16:07,440 --> 00:16:11,360
shoulder and being like a really fast

424
00:16:09,759 --> 00:16:13,639
colleague who can kind of jump ahead of

425
00:16:11,360 --> 00:16:15,920
you and type and figure out what you're

426
00:16:13,639 --> 00:16:18,920
what you're going to do next and that

427
00:16:15,920 --> 00:16:20,399
was the original idea behind that was

428
00:16:18,920 --> 00:16:22,040
kind kind of the kernel the idea behind

429
00:16:20,399 --> 00:16:24,120
a good autocomplete was predicting what

430
00:16:22,040 --> 00:16:26,639
you're going to do next you can make

431
00:16:24,120 --> 00:16:29,040
that concept even more ambitious by not

432
00:16:26,639 --> 00:16:30,519
just predicting the characters after

433
00:16:29,040 --> 00:16:31,480
cursor but actually predicting the next

434
00:16:30,519 --> 00:16:32,680
entire change you're going to make the

435
00:16:31,480 --> 00:16:37,880
next diff the next place you're going to

436
00:16:32,680 --> 00:16:40,880
jump to um and the second thing cursor

437
00:16:37,880 --> 00:16:42,720
is is pretty good at right now too is

438
00:16:40,880 --> 00:16:45,440
helping you sometimes jump ahead of the

439
00:16:42,720 --> 00:16:47,639
AI and tell it what to do and go from

440
00:16:45,440 --> 00:16:49,079
instructions to code and on both of

441
00:16:47,639 --> 00:16:50,480
those we've done a lot of work on making

442
00:16:49,079 --> 00:16:52,720
the editing experience for those things

443
00:16:50,480 --> 00:16:55,040
ergonomic um and also making those

444
00:16:52,720 --> 00:16:57,240
things smart and fast one of the things

445
00:16:55,040 --> 00:16:59,319
we really wanted was we wanted the model

446
00:16:57,240 --> 00:17:01,519
to be able to edit code for us uh that

447
00:16:59,319 --> 00:17:03,720
was kind of a wish and we had multiple

448
00:17:01,519 --> 00:17:05,480
attempts at it before before we had a

449
00:17:03,720 --> 00:17:06,480
sort of a good model that could edit

450
00:17:05,480 --> 00:17:09,400
code for

451
00:17:06,480 --> 00:17:10,640
you U then after after we had a good

452
00:17:09,400 --> 00:17:12,679
model I think there there have been a

453
00:17:10,640 --> 00:17:16,240
lot of effort to you know make the

454
00:17:12,679 --> 00:17:18,199
inference fast for you know uh having

455
00:17:16,240 --> 00:17:21,799
having a good good

456
00:17:18,199 --> 00:17:23,319
experience and uh we've been starting to

457
00:17:21,799 --> 00:17:25,280
incorporate I mean Michael sort of

458
00:17:23,319 --> 00:17:27,120
mentioned this like ability to jump to

459
00:17:25,280 --> 00:17:28,880
different places and that jump to

460
00:17:27,120 --> 00:17:31,320
different places I think came from a

461
00:17:28,880 --> 00:17:35,160
feeling off you know once you once you

462
00:17:31,320 --> 00:17:37,840
accept an edit um was like man it should

463
00:17:35,160 --> 00:17:39,919
be just really obvious where to go next

464
00:17:37,840 --> 00:17:41,760
it's like it's like I I made this change

465
00:17:39,919 --> 00:17:43,880
the model should just know that like the

466
00:17:41,760 --> 00:17:46,080
next place to go to is like 18 lines

467
00:17:43,880 --> 00:17:48,960
down like uh if you're if you're a whim

468
00:17:46,080 --> 00:17:51,600
user you could press 18 JJ or

469
00:17:48,960 --> 00:17:52,960
whatever but like why why even why am I

470
00:17:51,600 --> 00:17:55,280
doing this like the model the model

471
00:17:52,960 --> 00:17:57,000
should just know it and then so so the

472
00:17:55,280 --> 00:17:59,360
idea was you you just press tab it would

473
00:17:57,000 --> 00:18:00,640
go 18 lines down and then make it would

474
00:17:59,360 --> 00:18:02,679
show you show you the next edit and you

475
00:18:00,640 --> 00:18:04,919
would press tab so it's just you as long

476
00:18:02,679 --> 00:18:06,640
as you could keep pressing Tab and so

477
00:18:04,919 --> 00:18:08,840
the internal competition was how many

478
00:18:06,640 --> 00:18:12,120
tabs can we make them pressive once you

479
00:18:08,840 --> 00:18:14,640
have like the idea uh more more uh sort

480
00:18:12,120 --> 00:18:16,679
of abstractly the the thing to think

481
00:18:14,640 --> 00:18:18,880
about is sort of like once how how how

482
00:18:16,679 --> 00:18:20,400
are the edit sort of zero zero entropy

483
00:18:18,880 --> 00:18:23,640
so once You' sort of expressed your

484
00:18:20,400 --> 00:18:26,640
intent and the edit is there's no like

485
00:18:23,640 --> 00:18:28,799
new bits of information to finish your

486
00:18:26,640 --> 00:18:31,000
thought but you still have to type some

487
00:18:28,799 --> 00:18:33,159
characters to like make the computer

488
00:18:31,000 --> 00:18:34,960
understand what you're actually thinking

489
00:18:33,159 --> 00:18:37,080
then maybe the model should just sort of

490
00:18:34,960 --> 00:18:39,720
read your mind and and all the zero

491
00:18:37,080 --> 00:18:42,080
entropy bits should just be like tabbed

492
00:18:39,720 --> 00:18:43,600
away yeah that was that was sort of the

493
00:18:42,080 --> 00:18:45,559
abstract there's this interesting thing

494
00:18:43,600 --> 00:18:48,480
where if you look at language model loss

495
00:18:45,559 --> 00:18:50,559
on on different domains um I believe the

496
00:18:48,480 --> 00:18:54,799
bits per bite which is kind of character

497
00:18:50,559 --> 00:18:56,080
normalized loss for code is lower than

498
00:18:54,799 --> 00:18:57,440
language which means in general there

499
00:18:56,080 --> 00:18:59,640
are a lot of tokens in code that are

500
00:18:57,440 --> 00:19:01,960
super predictable lot of characters that

501
00:18:59,640 --> 00:19:03,480
are super predictable um and this is I

502
00:19:01,960 --> 00:19:06,159
think even magnified when you're not

503
00:19:03,480 --> 00:19:08,080
just trying to autocomplete code but

504
00:19:06,159 --> 00:19:10,919
predicting what the user is going to do

505
00:19:08,080 --> 00:19:12,559
next in their editing of existing code

506
00:19:10,919 --> 00:19:14,880
and so you know the gold cursor tab is

507
00:19:12,559 --> 00:19:16,799
let's eliminate all the low entropy

508
00:19:14,880 --> 00:19:18,679
actions you take inside of the editor

509
00:19:16,799 --> 00:19:20,640
when the intent is effectively

510
00:19:18,679 --> 00:19:23,159
determined let's just jump you forward

511
00:19:20,640 --> 00:19:24,320
in time skip you forward well well

512
00:19:23,159 --> 00:19:26,320
what's the intuition and what's the

513
00:19:24,320 --> 00:19:29,480
technical details of how to do next

514
00:19:26,320 --> 00:19:31,080
cursor prediction that jump that's not

515
00:19:29,480 --> 00:19:34,320
that's not so intuitive I think to

516
00:19:31,080 --> 00:19:36,760
people yeah I think I can speak to a few

517
00:19:34,320 --> 00:19:38,000
of the details on how how to make these

518
00:19:36,760 --> 00:19:40,559
things work they're incredibly low

519
00:19:38,000 --> 00:19:44,640
latency so you need to train small

520
00:19:40,559 --> 00:19:47,679
models on this on this task um in

521
00:19:44,640 --> 00:19:49,000
particular they're incredibly pre-fill

522
00:19:47,679 --> 00:19:50,799
token hungry what that means is they

523
00:19:49,000 --> 00:19:52,840
have these really really long prompts

524
00:19:50,799 --> 00:19:53,960
where they see a lot of your code and

525
00:19:52,840 --> 00:19:56,320
they're not actually generating that

526
00:19:53,960 --> 00:19:59,480
many tokens and so the perfect fit for

527
00:19:56,320 --> 00:20:02,000
that is using a sparse model meaning Ane

528
00:19:59,480 --> 00:20:03,600
model um so that was kind of one one

529
00:20:02,000 --> 00:20:04,919
break one breakthrough we made that

530
00:20:03,600 --> 00:20:08,880
substantially improved its performance

531
00:20:04,919 --> 00:20:10,440
at longer context the other being um a

532
00:20:08,880 --> 00:20:12,120
variant of speculative decoding that we

533
00:20:10,440 --> 00:20:14,799
we kind of built out called speculative

534
00:20:12,120 --> 00:20:17,600
edits um these are two I think important

535
00:20:14,799 --> 00:20:21,320
pieces of what make it quite high

536
00:20:17,600 --> 00:20:23,880
quality um and very fast okay soe

537
00:20:21,320 --> 00:20:26,480
mixture of experts the input is huge the

538
00:20:23,880 --> 00:20:28,280
output is small yeah okay so like what

539
00:20:26,480 --> 00:20:31,240
what what else can you say about how to

540
00:20:28,280 --> 00:20:34,240
make it like caching play a role in this

541
00:20:31,240 --> 00:20:35,600
cashing plays a huge role M um because

542
00:20:34,240 --> 00:20:38,520
you're dealing with this many input

543
00:20:35,600 --> 00:20:40,559
tokens if every single keystroke that

544
00:20:38,520 --> 00:20:42,919
you're typing in a given line you had to

545
00:20:40,559 --> 00:20:45,880
rerun the model on all those tokens

546
00:20:42,919 --> 00:20:47,640
passed in you're just going to one

547
00:20:45,880 --> 00:20:49,919
significantly deg grade latency two

548
00:20:47,640 --> 00:20:52,360
you're going to kill your gpus with load

549
00:20:49,919 --> 00:20:54,280
so you need to you you need to design

550
00:20:52,360 --> 00:20:57,240
the actual prompts use for the model

551
00:20:54,280 --> 00:20:58,840
such that they're cach caching aware and

552
00:20:57,240 --> 00:21:01,679
then yeah you need you need to re use

553
00:20:58,840 --> 00:21:04,520
the KV cach across request just so that

554
00:21:01,679 --> 00:21:06,760
you're spending less work less compute

555
00:21:04,520 --> 00:21:09,440
uh again what are the things that tab is

556
00:21:06,760 --> 00:21:12,559
supposed to be able to do kind of in the

557
00:21:09,440 --> 00:21:17,400
near term just to like sort of Linger on

558
00:21:12,559 --> 00:21:20,440
that generate code like fill empty

559
00:21:17,400 --> 00:21:22,799
space Also edit code across multiple

560
00:21:20,440 --> 00:21:24,679
lines yeah and then jump to different

561
00:21:22,799 --> 00:21:26,200
locations inside the same file yeah and

562
00:21:24,679 --> 00:21:28,200
then like hopefully jump to different

563
00:21:26,200 --> 00:21:31,039
files also so if you make an edit in one

564
00:21:28,200 --> 00:21:32,520
file and maybe maybe you have to go

565
00:21:31,039 --> 00:21:33,880
maybe you have to go to another file to

566
00:21:32,520 --> 00:21:36,840
finish your thought it should it should

567
00:21:33,880 --> 00:21:39,360
go to the second file also yeah and then

568
00:21:36,840 --> 00:21:41,640
the full generalization is like next

569
00:21:39,360 --> 00:21:43,080
next action prediction like sometimes

570
00:21:41,640 --> 00:21:45,640
you need to run a command in the

571
00:21:43,080 --> 00:21:47,720
terminal and it should be able to

572
00:21:45,640 --> 00:21:51,320
suggest the command based on the code

573
00:21:47,720 --> 00:21:53,760
that you wrote too um or sometimes you

574
00:21:51,320 --> 00:21:55,760
actually need to like it suggest

575
00:21:53,760 --> 00:21:57,840
something but you you it's hard for you

576
00:21:55,760 --> 00:21:59,279
to know if it's correct because you

577
00:21:57,840 --> 00:22:01,240
actually need some more information to

578
00:21:59,279 --> 00:22:02,760
learn like you need to know the type to

579
00:22:01,240 --> 00:22:04,760
be able to verify that it's correct and

580
00:22:02,760 --> 00:22:07,039
so maybe it should actually take you to

581
00:22:04,760 --> 00:22:09,400
a place that's like the definition of

582
00:22:07,039 --> 00:22:11,200
something and then take you back so that

583
00:22:09,400 --> 00:22:13,200
you have all the requisite knowledge to

584
00:22:11,200 --> 00:22:16,360
be able to accept the next completion Al

585
00:22:13,200 --> 00:22:19,559
also providing the human the knowledge

586
00:22:16,360 --> 00:22:21,919
yes right yeah can you integrate like I

587
00:22:19,559 --> 00:22:25,640
just uh gotten to know a guy named Prime

588
00:22:21,919 --> 00:22:28,640
Jen who I believe has an SS you can

589
00:22:25,640 --> 00:22:31,400
order coffee via SSH

590
00:22:28,640 --> 00:22:33,720
oh yeah oh we did that we did that uh so

591
00:22:31,400 --> 00:22:36,279
can that also the model do that like

592
00:22:33,720 --> 00:22:38,799
feed you and like yeah and provide you

593
00:22:36,279 --> 00:22:40,919
with caffeine okay so that's the general

594
00:22:38,799 --> 00:22:42,799
framework yeah and the the magic moment

595
00:22:40,919 --> 00:22:45,679
would be

596
00:22:42,799 --> 00:22:48,960
if it is programming is this weird

597
00:22:45,679 --> 00:22:51,039
discipline where um sometimes the next

598
00:22:48,960 --> 00:22:51,840
five minutes not always but sometimes

599
00:22:51,039 --> 00:22:53,000
the next five minutes of what you're

600
00:22:51,840 --> 00:22:54,600
going to do is actually predictable from

601
00:22:53,000 --> 00:22:56,400
the stuff you've done recently and so

602
00:22:54,600 --> 00:22:57,880
can you get to a world where that next 5

603
00:22:56,400 --> 00:22:59,720
minutes either happens by you

604
00:22:57,880 --> 00:23:01,799
disengaging and it taking you through or

605
00:22:59,720 --> 00:23:03,320
maybe a little bit more of just you

606
00:23:01,799 --> 00:23:04,559
seeing Next Step what it's going to do

607
00:23:03,320 --> 00:23:05,679
and you're like okay that's good that's

608
00:23:04,559 --> 00:23:08,000
good that's good that's good and you can

609
00:23:05,679 --> 00:23:10,159
just sort of tap tap tap through these

610
00:23:08,000 --> 00:23:12,360
big changes as we're talking about this

611
00:23:10,159 --> 00:23:14,600
I should mention like one of the really

612
00:23:12,360 --> 00:23:16,039
cool and noticeable things about cursor

613
00:23:14,600 --> 00:23:18,159
is that there's this whole diff

614
00:23:16,039 --> 00:23:21,520
interface situation going on so like the

615
00:23:18,159 --> 00:23:23,400
model suggests with uh with the red and

616
00:23:21,520 --> 00:23:25,600
the green of like here's how we're going

617
00:23:23,400 --> 00:23:27,840
to modify the code and in the chat

618
00:23:25,600 --> 00:23:30,080
window you can apply and it shows you

619
00:23:27,840 --> 00:23:31,400
the diff and you can accept the diff so

620
00:23:30,080 --> 00:23:33,400
maybe can you speak to whatever

621
00:23:31,400 --> 00:23:36,360
direction of that we'll probably have

622
00:23:33,400 --> 00:23:38,960
like four or five different kinds of

623
00:23:36,360 --> 00:23:41,240
diffs uh so we we have optimized the

624
00:23:38,960 --> 00:23:43,440
diff for for the autocomplete so that

625
00:23:41,240 --> 00:23:45,919
has a different diff interface

626
00:23:43,440 --> 00:23:48,400
than uh then when you're reviewing

627
00:23:45,919 --> 00:23:50,760
larger blocks of code and then we're

628
00:23:48,400 --> 00:23:53,320
trying to optimize uh another diff thing

629
00:23:50,760 --> 00:23:56,320
for when you're doing multiple different

630
00:23:53,320 --> 00:23:59,279
files uh and and sort of at a high level

631
00:23:56,320 --> 00:24:00,679
the difference is for

632
00:23:59,279 --> 00:24:02,600
when you're doing autocomplete it should

633
00:24:00,679 --> 00:24:04,679
be really really fast to

634
00:24:02,600 --> 00:24:07,039
read uh actually it should be really

635
00:24:04,679 --> 00:24:09,159
fast to read in all situations but in

636
00:24:07,039 --> 00:24:11,000
autocomplete it sort of you're you're

637
00:24:09,159 --> 00:24:13,559
really like your eyes focused in one

638
00:24:11,000 --> 00:24:14,799
area you you can't be in too many you

639
00:24:13,559 --> 00:24:16,120
the humans can't look in too many

640
00:24:14,799 --> 00:24:17,400
different places so you're talking about

641
00:24:16,120 --> 00:24:19,240
on the interface side like on the

642
00:24:17,400 --> 00:24:21,960
interface side so it currently has this

643
00:24:19,240 --> 00:24:24,320
box on the side so we have the current

644
00:24:21,960 --> 00:24:27,080
box and if it tries to delete code in

645
00:24:24,320 --> 00:24:28,679
some place and tries to add other code

646
00:24:27,080 --> 00:24:30,399
it tries to show you a box on the you

647
00:24:28,679 --> 00:24:32,520
can maybe show it if we pull it up on

648
00:24:30,399 --> 00:24:37,240
cursor. comom this is what we're talking

649
00:24:32,520 --> 00:24:39,200
about so that it was like three or four

650
00:24:37,240 --> 00:24:42,200
different attempts at trying to make

651
00:24:39,200 --> 00:24:45,320
this this thing work where first the

652
00:24:42,200 --> 00:24:48,080
attempt was like these blue crossed out

653
00:24:45,320 --> 00:24:50,440
line so before it was a box on the side

654
00:24:48,080 --> 00:24:52,960
it used to show you the code to delete

655
00:24:50,440 --> 00:24:54,720
by showing you like uh like Google doc

656
00:24:52,960 --> 00:24:57,960
style you would see like a line through

657
00:24:54,720 --> 00:25:00,440
it then you would see the the new code

658
00:24:57,960 --> 00:25:02,559
that was super distracting and then we

659
00:25:00,440 --> 00:25:04,559
tried many different you know there was

660
00:25:02,559 --> 00:25:07,399
there was sort of deletions there was

661
00:25:04,559 --> 00:25:09,159
trying to Red highlight then the next

662
00:25:07,399 --> 00:25:13,360
iteration of it which is sort of funny

663
00:25:09,159 --> 00:25:15,559
Would you would hold the on Mac the

664
00:25:13,360 --> 00:25:17,440
option button so it would it would sort

665
00:25:15,559 --> 00:25:19,559
of highlight a region of code to show

666
00:25:17,440 --> 00:25:22,240
you that there might be something coming

667
00:25:19,559 --> 00:25:25,200
uh so maybe in this example like the

668
00:25:22,240 --> 00:25:28,000
input and the value uh would get would

669
00:25:25,200 --> 00:25:29,679
all get blue and the blue would to

670
00:25:28,000 --> 00:25:32,120
highlight that the AI had a suggestion

671
00:25:29,679 --> 00:25:33,880
for you uh so instead of directly

672
00:25:32,120 --> 00:25:35,600
showing you the thing it would show you

673
00:25:33,880 --> 00:25:37,039
that the AI it would just hint that the

674
00:25:35,600 --> 00:25:39,279
AI had a suggestion and if you really

675
00:25:37,039 --> 00:25:41,360
wanted to see it you would hold the

676
00:25:39,279 --> 00:25:44,159
option button and then you would see the

677
00:25:41,360 --> 00:25:46,159
new suggestion then if you release the

678
00:25:44,159 --> 00:25:48,760
option button you would then see your

679
00:25:46,159 --> 00:25:50,200
original code mhm so that's by the way

680
00:25:48,760 --> 00:25:52,919
that's pretty nice but you have to know

681
00:25:50,200 --> 00:25:55,559
to hold the option button yeah I by the

682
00:25:52,919 --> 00:25:57,880
way I'm not a Mac User but I got it it

683
00:25:55,559 --> 00:25:59,320
was it was it's a button I guess you

684
00:25:57,880 --> 00:26:00,880
people

685
00:25:59,320 --> 00:26:02,480
it's h you know it's again it's just

686
00:26:00,880 --> 00:26:04,240
it's just nonintuitive I think that's

687
00:26:02,480 --> 00:26:05,880
the that's the key thing and there's a

688
00:26:04,240 --> 00:26:07,880
chance this this is also not the final

689
00:26:05,880 --> 00:26:10,039
version of it I am personally very

690
00:26:07,880 --> 00:26:13,120
excited for

691
00:26:10,039 --> 00:26:15,520
um making a lot of improvements in this

692
00:26:13,120 --> 00:26:19,240
area like uh we we often talk about it

693
00:26:15,520 --> 00:26:21,679
as the verification problem where U

694
00:26:19,240 --> 00:26:24,240
these diffs are great for small edits uh

695
00:26:21,679 --> 00:26:27,320
for large edits or like when it's

696
00:26:24,240 --> 00:26:28,880
multiple files or something it's um

697
00:26:27,320 --> 00:26:31,120
actually

698
00:26:28,880 --> 00:26:35,159
a little bit prohibitive to to review

699
00:26:31,120 --> 00:26:36,720
these diffs and uh uh so there are like

700
00:26:35,159 --> 00:26:38,919
a couple of different ideas here like

701
00:26:36,720 --> 00:26:41,080
one idea that we have is okay you know

702
00:26:38,919 --> 00:26:42,799
like parts of the diffs are important

703
00:26:41,080 --> 00:26:46,039
they have a lot of information and then

704
00:26:42,799 --> 00:26:48,320
parts of the diff um are just very low

705
00:26:46,039 --> 00:26:50,000
entropy they're like exam like the same

706
00:26:48,320 --> 00:26:52,679
thing over and over again and so maybe

707
00:26:50,000 --> 00:26:54,320
you can highlight the important pieces

708
00:26:52,679 --> 00:26:56,159
and then gray out the the not so

709
00:26:54,320 --> 00:26:58,880
important pieces or maybe you can have a

710
00:26:56,159 --> 00:27:01,159
model that uh looks at the the diff and

711
00:26:58,880 --> 00:27:03,200
and sees oh there's a likely bug here I

712
00:27:01,159 --> 00:27:05,039
will like Mark this with a little red

713
00:27:03,200 --> 00:27:06,320
squiggly and say like you should

714
00:27:05,039 --> 00:27:10,159
probably like review this part of the

715
00:27:06,320 --> 00:27:12,600
diff um and ideas in in that vein I

716
00:27:10,159 --> 00:27:15,000
think are exciting yeah that's a really

717
00:27:12,600 --> 00:27:17,679
fascinating space of like ux design

718
00:27:15,000 --> 00:27:21,320
engineering so you're basically trying

719
00:27:17,679 --> 00:27:22,679
to guide the human programmer through

720
00:27:21,320 --> 00:27:25,559
all the things they need to read and

721
00:27:22,679 --> 00:27:27,720
nothing more yeah like optimally yeah

722
00:27:25,559 --> 00:27:30,919
and you want an intelligent model to do

723
00:27:27,720 --> 00:27:34,240
it like ly diffs Al diff algorithms are

724
00:27:30,919 --> 00:27:36,760
they're like Al like they're just like

725
00:27:34,240 --> 00:27:38,360
normal algorithms uh there's no

726
00:27:36,760 --> 00:27:39,799
intelligence uh there's like

727
00:27:38,360 --> 00:27:42,159
intelligence that went into designing

728
00:27:39,799 --> 00:27:43,880
the algorithm but then there there's no

729
00:27:42,159 --> 00:27:45,559
like you don't care if the if it's about

730
00:27:43,880 --> 00:27:47,840
this thing or this thing uh and so you

731
00:27:45,559 --> 00:27:51,679
want a model to to do this so I think

732
00:27:47,840 --> 00:27:52,919
the the the general question is like M

733
00:27:51,679 --> 00:27:55,640
these models are going to get much

734
00:27:52,919 --> 00:27:57,640
smarter as the models get much smarter

735
00:27:55,640 --> 00:28:00,399
uh the the changes they will be able to

736
00:27:57,640 --> 00:28:01,559
propose are much bigger so as the

737
00:28:00,399 --> 00:28:03,360
changes gets bigger and bigger and

738
00:28:01,559 --> 00:28:05,480
bigger the humans have to do more and

739
00:28:03,360 --> 00:28:07,320
more and more verification work it gets

740
00:28:05,480 --> 00:28:09,279
more and more more hard like it's just

741
00:28:07,320 --> 00:28:11,559
you need you need to help them out it

742
00:28:09,279 --> 00:28:13,640
sort of I I don't want to spend all my

743
00:28:11,559 --> 00:28:17,200
time reviewing

744
00:28:13,640 --> 00:28:21,840
code uh can you say a little more across

745
00:28:17,200 --> 00:28:24,360
multiple files div yeah I mean so GitHub

746
00:28:21,840 --> 00:28:26,159
tries to solve this right with code

747
00:28:24,360 --> 00:28:28,360
review when you're doing code review

748
00:28:26,159 --> 00:28:31,159
you're reviewing multiple deaths cross

749
00:28:28,360 --> 00:28:34,440
multiple files but like Arvid said

750
00:28:31,159 --> 00:28:35,679
earlier I think you can do much better

751
00:28:34,440 --> 00:28:37,840
than code review you know code review

752
00:28:35,679 --> 00:28:39,960
kind of sucks like you spend a lot of

753
00:28:37,840 --> 00:28:44,120
time trying to grock this code that's

754
00:28:39,960 --> 00:28:46,440
often quite unfamiliar to you and it

755
00:28:44,120 --> 00:28:48,600
often like doesn't even actually catch

756
00:28:46,440 --> 00:28:50,399
that many bugs and I think you can

757
00:28:48,600 --> 00:28:52,159
signific significantly improve that

758
00:28:50,399 --> 00:28:53,960
review experience using language models

759
00:28:52,159 --> 00:28:56,240
for example using the kinds of tricks

760
00:28:53,960 --> 00:28:58,679
that AR had described of maybe uh

761
00:28:56,240 --> 00:29:00,440
pointing you towards the regions that

762
00:28:58,679 --> 00:29:04,000
matter

763
00:29:00,440 --> 00:29:06,080
um I think also if the code is produced

764
00:29:04,000 --> 00:29:09,200
by these language models uh and it's not

765
00:29:06,080 --> 00:29:13,039
produced by someone else like the code

766
00:29:09,200 --> 00:29:14,880
review experience is designed for both

767
00:29:13,039 --> 00:29:17,519
the reviewer and the person that

768
00:29:14,880 --> 00:29:18,559
produced the code in the case where the

769
00:29:17,519 --> 00:29:21,039
person that produced the code is a

770
00:29:18,559 --> 00:29:22,360
language model you don't have to care

771
00:29:21,039 --> 00:29:24,519
that much about their experience and you

772
00:29:22,360 --> 00:29:27,799
can design the entire thing around the

773
00:29:24,519 --> 00:29:31,960
reviewer such that the reviewer's job is

774
00:29:27,799 --> 00:29:34,159
as fun as easy as productive as possible

775
00:29:31,960 --> 00:29:35,640
um and I think that that feels like the

776
00:29:34,159 --> 00:29:38,440
issue with just kind of naively trying

777
00:29:35,640 --> 00:29:40,399
to make these things look like code

778
00:29:38,440 --> 00:29:42,320
review I think you can be a lot more

779
00:29:40,399 --> 00:29:44,640
creative and and push the boundary and

780
00:29:42,320 --> 00:29:47,240
what's possible just one one idea there

781
00:29:44,640 --> 00:29:49,559
is I think ordering matters generally

782
00:29:47,240 --> 00:29:51,559
when you review a PR you you have this

783
00:29:49,559 --> 00:29:54,159
list of files and you're reviewing them

784
00:29:51,559 --> 00:29:55,440
from top to bottom but actually like you

785
00:29:54,159 --> 00:29:57,279
actually want to understand this part

786
00:29:55,440 --> 00:29:58,559
first because that came like logically

787
00:29:57,279 --> 00:30:01,640
first and then you want understand the

788
00:29:58,559 --> 00:30:03,240
next part and um you don't want to have

789
00:30:01,640 --> 00:30:06,440
to figure out that yourself you want a

790
00:30:03,240 --> 00:30:07,960
model to guide you through the thing and

791
00:30:06,440 --> 00:30:10,559
is the step of creation going to be more

792
00:30:07,960 --> 00:30:14,200
and more natural language is the goal

793
00:30:10,559 --> 00:30:15,600
versus with actual uh I think sometimes

794
00:30:14,200 --> 00:30:17,519
I don't think it's going to be the case

795
00:30:15,600 --> 00:30:20,399
that all of programming will be natural

796
00:30:17,519 --> 00:30:22,399
language and the reason for that is you

797
00:30:20,399 --> 00:30:23,799
know if I'm PR programming with swalla

798
00:30:22,399 --> 00:30:26,919
and swall is at the computer and the

799
00:30:23,799 --> 00:30:30,440
keyboard uh and sometimes if I'm like

800
00:30:26,919 --> 00:30:32,159
driving I want to say to swallet hey

801
00:30:30,440 --> 00:30:35,159
like implement this function and that

802
00:30:32,159 --> 00:30:36,919
that works and then sometimes it's just

803
00:30:35,159 --> 00:30:38,679
so annoying to explain to swalla what I

804
00:30:36,919 --> 00:30:41,880
want him to do and so I actually take

805
00:30:38,679 --> 00:30:44,559
over the keyboard and I show him I I

806
00:30:41,880 --> 00:30:46,399
write like part of the example and then

807
00:30:44,559 --> 00:30:48,200
it makes sense and that's the easiest

808
00:30:46,399 --> 00:30:50,240
way to communicate and so I think that's

809
00:30:48,200 --> 00:30:51,679
also the case for AI like sometimes the

810
00:30:50,240 --> 00:30:52,960
easiest way to communicate with the AI

811
00:30:51,679 --> 00:30:54,880
will be to show an example and then it

812
00:30:52,960 --> 00:30:56,840
goes and does the thing everywhere else

813
00:30:54,880 --> 00:30:59,960
or sometimes if you're making a website

814
00:30:56,840 --> 00:31:01,679
for example the easiest way to show to

815
00:30:59,960 --> 00:31:03,679
the a what you want is not to tell it

816
00:31:01,679 --> 00:31:07,559
what to do but you know drag things

817
00:31:03,679 --> 00:31:09,320
around or draw things um and yeah and

818
00:31:07,559 --> 00:31:10,840
and like maybe eventually we will get to

819
00:31:09,320 --> 00:31:12,039
like brain machine interfaces or

820
00:31:10,840 --> 00:31:13,559
whatever and can of like understand what

821
00:31:12,039 --> 00:31:15,600
you're thinking and so I think natural

822
00:31:13,559 --> 00:31:18,039
language will have a place I think it

823
00:31:15,600 --> 00:31:20,840
will not definitely not be the way most

824
00:31:18,039 --> 00:31:23,360
people program most of the time I'm

825
00:31:20,840 --> 00:31:24,880
really feeling the AGI with this editor

826
00:31:23,360 --> 00:31:27,679
uh it feels like there's a lot of

827
00:31:24,880 --> 00:31:29,559
machine learning going on underneath

828
00:31:27,679 --> 00:31:32,559
tell tell me about some of the ml stuff

829
00:31:29,559 --> 00:31:35,639
that makes it all work recursor really

830
00:31:32,559 --> 00:31:37,360
works via this Ensemble of custom models

831
00:31:35,639 --> 00:31:38,679
that that that we've trained alongside

832
00:31:37,360 --> 00:31:40,159
you know the frontier models that are

833
00:31:38,679 --> 00:31:42,360
fantastic at the reasoning intense

834
00:31:40,159 --> 00:31:44,720
things and so cursor tab for example is

835
00:31:42,360 --> 00:31:46,480
is a great example of where you can

836
00:31:44,720 --> 00:31:47,880
specialize this model to be even better

837
00:31:46,480 --> 00:31:50,360
than even Frontier models if you look at

838
00:31:47,880 --> 00:31:52,120
evls on on the on the task we set it at

839
00:31:50,360 --> 00:31:53,960
the other domain which it's kind of

840
00:31:52,120 --> 00:31:55,679
surprising that it requires custom

841
00:31:53,960 --> 00:31:59,039
models but but it's kind of necessary

842
00:31:55,679 --> 00:32:00,039
and works quite well is in apply

843
00:31:59,039 --> 00:32:02,360
um

844
00:32:00,039 --> 00:32:03,679
so I think these models are like the

845
00:32:02,360 --> 00:32:05,279
frontier models are quite good at

846
00:32:03,679 --> 00:32:06,760
sketching out plans for code and

847
00:32:05,279 --> 00:32:08,600
generating like rough sketches of like

848
00:32:06,760 --> 00:32:13,000
the change but

849
00:32:08,600 --> 00:32:14,760
actually creating diffs is quite hard um

850
00:32:13,000 --> 00:32:19,000
for Frontier models for your training

851
00:32:14,760 --> 00:32:22,600
models um like you try to do this with

852
00:32:19,000 --> 00:32:24,360
Sonet with 01 any Frontier Model and it

853
00:32:22,600 --> 00:32:26,840
it really messes up stupid things like

854
00:32:24,360 --> 00:32:29,000
counting line numbers um especially in

855
00:32:26,840 --> 00:32:31,639
super super large file

856
00:32:29,000 --> 00:32:33,240
um and so what we've done to alleviate

857
00:32:31,639 --> 00:32:36,320
this is we let the model kind of sketch

858
00:32:33,240 --> 00:32:38,720
out this rough code block that indicates

859
00:32:36,320 --> 00:32:41,679
what the change will be and we train a

860
00:32:38,720 --> 00:32:45,200
model to then apply that change to the

861
00:32:41,679 --> 00:32:48,080
file and we should say that apply is the

862
00:32:45,200 --> 00:32:50,760
model looks at your code it gives you a

863
00:32:48,080 --> 00:32:53,760
really damn good suggestion of what new

864
00:32:50,760 --> 00:32:57,559
things to do and the seemingly for

865
00:32:53,760 --> 00:32:59,919
humans trivial step of combining the two

866
00:32:57,559 --> 00:33:01,880
you're saying is not so trivial contrary

867
00:32:59,919 --> 00:33:04,840
to popular perception it is not a

868
00:33:01,880 --> 00:33:08,559
deterministic algorithm yeah I I I think

869
00:33:04,840 --> 00:33:11,039
like you see shallow copies of apply um

870
00:33:08,559 --> 00:33:12,200
elsewhere and it just breaks like most

871
00:33:11,039 --> 00:33:13,600
of the time because you think you can

872
00:33:12,200 --> 00:33:16,279
kind of try to do some deterministic

873
00:33:13,600 --> 00:33:19,320
matching and then it fails you know at

874
00:33:16,279 --> 00:33:21,200
least 40% of the time and that just

875
00:33:19,320 --> 00:33:24,639
results in a terrible product

876
00:33:21,200 --> 00:33:27,200
experience um I think in general this

877
00:33:24,639 --> 00:33:29,960
this regime of you are going to get

878
00:33:27,200 --> 00:33:33,159
smarter models and like so one other

879
00:33:29,960 --> 00:33:35,480
thing that apply lets you do is it lets

880
00:33:33,159 --> 00:33:38,159
you use fewer tokens with the most

881
00:33:35,480 --> 00:33:40,039
intelligent models uh this is both

882
00:33:38,159 --> 00:33:44,320
expensive in terms of latency for

883
00:33:40,039 --> 00:33:46,320
generating all these tokens um and cost

884
00:33:44,320 --> 00:33:48,679
so you can give this very very rough

885
00:33:46,320 --> 00:33:50,480
sketch and then have your smaller models

886
00:33:48,679 --> 00:33:53,120
go and implement it because it's a much

887
00:33:50,480 --> 00:33:55,039
easier task to implement this very very

888
00:33:53,120 --> 00:33:56,760
sketched out code and I think that this

889
00:33:55,039 --> 00:33:58,559
this regime will continue where you can

890
00:33:56,760 --> 00:33:59,760
use smarter and SM models to do the

891
00:33:58,559 --> 00:34:02,279
planning and then maybe the

892
00:33:59,760 --> 00:34:03,960
implementation details uh can be handled

893
00:34:02,279 --> 00:34:06,120
by the less intelligent ones perhaps

894
00:34:03,960 --> 00:34:08,320
you'll have you know maybe 01 maybe

895
00:34:06,120 --> 00:34:11,399
it'll be even more cap capable models

896
00:34:08,320 --> 00:34:15,560
given an even higher level plan that is

897
00:34:11,399 --> 00:34:17,159
kind of recursively uh applied by Sonet

898
00:34:15,560 --> 00:34:18,320
and then the apply model maybe we should

899
00:34:17,159 --> 00:34:20,720
we should talk about how to how to make

900
00:34:18,320 --> 00:34:23,440
it fast yeah I feel like fast is always

901
00:34:20,720 --> 00:34:26,480
an interesting detail fast good yeah how

902
00:34:23,440 --> 00:34:28,560
do you make it fast yeah so one big

903
00:34:26,480 --> 00:34:31,000
component of making it it fast is

904
00:34:28,560 --> 00:34:33,159
speculative edits so speculative edits

905
00:34:31,000 --> 00:34:35,720
are a variant of speculative decoding

906
00:34:33,159 --> 00:34:38,359
and maybe be helpful to briefly describe

907
00:34:35,720 --> 00:34:41,079
speculative decoding um with speculative

908
00:34:38,359 --> 00:34:44,200
decoding what you do is you you can kind

909
00:34:41,079 --> 00:34:46,119
of take advantage of the fact that you

910
00:34:44,200 --> 00:34:48,280
know most of the time and I I'll add the

911
00:34:46,119 --> 00:34:49,839
caveat that it would be when you're

912
00:34:48,280 --> 00:34:54,200
memory Bound in in language model

913
00:34:49,839 --> 00:34:56,919
Generation Um if you process multiple

914
00:34:54,200 --> 00:34:59,160
tokens at once um it is faster than

915
00:34:56,919 --> 00:35:00,960
generating one Tok at a time so this is

916
00:34:59,160 --> 00:35:04,160
like the same reason why if you look at

917
00:35:00,960 --> 00:35:05,880
tokens per second uh with prompt tokens

918
00:35:04,160 --> 00:35:10,640
versus generated tokens it's much much

919
00:35:05,880 --> 00:35:12,760
faster for prompt tokens um so what we

920
00:35:10,640 --> 00:35:14,520
do is instead of using what specul

921
00:35:12,760 --> 00:35:16,320
decoding normally does which is using a

922
00:35:14,520 --> 00:35:17,960
really small model to predict these

923
00:35:16,320 --> 00:35:22,280
draft tokens that your larger model

924
00:35:17,960 --> 00:35:23,920
would then go in and and verify um with

925
00:35:22,280 --> 00:35:26,079
code edits we have a very strong prior

926
00:35:23,920 --> 00:35:28,760
of what the existing code will look like

927
00:35:26,079 --> 00:35:30,520
and that prior is literally the same

928
00:35:28,760 --> 00:35:32,599
exact code so you can do is you can just

929
00:35:30,520 --> 00:35:35,280
feed chunks of the original code back

930
00:35:32,599 --> 00:35:38,160
into the into the model um and then the

931
00:35:35,280 --> 00:35:39,560
model will just pretty much agree most

932
00:35:38,160 --> 00:35:41,280
of the time that okay I'm just going to

933
00:35:39,560 --> 00:35:43,560
spit this code back out and so you can

934
00:35:41,280 --> 00:35:44,760
process all of those lines in parallel

935
00:35:43,560 --> 00:35:45,960
and you just do this with sufficiently

936
00:35:44,760 --> 00:35:48,400
many chunks and then eventually you'll

937
00:35:45,960 --> 00:35:50,680
reach a point of disagreement where the

938
00:35:48,400 --> 00:35:52,760
model will now predict text that is

939
00:35:50,680 --> 00:35:54,760
different from the ground truth original

940
00:35:52,760 --> 00:35:56,760
code it'll generate those tokens and

941
00:35:54,760 --> 00:35:58,280
then we kind of will decide after enough

942
00:35:56,760 --> 00:36:00,640
tokens match

943
00:35:58,280 --> 00:36:03,000
uh the original code to re start

944
00:36:00,640 --> 00:36:05,960
speculating in chunks of code what this

945
00:36:03,000 --> 00:36:08,680
actually ends up looking like is just a

946
00:36:05,960 --> 00:36:10,119
much faster version of normal editing

947
00:36:08,680 --> 00:36:12,800
code so it's just like it looks like a

948
00:36:10,119 --> 00:36:14,839
much faster version of the model

949
00:36:12,800 --> 00:36:17,560
rewriting all the code so just we we can

950
00:36:14,839 --> 00:36:20,480
use the same exact interface that we use

951
00:36:17,560 --> 00:36:22,680
for for diffs but it will just stream

952
00:36:20,480 --> 00:36:24,640
down a lot faster and then and then the

953
00:36:22,680 --> 00:36:26,680
advantage is that W wireless streaming

954
00:36:24,640 --> 00:36:28,520
you can just also be reviewing start

955
00:36:26,680 --> 00:36:30,880
reviewing the code exactly before before

956
00:36:28,520 --> 00:36:34,520
it's done so there's no no big loading

957
00:36:30,880 --> 00:36:36,920
screen uh so maybe that that is part of

958
00:36:34,520 --> 00:36:38,760
the part of the advantage so the human

959
00:36:36,920 --> 00:36:40,640
can start reading before the thing is

960
00:36:38,760 --> 00:36:43,359
done I think the interesting riff here

961
00:36:40,640 --> 00:36:45,880
is something like like speculation is a

962
00:36:43,359 --> 00:36:47,440
fairly common idea nowadays it's like

963
00:36:45,880 --> 00:36:49,160
not only in language models I mean

964
00:36:47,440 --> 00:36:50,880
there's obviously speculation in CPUs

965
00:36:49,160 --> 00:36:53,359
and there's there like speculation for

966
00:36:50,880 --> 00:36:55,760
databases and like speculation all over

967
00:36:53,359 --> 00:36:58,400
the place let me ask the sort of the

968
00:36:55,760 --> 00:37:02,920
ridiculous question of uh which llm is

969
00:36:58,400 --> 00:37:04,480
better at coding GPT Claude who wins in

970
00:37:02,920 --> 00:37:06,119
the context of programming and I'm sure

971
00:37:04,480 --> 00:37:08,839
the answer is much more Nuance because

972
00:37:06,119 --> 00:37:11,160
it sounds like every single part of this

973
00:37:08,839 --> 00:37:15,440
involves a different

974
00:37:11,160 --> 00:37:19,760
model yeah I think they there's no model

975
00:37:15,440 --> 00:37:21,720
that poo dominates uh others meaning it

976
00:37:19,760 --> 00:37:25,000
is better in all categories that we

977
00:37:21,720 --> 00:37:26,520
think matter the categories being

978
00:37:25,000 --> 00:37:29,720
speed

979
00:37:26,520 --> 00:37:31,960
um ability to edit code ability to

980
00:37:29,720 --> 00:37:33,440
process lots of code long context you

981
00:37:31,960 --> 00:37:34,520
know a couple of other things and kind

982
00:37:33,440 --> 00:37:36,599
of coding

983
00:37:34,520 --> 00:37:39,520
capabilities the one that I'd say right

984
00:37:36,599 --> 00:37:41,319
now is just kind of net best is Sonet I

985
00:37:39,520 --> 00:37:43,160
think this is a consensus opinion our

986
00:37:41,319 --> 00:37:45,920
one's really interesting and it's really

987
00:37:43,160 --> 00:37:48,880
good at reasoning so if you give it

988
00:37:45,920 --> 00:37:51,520
really hard uh programming interview

989
00:37:48,880 --> 00:37:54,200
style problems or lead code problems it

990
00:37:51,520 --> 00:37:56,319
can do quite quite well on them um but

991
00:37:54,200 --> 00:37:59,520
it doesn't feel like it kind of

992
00:37:56,319 --> 00:38:00,520
understands your rough intent as well as

993
00:37:59,520 --> 00:38:03,440
son it

994
00:38:00,520 --> 00:38:06,960
does like if you look at a lot of the

995
00:38:03,440 --> 00:38:09,079
other Frontier models um one qual I have

996
00:38:06,960 --> 00:38:10,880
is it feels like they're not necessarily

997
00:38:09,079 --> 00:38:13,000
over I'm not saying they they train in

998
00:38:10,880 --> 00:38:15,800
benchmarks um but they perform really

999
00:38:13,000 --> 00:38:17,680
well in benchmarks relative to kind of

1000
00:38:15,800 --> 00:38:19,280
everything that's kind of in the middle

1001
00:38:17,680 --> 00:38:20,640
so if you tried on all these benchmarks

1002
00:38:19,280 --> 00:38:22,319
and things that are in the distribution

1003
00:38:20,640 --> 00:38:23,560
of the benchmarks they're valuated on

1004
00:38:22,319 --> 00:38:25,480
you know they'll do really well but when

1005
00:38:23,560 --> 00:38:27,160
you push them a little bit outside of

1006
00:38:25,480 --> 00:38:29,599
that son's I think the one that that

1007
00:38:27,160 --> 00:38:31,560
kind of does best at at kind of

1008
00:38:29,599 --> 00:38:32,880
maintaining that same capability like

1009
00:38:31,560 --> 00:38:34,760
you kind of have the same capability in

1010
00:38:32,880 --> 00:38:37,480
The Benchmark as when you try to

1011
00:38:34,760 --> 00:38:39,599
instruct it to do anything with coding

1012
00:38:37,480 --> 00:38:41,160
what another ridiculous question is the

1013
00:38:39,599 --> 00:38:43,200
difference between the normal

1014
00:38:41,160 --> 00:38:45,480
programming experience versus what

1015
00:38:43,200 --> 00:38:47,480
benchmarks represent like where do

1016
00:38:45,480 --> 00:38:49,560
benchmarks fall short do you think when

1017
00:38:47,480 --> 00:38:51,760
we're evaluating these models by the way

1018
00:38:49,560 --> 00:38:54,480
that's like a really really hard it's

1019
00:38:51,760 --> 00:38:56,280
like like critically important detail

1020
00:38:54,480 --> 00:38:58,520
like how how different like benchmarks

1021
00:38:56,280 --> 00:39:00,440
are versus where is like real coding

1022
00:38:58,520 --> 00:39:03,960
where real

1023
00:39:00,440 --> 00:39:06,760
coding it's not interview style coding

1024
00:39:03,960 --> 00:39:09,200
it's you're you're doing these you know

1025
00:39:06,760 --> 00:39:11,720
humans are saying like half broken

1026
00:39:09,200 --> 00:39:13,880
English sometimes and sometimes you're

1027
00:39:11,720 --> 00:39:17,520
saying like oh do what I did

1028
00:39:13,880 --> 00:39:19,599
before sometimes you're saying uh you

1029
00:39:17,520 --> 00:39:21,400
know go add this thing and then do this

1030
00:39:19,599 --> 00:39:25,119
other thing for me and then make this UI

1031
00:39:21,400 --> 00:39:26,560
element and then you know it's it's just

1032
00:39:25,119 --> 00:39:27,880
like a lot of things are sort of context

1033
00:39:26,560 --> 00:39:29,680
dependent

1034
00:39:27,880 --> 00:39:31,359
you really want to like understand the

1035
00:39:29,680 --> 00:39:33,640
human and then do do what the human

1036
00:39:31,359 --> 00:39:34,960
wants as opposed to sort of this maybe

1037
00:39:33,640 --> 00:39:37,839
the the way to put it is sort of

1038
00:39:34,960 --> 00:39:38,760
abstractly is uh the interview problems

1039
00:39:37,839 --> 00:39:41,359
are

1040
00:39:38,760 --> 00:39:44,200
very wellp

1041
00:39:41,359 --> 00:39:47,599
specified they lean a lot on

1042
00:39:44,200 --> 00:39:48,880
specification while the human stuff is

1043
00:39:47,599 --> 00:39:51,520
less

1044
00:39:48,880 --> 00:39:53,640
specified yeah I think that this this SP

1045
00:39:51,520 --> 00:39:57,839
for question is both Complicated by what

1046
00:39:53,640 --> 00:39:59,960
um Sol just mentioned and then also to

1047
00:39:57,839 --> 00:40:01,000
what Aman was getting into is that even

1048
00:39:59,960 --> 00:40:02,240
if you like you know there's this

1049
00:40:01,000 --> 00:40:03,520
problem of like the skew between what

1050
00:40:02,240 --> 00:40:06,200
can you actually model in a benchmark

1051
00:40:03,520 --> 00:40:07,599
versus uh real programming and that can

1052
00:40:06,200 --> 00:40:09,800
be sometimes hard to encapsulate because

1053
00:40:07,599 --> 00:40:12,160
it's like real programming is like very

1054
00:40:09,800 --> 00:40:13,319
messy and sometimes things aren't super

1055
00:40:12,160 --> 00:40:16,640
well specified what's correct or what

1056
00:40:13,319 --> 00:40:18,359
isn't but then uh it's also doubly hard

1057
00:40:16,640 --> 00:40:19,920
because of this public Benchmark problem

1058
00:40:18,359 --> 00:40:21,119
and that's both because public

1059
00:40:19,920 --> 00:40:22,960
benchmarks are sometimes kind of Hill

1060
00:40:21,119 --> 00:40:24,960
climbed on then it's like really really

1061
00:40:22,960 --> 00:40:28,440
hard to also get the data from the

1062
00:40:24,960 --> 00:40:30,800
public benchmarks out of the models and

1063
00:40:28,440 --> 00:40:33,359
so for instance like one of the most

1064
00:40:30,800 --> 00:40:36,520
popular like agent benchmarks sweet

1065
00:40:33,359 --> 00:40:38,560
bench um is really really contaminated

1066
00:40:36,520 --> 00:40:40,079
in the training data of uh these

1067
00:40:38,560 --> 00:40:41,880
Foundation models and so if you ask

1068
00:40:40,079 --> 00:40:42,880
these Foundation models to do a sweet

1069
00:40:41,880 --> 00:40:44,400
bench problem you actually don't give

1070
00:40:42,880 --> 00:40:45,839
them the context of a codebase they can

1071
00:40:44,400 --> 00:40:47,240
like hallucinate the right file pass

1072
00:40:45,839 --> 00:40:51,000
they can hallucinate the right function

1073
00:40:47,240 --> 00:40:52,400
names um and so the the it's it's also

1074
00:40:51,000 --> 00:40:54,720
just the public aspect of these things

1075
00:40:52,400 --> 00:40:56,800
is tricky yeah like in that case it

1076
00:40:54,720 --> 00:41:00,040
could be trained on the literal issues

1077
00:40:56,800 --> 00:41:02,000
or pool request themselves and and maybe

1078
00:41:00,040 --> 00:41:03,920
the lives will start to do a better job

1079
00:41:02,000 --> 00:41:05,720
um or they've already done a good job at

1080
00:41:03,920 --> 00:41:07,960
decontaminating those things but they're

1081
00:41:05,720 --> 00:41:10,119
not going to emit the actual training

1082
00:41:07,960 --> 00:41:11,680
data of the repository itself like these

1083
00:41:10,119 --> 00:41:13,720
are all like some of the most popular

1084
00:41:11,680 --> 00:41:16,440
python repositories like simpai is one

1085
00:41:13,720 --> 00:41:18,520
example I don't think they're going to

1086
00:41:16,440 --> 00:41:20,280
handicap their models on Senpai and all

1087
00:41:18,520 --> 00:41:23,040
these popular P python repositories in

1088
00:41:20,280 --> 00:41:25,000
order to get uh true evaluation scores

1089
00:41:23,040 --> 00:41:27,920
in these benchmarks yeah I think that

1090
00:41:25,000 --> 00:41:29,480
given the dirs and benchmarks

1091
00:41:27,920 --> 00:41:31,240
um there have been like a few

1092
00:41:29,480 --> 00:41:33,160
interesting crutches that uh places that

1093
00:41:31,240 --> 00:41:35,440
build systems with these models or build

1094
00:41:33,160 --> 00:41:36,560
these models actually use to get a sense

1095
00:41:35,440 --> 00:41:39,440
of are they going in the right direction

1096
00:41:36,560 --> 00:41:41,319
or not and uh in a lot of places uh

1097
00:41:39,440 --> 00:41:42,200
people will actually just have humans

1098
00:41:41,319 --> 00:41:44,440
play with the things and give

1099
00:41:42,200 --> 00:41:45,560
qualitative feedback on these um like

1100
00:41:44,440 --> 00:41:47,440
one or two of the foundation model

1101
00:41:45,560 --> 00:41:49,160
companies they they have people who

1102
00:41:47,440 --> 00:41:51,599
that's that's a big part of their role

1103
00:41:49,160 --> 00:41:53,000
and you know internally we also uh you

1104
00:41:51,599 --> 00:41:54,119
know qualitatively assess these models

1105
00:41:53,000 --> 00:41:55,640
and actually lean on that a lot in

1106
00:41:54,119 --> 00:41:58,000
addition to like private evals that we

1107
00:41:55,640 --> 00:42:00,960
have it's like the live

1108
00:41:58,000 --> 00:42:03,079
the vibe yeah the vi the vibe Benchmark

1109
00:42:00,960 --> 00:42:06,839
human Benchmark the hum you pull in the

1110
00:42:03,079 --> 00:42:08,040
humans to do a Vibe check yeah okay I

1111
00:42:06,839 --> 00:42:10,079
mean that's that's kind of what I do

1112
00:42:08,040 --> 00:42:14,599
like just like reading online forums and

1113
00:42:10,079 --> 00:42:15,599
Reddit and X just like well I don't know

1114
00:42:14,599 --> 00:42:19,000
how

1115
00:42:15,599 --> 00:42:21,319
to properly load in people's opinions

1116
00:42:19,000 --> 00:42:24,760
because they'll say things like I feel

1117
00:42:21,319 --> 00:42:27,640
like Claude or gpt's gotten Dumber or

1118
00:42:24,760 --> 00:42:30,040
something they'll say I feel like

1119
00:42:27,640 --> 00:42:32,680
and then I sometimes feel like that too

1120
00:42:30,040 --> 00:42:34,800
but I wonder if it's the model's problem

1121
00:42:32,680 --> 00:42:38,559
or mine yeah with Claude there's an

1122
00:42:34,800 --> 00:42:42,359
interesting take I heard where I think

1123
00:42:38,559 --> 00:42:43,599
AWS has different chips um and I I

1124
00:42:42,359 --> 00:42:48,119
suspect they've slightly different

1125
00:42:43,599 --> 00:42:50,599
numerics than uh Nvidia gpus and someone

1126
00:42:48,119 --> 00:42:53,319
speculated that claud's deg degraded

1127
00:42:50,599 --> 00:42:55,480
performance had to do with maybe using

1128
00:42:53,319 --> 00:42:58,640
the quantise version that existed on AWS

1129
00:42:55,480 --> 00:43:01,319
Bedrock versus uh whatever was running

1130
00:42:58,640 --> 00:43:02,559
on on anthropics gpus I interview a

1131
00:43:01,319 --> 00:43:05,160
bunch of people that have conspiracy

1132
00:43:02,559 --> 00:43:08,160
theories so I'm glad spoke spoke to this

1133
00:43:05,160 --> 00:43:10,400
conspiracy well it's it's not not like

1134
00:43:08,160 --> 00:43:12,000
conspiracy theory as much as they're

1135
00:43:10,400 --> 00:43:13,400
just they're like they're you know

1136
00:43:12,000 --> 00:43:15,359
humans humans are humans and there's

1137
00:43:13,400 --> 00:43:16,079
there's these details and you know

1138
00:43:15,359 --> 00:43:19,200
you're

1139
00:43:16,079 --> 00:43:21,640
doing like these quzy amount of flops

1140
00:43:19,200 --> 00:43:24,599
and you know chips are messy and man you

1141
00:43:21,640 --> 00:43:26,960
can just have bugs like bugs are it's

1142
00:43:24,599 --> 00:43:30,839
it's hard to overstate how how hard bugs

1143
00:43:26,960 --> 00:43:33,920
are to avoid what's uh the role of a

1144
00:43:30,839 --> 00:43:35,359
good prompt in all this see you mention

1145
00:43:33,920 --> 00:43:39,160
that benchmarks have

1146
00:43:35,359 --> 00:43:41,280
really uh structured well formulated

1147
00:43:39,160 --> 00:43:45,240
prompts what what should a human be

1148
00:43:41,280 --> 00:43:46,800
doing to maximize success and what's the

1149
00:43:45,240 --> 00:43:49,880
importance of what the humans you wrote

1150
00:43:46,800 --> 00:43:53,720
a blog post on you called it prompt

1151
00:43:49,880 --> 00:43:56,480
design yeah uh I think it depends on

1152
00:43:53,720 --> 00:43:58,160
which model you're using and all of them

1153
00:43:56,480 --> 00:44:01,839
are likly different and they respond

1154
00:43:58,160 --> 00:44:05,559
differently to different prompts but um

1155
00:44:01,839 --> 00:44:08,040
I think the original gp4 uh and the

1156
00:44:05,559 --> 00:44:09,960
original sort of bre of models last last

1157
00:44:08,040 --> 00:44:12,119
year they were quite sensitive to the

1158
00:44:09,960 --> 00:44:15,319
prompts and they also had a very small

1159
00:44:12,119 --> 00:44:16,880
context window and so we have all of

1160
00:44:15,319 --> 00:44:19,960
these pieces of information around the

1161
00:44:16,880 --> 00:44:21,640
codebase that would maybe be relevant in

1162
00:44:19,960 --> 00:44:23,319
the prompt like you have the docs you

1163
00:44:21,640 --> 00:44:25,800
have the files that you add you have the

1164
00:44:23,319 --> 00:44:27,880
conversation history and then there's a

1165
00:44:25,800 --> 00:44:29,680
problem like how do you decide what you

1166
00:44:27,880 --> 00:44:31,119
actually put in the prompt and when you

1167
00:44:29,680 --> 00:44:33,040
have a a limited space and even for

1168
00:44:31,119 --> 00:44:35,359
today's models even when you have long

1169
00:44:33,040 --> 00:44:38,280
context filling out the entire context

1170
00:44:35,359 --> 00:44:40,079
window means that it's slower it means

1171
00:44:38,280 --> 00:44:41,640
that sometimes a model actually gets

1172
00:44:40,079 --> 00:44:44,400
confused and some models get more

1173
00:44:41,640 --> 00:44:46,839
confused than others and we have this

1174
00:44:44,400 --> 00:44:50,040
one system internally that we call preum

1175
00:44:46,839 --> 00:44:55,920
which helps us with that a little bit um

1176
00:44:50,040 --> 00:44:57,599
and I think it was built for the era

1177
00:44:55,920 --> 00:45:01,720
before where we had

1178
00:44:57,599 --> 00:45:04,800
8,000 uh token context Windows uh and

1179
00:45:01,720 --> 00:45:07,680
it's a little bit similar to when you're

1180
00:45:04,800 --> 00:45:10,400
making a website you you sort of you you

1181
00:45:07,680 --> 00:45:12,800
want it to work on mobile you want it to

1182
00:45:10,400 --> 00:45:17,240
work on a desktop screen and you have

1183
00:45:12,800 --> 00:45:18,720
this uh Dynamic information which you

1184
00:45:17,240 --> 00:45:20,240
don't have for example if you're making

1185
00:45:18,720 --> 00:45:21,760
like designing a print magazine you have

1186
00:45:20,240 --> 00:45:23,200
like you know exactly where you can put

1187
00:45:21,760 --> 00:45:24,920
stuff but when you have a website or

1188
00:45:23,200 --> 00:45:27,000
when you have a prompt you have these

1189
00:45:24,920 --> 00:45:28,599
inputs and then you need to format them

1190
00:45:27,000 --> 00:45:29,880
will always work even if the input is

1191
00:45:28,599 --> 00:45:32,200
really big then you might have to cut

1192
00:45:29,880 --> 00:45:33,920
something down uh and and and so the

1193
00:45:32,200 --> 00:45:36,079
idea was okay like let's take some

1194
00:45:33,920 --> 00:45:39,119
inspiration what's the best way to

1195
00:45:36,079 --> 00:45:41,160
design websites well um the thing that

1196
00:45:39,119 --> 00:45:44,559
we really like is is react and the

1197
00:45:41,160 --> 00:45:48,440
declarative approach where you um you

1198
00:45:44,559 --> 00:45:51,079
use jsx in in in JavaScript uh and then

1199
00:45:48,440 --> 00:45:53,520
you declare this is what I want and I

1200
00:45:51,079 --> 00:45:55,280
think this has higher priority or like

1201
00:45:53,520 --> 00:45:57,480
this has higher Z index than something

1202
00:45:55,280 --> 00:45:59,599
else um and

1203
00:45:57,480 --> 00:46:01,760
then you have this rendering engine in

1204
00:45:59,599 --> 00:46:04,520
web design it's it's like Chrome and uh

1205
00:46:01,760 --> 00:46:07,319
in our case it's a pre renderer uh which

1206
00:46:04,520 --> 00:46:08,720
then fits everything onto the page and

1207
00:46:07,319 --> 00:46:10,280
and so you declaratively decide what you

1208
00:46:08,720 --> 00:46:12,800
want and then it figures out what you

1209
00:46:10,280 --> 00:46:15,839
want um and and so we have found that to

1210
00:46:12,800 --> 00:46:18,760
be uh quite helpful and I think the role

1211
00:46:15,839 --> 00:46:20,400
of it has has sort of shifted over time

1212
00:46:18,760 --> 00:46:22,359
um where initially was to fit to these

1213
00:46:20,400 --> 00:46:25,880
small context Windows now it's really

1214
00:46:22,359 --> 00:46:28,440
useful because you know it helps us with

1215
00:46:25,880 --> 00:46:30,240
splitting up the data that goes into the

1216
00:46:28,440 --> 00:46:33,359
prompt and the actual rendering of it

1217
00:46:30,240 --> 00:46:34,960
and so um it's easier to debug because

1218
00:46:33,359 --> 00:46:37,880
you can change the rendering of the

1219
00:46:34,960 --> 00:46:39,400
prompt and then try it on Old prompts

1220
00:46:37,880 --> 00:46:41,359
because you have the raw data that went

1221
00:46:39,400 --> 00:46:43,520
into the prompt and then you can see did

1222
00:46:41,359 --> 00:46:45,640
my change actually improve it for for

1223
00:46:43,520 --> 00:46:49,520
like this entire evil set so do you

1224
00:46:45,640 --> 00:46:50,720
literally prompt with jsx yes yes so it

1225
00:46:49,520 --> 00:46:52,319
kind of looks like react there are

1226
00:46:50,720 --> 00:46:55,720
components like we have one component

1227
00:46:52,319 --> 00:46:57,480
that's a file component and it takes in

1228
00:46:55,720 --> 00:46:59,280
like the cursor

1229
00:46:57,480 --> 00:47:01,119
like usually there's like one line where

1230
00:46:59,280 --> 00:47:02,280
the cursor is in your file and that's

1231
00:47:01,119 --> 00:47:03,559
like probably the most important line

1232
00:47:02,280 --> 00:47:05,200
because that's the one you're looking at

1233
00:47:03,559 --> 00:47:07,160
and so then you can give priorities so

1234
00:47:05,200 --> 00:47:09,720
like that line has the highest priority

1235
00:47:07,160 --> 00:47:12,119
and then you subtract one for every line

1236
00:47:09,720 --> 00:47:13,480
that uh is farther away and then

1237
00:47:12,119 --> 00:47:14,880
eventually when it's render it to figure

1238
00:47:13,480 --> 00:47:17,280
out how many lines can I actually fit

1239
00:47:14,880 --> 00:47:19,079
and it centers around that thing that's

1240
00:47:17,280 --> 00:47:20,880
amazing yeah and you can do like other

1241
00:47:19,079 --> 00:47:22,960
fancy things where if you have lots of

1242
00:47:20,880 --> 00:47:25,800
code blocks from the entire code base

1243
00:47:22,960 --> 00:47:28,280
you could use uh retrieval um and things

1244
00:47:25,800 --> 00:47:29,960
like embedding and reranking scores to

1245
00:47:28,280 --> 00:47:32,720
add priorities for each of these

1246
00:47:29,960 --> 00:47:35,160
components so should humans when they

1247
00:47:32,720 --> 00:47:36,960
ask questions also use try to use

1248
00:47:35,160 --> 00:47:39,680
something like that like would it be

1249
00:47:36,960 --> 00:47:41,319
beneficial to write jsx in the in the

1250
00:47:39,680 --> 00:47:44,640
problem where the whole idea is should

1251
00:47:41,319 --> 00:47:47,520
be loose and messy I I think our goal is

1252
00:47:44,640 --> 00:47:48,920
kind of that you should just uh do

1253
00:47:47,520 --> 00:47:53,160
whatever is the most natural thing for

1254
00:47:48,920 --> 00:47:54,480
you and then we are job is to figure out

1255
00:47:53,160 --> 00:47:56,040
how do we actually like retrieve the

1256
00:47:54,480 --> 00:47:57,960
relative EV things so that your thing

1257
00:47:56,040 --> 00:48:00,440
actually makes sense well this is sort

1258
00:47:57,960 --> 00:48:02,640
of the discussion I had with uh Arvin of

1259
00:48:00,440 --> 00:48:04,800
perplexity is like his whole idea is

1260
00:48:02,640 --> 00:48:09,000
like you should let the person be as

1261
00:48:04,800 --> 00:48:11,319
lazy as he want but like yeah that's a

1262
00:48:09,000 --> 00:48:14,599
beautiful thing but I feel like you're

1263
00:48:11,319 --> 00:48:16,720
allowed to ask more of programmers right

1264
00:48:14,599 --> 00:48:19,640
so like if you say just do what you want

1265
00:48:16,720 --> 00:48:21,920
I mean humans are lazy there's a kind of

1266
00:48:19,640 --> 00:48:25,640
tension between just being lazy versus

1267
00:48:21,920 --> 00:48:27,599
like provide more is uh be prompted

1268
00:48:25,640 --> 00:48:31,240
almost like the system

1269
00:48:27,599 --> 00:48:33,359
pressuring you or inspiring you to be

1270
00:48:31,240 --> 00:48:35,359
articulate not in terms of the grammar

1271
00:48:33,359 --> 00:48:37,960
of the sentences but in terms of the

1272
00:48:35,359 --> 00:48:39,720
depth of thoughts that you convey inside

1273
00:48:37,960 --> 00:48:42,359
the uh the problems I think even as a

1274
00:48:39,720 --> 00:48:45,960
system gets closer to some level of

1275
00:48:42,359 --> 00:48:48,720
perfection often when you ask the model

1276
00:48:45,960 --> 00:48:51,040
for something you just are not not

1277
00:48:48,720 --> 00:48:53,040
enough intent is conveyed to know what

1278
00:48:51,040 --> 00:48:55,359
to do and there are like a few ways to

1279
00:48:53,040 --> 00:48:58,240
resolve that intent one is the simple

1280
00:48:55,359 --> 00:49:00,640
thing of having model just ask you I'm

1281
00:48:58,240 --> 00:49:04,440
not sure how to do these parts based in

1282
00:49:00,640 --> 00:49:07,559
your query could you clarify that um I

1283
00:49:04,440 --> 00:49:10,520
think the other could be

1284
00:49:07,559 --> 00:49:12,400
maybe if you there are five or six

1285
00:49:10,520 --> 00:49:14,680
possible Generations given the

1286
00:49:12,400 --> 00:49:16,119
uncertainty present in your query so far

1287
00:49:14,680 --> 00:49:18,440
why don't we just actually show you all

1288
00:49:16,119 --> 00:49:21,599
of those and let you pick

1289
00:49:18,440 --> 00:49:25,559
them how hard is it to for the model to

1290
00:49:21,599 --> 00:49:27,920
choose to speak talk back sort of versus

1291
00:49:25,559 --> 00:49:29,200
gener that's a that's hard sort of like

1292
00:49:27,920 --> 00:49:33,079
how to deal with the

1293
00:49:29,200 --> 00:49:36,040
uncertainty do I do I choose to ask for

1294
00:49:33,079 --> 00:49:39,000
more information to reduce the ambiguity

1295
00:49:36,040 --> 00:49:42,079
so I mean one of the things we we do is

1296
00:49:39,000 --> 00:49:44,960
um it's like a recent addition is try to

1297
00:49:42,079 --> 00:49:48,119
suggest files that you can add so and

1298
00:49:44,960 --> 00:49:52,200
while you're typing uh one can guess

1299
00:49:48,119 --> 00:49:54,400
what the uncertainty is and maybe

1300
00:49:52,200 --> 00:49:57,960
suggest that like you know maybe maybe

1301
00:49:54,400 --> 00:50:02,200
you're writing your API

1302
00:49:57,960 --> 00:50:04,480
and uh we can guess using the

1303
00:50:02,200 --> 00:50:07,319
commits uh that you've made previously

1304
00:50:04,480 --> 00:50:11,240
in the same file that the client and the

1305
00:50:07,319 --> 00:50:13,240
server is super useful and uh there's

1306
00:50:11,240 --> 00:50:15,559
like a hard technical problem of how do

1307
00:50:13,240 --> 00:50:17,359
you resolve it across all commits which

1308
00:50:15,559 --> 00:50:21,720
files are the most important given your

1309
00:50:17,359 --> 00:50:23,119
current prompt and we still sort of uh

1310
00:50:21,720 --> 00:50:25,359
initial version is ruled out and I'm

1311
00:50:23,119 --> 00:50:27,359
sure we can make it much more

1312
00:50:25,359 --> 00:50:29,040
accurate uh it's it's it's very

1313
00:50:27,359 --> 00:50:31,119
experimental but then the ideaas we show

1314
00:50:29,040 --> 00:50:33,680
you like do you just want to add this

1315
00:50:31,119 --> 00:50:35,559
file this file this file also to tell

1316
00:50:33,680 --> 00:50:38,040
you know the model to edit those files

1317
00:50:35,559 --> 00:50:39,760
for you uh because if if you're maybe

1318
00:50:38,040 --> 00:50:41,280
you're making the API like you should

1319
00:50:39,760 --> 00:50:43,280
also edit the client and the server that

1320
00:50:41,280 --> 00:50:45,000
is using the API and the other one

1321
00:50:43,280 --> 00:50:48,079
resolving the API and so that would be

1322
00:50:45,000 --> 00:50:49,440
kind of cool as both there's the phase

1323
00:50:48,079 --> 00:50:52,000
where you're writing the prompt and

1324
00:50:49,440 --> 00:50:53,359
there's before you even click enter

1325
00:50:52,000 --> 00:50:55,599
maybe we can help resolve some of the

1326
00:50:53,359 --> 00:50:59,119
uncertainty to what degree do you use uh

1327
00:50:55,599 --> 00:51:02,599
agentic approaches how useful are agents

1328
00:50:59,119 --> 00:51:06,359
we think agents are really really cool

1329
00:51:02,599 --> 00:51:08,359
like I I I think agents is like uh it's

1330
00:51:06,359 --> 00:51:10,000
like resembles sort of like a human it's

1331
00:51:08,359 --> 00:51:12,000
sort of like the like you can kind of

1332
00:51:10,000 --> 00:51:15,319
feel that it like you're getting closer

1333
00:51:12,000 --> 00:51:18,880
to AGI because you see a demo where um

1334
00:51:15,319 --> 00:51:22,720
it acts as as a human would and and it's

1335
00:51:18,880 --> 00:51:26,760
really really cool I think um agents are

1336
00:51:22,720 --> 00:51:28,640
not yet super useful for many things

1337
00:51:26,760 --> 00:51:30,839
they I think we're we're getting close

1338
00:51:28,640 --> 00:51:34,280
to where they will actually be useful

1339
00:51:30,839 --> 00:51:37,640
and so I think uh there are certain

1340
00:51:34,280 --> 00:51:40,079
types of tasks where having an agent

1341
00:51:37,640 --> 00:51:41,640
would be really nice like I would love

1342
00:51:40,079 --> 00:51:44,200
to have an agent for example if like we

1343
00:51:41,640 --> 00:51:47,280
have a bug where you sometimes can't

1344
00:51:44,200 --> 00:51:49,880
command C and command V uh inside our

1345
00:51:47,280 --> 00:51:51,559
chat input box and that's a task that's

1346
00:51:49,880 --> 00:51:53,599
super well specified I just want to say

1347
00:51:51,559 --> 00:51:55,319
like in two sentences this does not work

1348
00:51:53,599 --> 00:51:58,319
please fix it and then I would love to

1349
00:51:55,319 --> 00:52:00,960
have an agent that just goes off does it

1350
00:51:58,319 --> 00:52:03,520
and then uh a day later I I come back

1351
00:52:00,960 --> 00:52:05,920
and I review the the thing you mean it

1352
00:52:03,520 --> 00:52:07,640
goes finds the right file yeah it finds

1353
00:52:05,920 --> 00:52:10,119
the right files it like tries to

1354
00:52:07,640 --> 00:52:11,720
reproduce the bug it like fixes the bug

1355
00:52:10,119 --> 00:52:13,079
and then it verifies that it's correct

1356
00:52:11,720 --> 00:52:15,920
and this is could be a process that

1357
00:52:13,079 --> 00:52:18,079
takes a long time um and so I think I

1358
00:52:15,920 --> 00:52:21,200
would love to have that uh and then I

1359
00:52:18,079 --> 00:52:23,280
think a lot of programming like there is

1360
00:52:21,200 --> 00:52:26,680
often this belief that agents will take

1361
00:52:23,280 --> 00:52:28,680
over all of programming um I don't think

1362
00:52:26,680 --> 00:52:31,119
we think that that's the case because a

1363
00:52:28,680 --> 00:52:33,799
lot of programming a lot of the value is

1364
00:52:31,119 --> 00:52:35,760
in iterating or you don't actually want

1365
00:52:33,799 --> 00:52:37,799
to specify something upfront because you

1366
00:52:35,760 --> 00:52:39,359
don't really know what you want until

1367
00:52:37,799 --> 00:52:41,720
youve seen an initial version and then

1368
00:52:39,359 --> 00:52:44,000
you want to iterate on that and then you

1369
00:52:41,720 --> 00:52:45,640
provide more information and so for a

1370
00:52:44,000 --> 00:52:47,520
lot of programming I think you actually

1371
00:52:45,640 --> 00:52:49,119
want a system that's instant that gives

1372
00:52:47,520 --> 00:52:51,240
you an initial version instantly back

1373
00:52:49,119 --> 00:52:53,839
and then you can iterate super super

1374
00:52:51,240 --> 00:52:56,640
quickly uh what about something like

1375
00:52:53,839 --> 00:52:58,839
that recently came out rep agent that

1376
00:52:56,640 --> 00:53:00,240
does also like setting up the

1377
00:52:58,839 --> 00:53:02,280
development environment installing

1378
00:53:00,240 --> 00:53:04,240
software packages configuring everything

1379
00:53:02,280 --> 00:53:07,359
configuring the databases and actually

1380
00:53:04,240 --> 00:53:10,040
deploying the app yeah is that also in

1381
00:53:07,359 --> 00:53:11,280
the set of things you dream about I

1382
00:53:10,040 --> 00:53:13,000
think so I think that would be really

1383
00:53:11,280 --> 00:53:14,960
cool for for certain types of

1384
00:53:13,000 --> 00:53:18,119
programming uh it it would be really

1385
00:53:14,960 --> 00:53:20,200
cool is that within scope of cursor yeah

1386
00:53:18,119 --> 00:53:23,000
we're aren't actively working on it

1387
00:53:20,200 --> 00:53:26,040
right now um but it's definitely like we

1388
00:53:23,000 --> 00:53:29,119
want to make the programmer's life

1389
00:53:26,040 --> 00:53:30,599
easier and more fun and some things are

1390
00:53:29,119 --> 00:53:32,040
just really tedious and you need to go

1391
00:53:30,599 --> 00:53:34,520
through a bunch of steps and you want to

1392
00:53:32,040 --> 00:53:35,720
delegate that to an agent um and then

1393
00:53:34,520 --> 00:53:37,280
some things you can actually have an

1394
00:53:35,720 --> 00:53:39,599
agent in the background while you're

1395
00:53:37,280 --> 00:53:41,599
working like let's say you have a PR

1396
00:53:39,599 --> 00:53:42,640
that's both backend and front end and

1397
00:53:41,599 --> 00:53:44,760
you're working in the front end and then

1398
00:53:42,640 --> 00:53:46,520
you can have a background agent that

1399
00:53:44,760 --> 00:53:48,440
doesn't work and figure out kind of what

1400
00:53:46,520 --> 00:53:50,880
you're doing and then when you get to

1401
00:53:48,440 --> 00:53:52,880
the backend part of your PR then you

1402
00:53:50,880 --> 00:53:56,319
have some like initial piece of code

1403
00:53:52,880 --> 00:53:58,839
that you can iterate on um and and so

1404
00:53:56,319 --> 00:54:00,520
that that would also be really cool one

1405
00:53:58,839 --> 00:54:03,599
of the things we already talked about is

1406
00:54:00,520 --> 00:54:05,319
speed but I wonder if we can just uh

1407
00:54:03,599 --> 00:54:08,680
Linger on that some more in the the

1408
00:54:05,319 --> 00:54:11,040
various places that uh the technical

1409
00:54:08,680 --> 00:54:13,599
details involved in making this thing

1410
00:54:11,040 --> 00:54:15,480
really fast so every single aspect of

1411
00:54:13,599 --> 00:54:17,280
cursor most aspects of cursor feel

1412
00:54:15,480 --> 00:54:19,040
really fast like I mentioned the apply

1413
00:54:17,280 --> 00:54:21,119
is probably the slowest thing and for me

1414
00:54:19,040 --> 00:54:23,440
from sorry the

1415
00:54:21,119 --> 00:54:25,400
pain I know it's it's a pain it's a pain

1416
00:54:23,440 --> 00:54:27,599
that we're feeling and we're working on

1417
00:54:25,400 --> 00:54:29,359
fixing it uh

1418
00:54:27,599 --> 00:54:30,599
yeah I mean it says something that

1419
00:54:29,359 --> 00:54:33,280
something that feels I don't know what

1420
00:54:30,599 --> 00:54:36,200
it is like 1 second or two seconds that

1421
00:54:33,280 --> 00:54:37,920
feels slow that means that's actually

1422
00:54:36,200 --> 00:54:40,200
shows that everything else is just

1423
00:54:37,920 --> 00:54:41,720
really really fast um so is there some

1424
00:54:40,200 --> 00:54:43,760
technical details about how to make some

1425
00:54:41,720 --> 00:54:47,520
of these models so how to make the chat

1426
00:54:43,760 --> 00:54:49,520
fast how to make the diffs fast is there

1427
00:54:47,520 --> 00:54:50,880
something that just jumps to mind yeah I

1428
00:54:49,520 --> 00:54:52,520
mean so we can go over a lot of the

1429
00:54:50,880 --> 00:54:56,079
strategies that we use one interesting

1430
00:54:52,520 --> 00:55:00,319
thing is Cash Waring um and so what you

1431
00:54:56,079 --> 00:55:02,319
can is if as the user is typing you can

1432
00:55:00,319 --> 00:55:05,280
have yeah you're you're probably going

1433
00:55:02,319 --> 00:55:06,720
to use uh some piece of context and you

1434
00:55:05,280 --> 00:55:09,599
can know that before the user's done

1435
00:55:06,720 --> 00:55:12,599
typing so you know as we discussed

1436
00:55:09,599 --> 00:55:15,040
before reusing the KV cache results and

1437
00:55:12,599 --> 00:55:17,040
lower latency lower cost uh cross

1438
00:55:15,040 --> 00:55:19,200
requests so as a user starts type in you

1439
00:55:17,040 --> 00:55:21,440
can immediately warm the cache with like

1440
00:55:19,200 --> 00:55:24,160
let's say the current file contents and

1441
00:55:21,440 --> 00:55:26,079
then when theyve pressed enter uh

1442
00:55:24,160 --> 00:55:27,720
there's very few tokens it actually has

1443
00:55:26,079 --> 00:55:29,079
to to prefill and compute before

1444
00:55:27,720 --> 00:55:31,720
starting the generation this will

1445
00:55:29,079 --> 00:55:34,559
significantly lower ttf can you explain

1446
00:55:31,720 --> 00:55:39,559
how KV cach works yeah so the way

1447
00:55:34,559 --> 00:55:42,000
Transformers work um I like it I

1448
00:55:39,559 --> 00:55:44,280
mean like one one of the mechanisms that

1449
00:55:42,000 --> 00:55:46,119
allow Transformers to not just

1450
00:55:44,280 --> 00:55:47,280
independently like the mechanism that

1451
00:55:46,119 --> 00:55:48,960
allows Transformers to not just

1452
00:55:47,280 --> 00:55:51,640
independently look at each token but see

1453
00:55:48,960 --> 00:55:54,000
previous tokens are the keys and values

1454
00:55:51,640 --> 00:55:57,000
to tension and generally the way tension

1455
00:55:54,000 --> 00:55:59,799
works is you have at your current token

1456
00:55:57,000 --> 00:56:01,640
some query and then you've all the keys

1457
00:55:59,799 --> 00:56:04,000
and values of all your previous tokens

1458
00:56:01,640 --> 00:56:05,839
which are some kind of representation

1459
00:56:04,000 --> 00:56:09,559
that the model stores internally of all

1460
00:56:05,839 --> 00:56:12,280
the previous tokens in the prompt

1461
00:56:09,559 --> 00:56:14,920
and like by default when you're doing a

1462
00:56:12,280 --> 00:56:17,440
chat the model has to for every single

1463
00:56:14,920 --> 00:56:20,440
token do this forward pass through the

1464
00:56:17,440 --> 00:56:22,000
entire uh model that's a lot of Matrix

1465
00:56:20,440 --> 00:56:25,400
multiplies that happen and that is

1466
00:56:22,000 --> 00:56:27,039
really really slow instead if you have

1467
00:56:25,400 --> 00:56:29,640
already done that and you stored the

1468
00:56:27,039 --> 00:56:32,119
keys and values and you keep that in the

1469
00:56:29,640 --> 00:56:34,319
GPU then when I'm let's say I have

1470
00:56:32,119 --> 00:56:36,520
stored it for the last end tokens if I

1471
00:56:34,319 --> 00:56:39,880
now want to compute the the output token

1472
00:56:36,520 --> 00:56:42,400
for the N plus one token I don't need to

1473
00:56:39,880 --> 00:56:44,720
pass those first end tokens through the

1474
00:56:42,400 --> 00:56:47,119
entire model because I already have all

1475
00:56:44,720 --> 00:56:48,839
those keys and values and so you just

1476
00:56:47,119 --> 00:56:50,880
need to do the forward pass through that

1477
00:56:48,839 --> 00:56:53,680
last token and then when you're doing

1478
00:56:50,880 --> 00:56:55,039
attention uh you're reusing those keys

1479
00:56:53,680 --> 00:56:57,559
and values that have been computed which

1480
00:56:55,039 --> 00:56:58,960
is the only kind of sequential part um

1481
00:56:57,559 --> 00:57:01,520
or sequentially dependent part of the

1482
00:56:58,960 --> 00:57:04,280
Transformer is there like higher level

1483
00:57:01,520 --> 00:57:07,079
caching of like caching of the prompts

1484
00:57:04,280 --> 00:57:09,280
or that kind of stuff could help yeah

1485
00:57:07,079 --> 00:57:13,240
that that there's other types of caching

1486
00:57:09,280 --> 00:57:16,799
you can kind of do um one interesting

1487
00:57:13,240 --> 00:57:21,079
thing that you can do for cursor tab

1488
00:57:16,799 --> 00:57:22,440
is you can basically predict ahead as if

1489
00:57:21,079 --> 00:57:25,440
the user would have accepted the

1490
00:57:22,440 --> 00:57:26,760
suggestion and then trigger another uh

1491
00:57:25,440 --> 00:57:28,520
request

1492
00:57:26,760 --> 00:57:29,880
and so then you've cashed you've done

1493
00:57:28,520 --> 00:57:31,119
the speculative it's it's a mix of

1494
00:57:29,880 --> 00:57:32,880
speculation and caching right because

1495
00:57:31,119 --> 00:57:35,359
you're speculating what would happen if

1496
00:57:32,880 --> 00:57:37,680
they accepted it and then you have this

1497
00:57:35,359 --> 00:57:39,559
value that is cach this this uh

1498
00:57:37,680 --> 00:57:40,920
suggestion and then when they press tab

1499
00:57:39,559 --> 00:57:43,280
the next one would be waiting for them

1500
00:57:40,920 --> 00:57:46,079
immediately it's a it's a kind of clever

1501
00:57:43,280 --> 00:57:49,440
heuristic slash trick uh that uses a

1502
00:57:46,079 --> 00:57:52,319
higher level caching and and can give uh

1503
00:57:49,440 --> 00:57:53,839
the it feels fast despite there not

1504
00:57:52,319 --> 00:57:55,640
actually being any changes in the in the

1505
00:57:53,839 --> 00:57:57,799
model and if you can make the KV cach

1506
00:57:55,640 --> 00:57:59,640
smaller one of the advantages you get is

1507
00:57:57,799 --> 00:58:01,640
like maybe maybe you can speculate even

1508
00:57:59,640 --> 00:58:04,000
more maybe you can get seriously 10

1509
00:58:01,640 --> 00:58:07,359
things that you know could be useful I

1510
00:58:04,000 --> 00:58:09,400
like uh like predict the next 10 and and

1511
00:58:07,359 --> 00:58:11,319
then like it's possible the user hits

1512
00:58:09,400 --> 00:58:12,760
the the one of the 10 it's like much

1513
00:58:11,319 --> 00:58:15,000
higher chance than the user hits like

1514
00:58:12,760 --> 00:58:16,799
the exact one that you show them uh

1515
00:58:15,000 --> 00:58:18,160
maybe they typeing another character and

1516
00:58:16,799 --> 00:58:19,880
and he sort of hits hits something else

1517
00:58:18,160 --> 00:58:23,559
in the cache yeah so there's there's all

1518
00:58:19,880 --> 00:58:26,240
these tricks where um the the general

1519
00:58:23,559 --> 00:58:30,160
phenomena here is uh I think it's it's

1520
00:58:26,240 --> 00:58:32,039
also super useful for RL is you know may

1521
00:58:30,160 --> 00:58:34,760
maybe a single sample from the model

1522
00:58:32,039 --> 00:58:37,920
isn't very good but if you

1523
00:58:34,760 --> 00:58:40,440
predict like 10 different things uh

1524
00:58:37,920 --> 00:58:42,599
turns out that one of the 10 uh that's

1525
00:58:40,440 --> 00:58:44,960
right is the probability is much higher

1526
00:58:42,599 --> 00:58:47,599
there's these passid key curves and you

1527
00:58:44,960 --> 00:58:50,079
know part of RL like what what RL does

1528
00:58:47,599 --> 00:58:52,559
is you know you can you can exploit this

1529
00:58:50,079 --> 00:58:56,440
passid K phenomena to to make many

1530
00:58:52,559 --> 00:58:57,680
different predictions and and uh one one

1531
00:58:56,440 --> 00:59:00,000
way to think about this the model sort

1532
00:58:57,680 --> 00:59:01,839
of knows internally has like has some

1533
00:59:00,000 --> 00:59:03,599
uncertainty over like which of the key

1534
00:59:01,839 --> 00:59:05,799
things is correct or like which of the

1535
00:59:03,599 --> 00:59:10,440
key things does the human want when we

1536
00:59:05,799 --> 00:59:13,799
ARL our uh you know cursor Tab model one

1537
00:59:10,440 --> 00:59:16,640
of the things we're doing is we're

1538
00:59:13,799 --> 00:59:18,240
predicting which like which of the

1539
00:59:16,640 --> 00:59:20,520
hundred different suggestions the model

1540
00:59:18,240 --> 00:59:22,200
produces is more amendable for humans

1541
00:59:20,520 --> 00:59:24,960
like which of them do humans more like

1542
00:59:22,200 --> 00:59:26,520
than other things uh maybe maybe like

1543
00:59:24,960 --> 00:59:28,160
there's something with the model can

1544
00:59:26,520 --> 00:59:29,760
predict very far ahead versus like a

1545
00:59:28,160 --> 00:59:33,119
little bit and maybe somewhere in the

1546
00:59:29,760 --> 00:59:34,680
middle and and you just and then you can

1547
00:59:33,119 --> 00:59:36,839
give a reward to the things that humans

1548
00:59:34,680 --> 00:59:38,079
would like more and and sort of punish

1549
00:59:36,839 --> 00:59:39,680
the things that it would like and sort

1550
00:59:38,079 --> 00:59:40,960
of then train the model to Output the

1551
00:59:39,680 --> 00:59:42,480
suggestions that humans would like more

1552
00:59:40,960 --> 00:59:43,799
you you have these like RL Loops that

1553
00:59:42,480 --> 00:59:47,160
are very useful that exploit these

1554
00:59:43,799 --> 00:59:49,039
passive K curves um Oman maybe can can

1555
00:59:47,160 --> 00:59:50,280
go into even more detail yeah it's a

1556
00:59:49,039 --> 00:59:55,240
little it is a little different than

1557
00:59:50,280 --> 00:59:56,559
speed um but I mean like technically you

1558
00:59:55,240 --> 00:59:58,000
tie it back in because you can get away

1559
00:59:56,559 --> 00:59:59,440
with the smaller model if you are all

1560
00:59:58,000 --> 01:00:03,240
your smaller model and it gets the same

1561
00:59:59,440 --> 01:00:06,760
performance as the bigger one um that's

1562
01:00:03,240 --> 01:00:08,559
like and SW I was mentioning stuff about

1563
01:00:06,760 --> 01:00:09,680
KV about reducing the size of your KV

1564
01:00:08,559 --> 01:00:10,720
cach there there are other techniques

1565
01:00:09,680 --> 01:00:15,160
there as well that are really helpful

1566
01:00:10,720 --> 01:00:17,839
for Speed um so kind of back in the day

1567
01:00:15,160 --> 01:00:20,480
like all the way two years ago uh people

1568
01:00:17,839 --> 01:00:21,839
mainly use multi-ad attention um and I

1569
01:00:20,480 --> 01:00:24,760
think there's been a migration towards

1570
01:00:21,839 --> 01:00:28,799
more uh efficient attention schemes like

1571
01:00:24,760 --> 01:00:31,640
group query um or multiquery attention

1572
01:00:28,799 --> 01:00:34,160
and this is really helpful for then uh

1573
01:00:31,640 --> 01:00:36,760
with larger batch sizes being able to

1574
01:00:34,160 --> 01:00:40,240
generate the tokens much faster the

1575
01:00:36,760 --> 01:00:42,640
interesting thing here is um this now

1576
01:00:40,240 --> 01:00:45,640
has no effect on that uh time to First

1577
01:00:42,640 --> 01:00:48,839
token pre-fill speed uh the thing this

1578
01:00:45,640 --> 01:00:50,240
matters for is uh now generating tokens

1579
01:00:48,839 --> 01:00:53,880
and and why is that because when you're

1580
01:00:50,240 --> 01:00:55,960
generating tokens instead of uh being

1581
01:00:53,880 --> 01:00:58,000
bottlenecked by doing the super

1582
01:00:55,960 --> 01:01:00,000
realizable Matrix multiplies across all

1583
01:00:58,000 --> 01:01:03,359
your tokens you're bottleneck by how

1584
01:01:00,000 --> 01:01:05,079
quickly it's for long context um with

1585
01:01:03,359 --> 01:01:08,319
large batch sizes by how quickly you can

1586
01:01:05,079 --> 01:01:10,680
read those cache keys and values um and

1587
01:01:08,319 --> 01:01:12,680
so then how that that's memory bandwidth

1588
01:01:10,680 --> 01:01:14,359
and how can we make this faster we can

1589
01:01:12,680 --> 01:01:16,520
try to compress the size of these keys

1590
01:01:14,359 --> 01:01:19,559
and values so multiquery attention is

1591
01:01:16,520 --> 01:01:20,920
the most aggressive of these um where

1592
01:01:19,559 --> 01:01:22,960
normally with multi-head attention you

1593
01:01:20,920 --> 01:01:27,000
have some number of quote unquote

1594
01:01:22,960 --> 01:01:29,760
attention heads um and some number of

1595
01:01:27,000 --> 01:01:32,680
kind of query query heads U multiquery

1596
01:01:29,760 --> 01:01:35,799
just preserves the query heads gets rid

1597
01:01:32,680 --> 01:01:38,359
of all the key value heads um so there's

1598
01:01:35,799 --> 01:01:41,240
only one kind of key value head and

1599
01:01:38,359 --> 01:01:45,240
there's all the remaining uh query heads

1600
01:01:41,240 --> 01:01:49,240
with group query um you instead you know

1601
01:01:45,240 --> 01:01:52,119
preserve all the query heads and then

1602
01:01:49,240 --> 01:01:53,319
your keys and values are kind of in

1603
01:01:52,119 --> 01:01:54,880
there are fewer heads for the keys and

1604
01:01:53,319 --> 01:01:56,839
values but you're not reducing it to

1605
01:01:54,880 --> 01:01:58,359
just one um but anyways like the whole

1606
01:01:56,839 --> 01:02:01,440
point here is you're just reducing the

1607
01:01:58,359 --> 01:02:04,400
size of your KV cache and then there is

1608
01:02:01,440 --> 01:02:07,160
MLA yeah multi- latent um that's a

1609
01:02:04,400 --> 01:02:09,599
little more complicated and the way that

1610
01:02:07,160 --> 01:02:12,599
this works is it kind of turns the

1611
01:02:09,599 --> 01:02:14,760
entirety of your keys and values across

1612
01:02:12,599 --> 01:02:17,680
all your heads into this kind of one

1613
01:02:14,760 --> 01:02:21,079
latent Vector that is then kind of

1614
01:02:17,680 --> 01:02:24,160
expanded in frence time but MLA is from

1615
01:02:21,079 --> 01:02:26,279
this company uh called Deep seek um it's

1616
01:02:24,160 --> 01:02:30,079
it's quite an interesting algorithm uh

1617
01:02:26,279 --> 01:02:32,760
maybe the key idea is sort of uh in both

1618
01:02:30,079 --> 01:02:35,960
mqa uh and in other places what you're

1619
01:02:32,760 --> 01:02:38,880
doing is sort of reducing the uh num

1620
01:02:35,960 --> 01:02:42,000
like the number of KV heads the

1621
01:02:38,880 --> 01:02:45,680
advantage you get from that is is you

1622
01:02:42,000 --> 01:02:47,839
know there's less of them but uh maybe

1623
01:02:45,680 --> 01:02:50,480
the theory is that you actually want a

1624
01:02:47,839 --> 01:02:52,200
lot of different uh like you want each

1625
01:02:50,480 --> 01:02:54,039
of the the keys and values to actually

1626
01:02:52,200 --> 01:02:56,359
be different so one way to reduce the

1627
01:02:54,039 --> 01:03:00,599
size is you keep

1628
01:02:56,359 --> 01:03:01,839
uh one big shared Vector for all the

1629
01:03:00,599 --> 01:03:03,920
keys and values and then you have

1630
01:03:01,839 --> 01:03:05,880
smaller vectors for every single token

1631
01:03:03,920 --> 01:03:08,160
so that when you m you can you can store

1632
01:03:05,880 --> 01:03:10,480
the only the smaller thing as some sort

1633
01:03:08,160 --> 01:03:12,279
of like low rank reduction and the low

1634
01:03:10,480 --> 01:03:13,760
rank reduction with that and at the end

1635
01:03:12,279 --> 01:03:16,079
of the time when you when you eventually

1636
01:03:13,760 --> 01:03:17,640
want to compute the final thing uh

1637
01:03:16,079 --> 01:03:19,160
remember that like your memory bound

1638
01:03:17,640 --> 01:03:20,799
which means that like you still have

1639
01:03:19,160 --> 01:03:22,279
some some compute left that you can use

1640
01:03:20,799 --> 01:03:26,480
for these things and so if you can

1641
01:03:22,279 --> 01:03:29,079
expand the um the latent vector

1642
01:03:26,480 --> 01:03:31,839
back out and and somehow like this is

1643
01:03:29,079 --> 01:03:34,160
far more efficient because just like

1644
01:03:31,839 --> 01:03:35,559
you're reducing like for example maybe

1645
01:03:34,160 --> 01:03:37,240
like you're reducing like 32 or

1646
01:03:35,559 --> 01:03:38,839
something like the size of the vector

1647
01:03:37,240 --> 01:03:42,520
that you're keeping yeah there's perhaps

1648
01:03:38,839 --> 01:03:44,599
some richness in having a separate uh

1649
01:03:42,520 --> 01:03:46,400
set of keys and values and query that

1650
01:03:44,599 --> 01:03:48,200
kind of pawise match up versus

1651
01:03:46,400 --> 01:03:51,559
compressing that all into

1652
01:03:48,200 --> 01:03:54,319
one and that interaction at least okay

1653
01:03:51,559 --> 01:03:56,680
and all of that is dealing with um being

1654
01:03:54,319 --> 01:03:59,400
memory bound yeah

1655
01:03:56,680 --> 01:04:01,839
and what I mean ultimately how does that

1656
01:03:59,400 --> 01:04:03,559
map to the user experience trying to get

1657
01:04:01,839 --> 01:04:05,599
the yeah the the two things that it maps

1658
01:04:03,559 --> 01:04:08,520
to is you can now make your cash a lot

1659
01:04:05,599 --> 01:04:10,039
larger because you've less space

1660
01:04:08,520 --> 01:04:11,480
allocated for the KB cash you can maybe

1661
01:04:10,039 --> 01:04:14,079
cash a lot more aggressively and a lot

1662
01:04:11,480 --> 01:04:16,319
more things do you get more cash hits

1663
01:04:14,079 --> 01:04:18,200
which are helpful for reducing the time

1664
01:04:16,319 --> 01:04:19,839
to First token for the reasons that were

1665
01:04:18,200 --> 01:04:22,680
kind of described earlier and then the

1666
01:04:19,839 --> 01:04:24,039
second being when you start doing

1667
01:04:22,680 --> 01:04:26,039
inference with more and more requests

1668
01:04:24,039 --> 01:04:29,720
and larger and larger batch sizes you

1669
01:04:26,039 --> 01:04:31,680
don't see much of a Slowdown in as it's

1670
01:04:29,720 --> 01:04:32,839
generating the tokens the speed of that

1671
01:04:31,680 --> 01:04:35,599
what it also allows you to make your

1672
01:04:32,839 --> 01:04:38,400
prompt bigger for certain yeah yeah so

1673
01:04:35,599 --> 01:04:41,200
like the basic the size of your KV cache

1674
01:04:38,400 --> 01:04:42,839
is uh both the size of all your prompts

1675
01:04:41,200 --> 01:04:44,119
multiply by the number of prompts being

1676
01:04:42,839 --> 01:04:45,760
processed in parallel so you could

1677
01:04:44,119 --> 01:04:47,720
increase either those Dimensions right

1678
01:04:45,760 --> 01:04:50,680
the batch size or the size of your

1679
01:04:47,720 --> 01:04:53,000
prompts without degrading the latency of

1680
01:04:50,680 --> 01:04:55,480
generating tokens Arvid you wrote a blog

1681
01:04:53,000 --> 01:04:57,400
post Shadow workspace iterating on code

1682
01:04:55,480 --> 01:05:01,319
in the background yeah so what's going

1683
01:04:57,400 --> 01:05:03,000
on uh so to be clear we want there to be

1684
01:05:01,319 --> 01:05:04,599
a lot of stuff stuff happening in the

1685
01:05:03,000 --> 01:05:08,039
background and we're experimenting with

1686
01:05:04,599 --> 01:05:09,640
a lot of things uh right now uh we don't

1687
01:05:08,039 --> 01:05:11,960
have much of that happening other than

1688
01:05:09,640 --> 01:05:13,880
like the the cash warming or like you

1689
01:05:11,960 --> 01:05:15,520
know figuring out the right context to

1690
01:05:13,880 --> 01:05:18,319
that goes into your command PRS for

1691
01:05:15,520 --> 01:05:19,520
example uh but the idea is if you can

1692
01:05:18,319 --> 01:05:23,760
actually spend computation in the

1693
01:05:19,520 --> 01:05:27,079
background then you can help um help the

1694
01:05:23,760 --> 01:05:28,839
user maybe like at a slightly longer

1695
01:05:27,079 --> 01:05:30,760
time Horizon than just predicting the

1696
01:05:28,839 --> 01:05:32,839
next few lines that you're going to make

1697
01:05:30,760 --> 01:05:34,720
but actually like in the next 10 minutes

1698
01:05:32,839 --> 01:05:36,200
what are you're going to make and by

1699
01:05:34,720 --> 01:05:39,119
doing it in background you can spend

1700
01:05:36,200 --> 01:05:41,920
more comp computation doing that and so

1701
01:05:39,119 --> 01:05:43,400
the idea of the Shadow workspace that

1702
01:05:41,920 --> 01:05:46,720
that we implemented and we use it

1703
01:05:43,400 --> 01:05:49,720
internally for like experiments um is

1704
01:05:46,720 --> 01:05:51,760
that to actually get advantage of doing

1705
01:05:49,720 --> 01:05:54,079
stuff in the background you want some

1706
01:05:51,760 --> 01:05:55,799
kind of feedback signal to give give

1707
01:05:54,079 --> 01:05:57,760
back to the model because otherwise like

1708
01:05:55,799 --> 01:06:00,760
you can get higher performance by just

1709
01:05:57,760 --> 01:06:02,640
letting the model think for longer um

1710
01:06:00,760 --> 01:06:04,240
and and so like o1 is a good example of

1711
01:06:02,640 --> 01:06:06,559
that but another way you can improve

1712
01:06:04,240 --> 01:06:09,640
performance is by letting the model

1713
01:06:06,559 --> 01:06:11,279
iterate and get feedback and and so one

1714
01:06:09,640 --> 01:06:14,200
very important piece of feedback when

1715
01:06:11,279 --> 01:06:18,000
you're a programmer is um the language

1716
01:06:14,200 --> 01:06:20,160
server which is uh this thing it exists

1717
01:06:18,000 --> 01:06:21,839
uh for most different languages and

1718
01:06:20,160 --> 01:06:24,599
there's like a separate language Ser per

1719
01:06:21,839 --> 01:06:26,200
language and it can tell you you know

1720
01:06:24,599 --> 01:06:28,200
you're using the wrong type appear and

1721
01:06:26,200 --> 01:06:30,000
then gives you an error or it can allow

1722
01:06:28,200 --> 01:06:31,839
you to go to definition and sort of

1723
01:06:30,000 --> 01:06:34,079
understands the structure of your code

1724
01:06:31,839 --> 01:06:35,880
so language servers are extensions

1725
01:06:34,079 --> 01:06:37,400
developed by like there's a typescript

1726
01:06:35,880 --> 01:06:39,319
language Ser developed by the typescript

1727
01:06:37,400 --> 01:06:41,000
people a rust language Ser developed by

1728
01:06:39,319 --> 01:06:42,319
the rust people and then they all inter

1729
01:06:41,000 --> 01:06:44,240
interface over the language server

1730
01:06:42,319 --> 01:06:45,599
protocol to vs code so that vs code

1731
01:06:44,240 --> 01:06:47,440
doesn't need to have all of the

1732
01:06:45,599 --> 01:06:49,359
different languages built into vs code

1733
01:06:47,440 --> 01:06:51,440
but rather uh you can use the existing

1734
01:06:49,359 --> 01:06:53,640
compiler infrastructure for linting

1735
01:06:51,440 --> 01:06:56,640
purposes what it's for it's for linting

1736
01:06:53,640 --> 01:06:58,359
it's for going to definition uh and for

1737
01:06:56,640 --> 01:07:00,480
like seeing the the right types that

1738
01:06:58,359 --> 01:07:02,720
you're using uh so it's doing like type

1739
01:07:00,480 --> 01:07:05,640
checking also yes type checking and and

1740
01:07:02,720 --> 01:07:07,240
going to references um and that's like

1741
01:07:05,640 --> 01:07:08,920
when you're working in a big project you

1742
01:07:07,240 --> 01:07:11,400
you kind of need that if you if you

1743
01:07:08,920 --> 01:07:13,440
don't have that it's like really hard to

1744
01:07:11,400 --> 01:07:15,640
to code in a big project can you say

1745
01:07:13,440 --> 01:07:19,039
again how that's being used inside

1746
01:07:15,640 --> 01:07:21,079
cursor the the language server protocol

1747
01:07:19,039 --> 01:07:22,640
communication thing so it's being used

1748
01:07:21,079 --> 01:07:24,799
in cursor to show to the programmer just

1749
01:07:22,640 --> 01:07:27,640
like nvs could but then the idea is you

1750
01:07:24,799 --> 01:07:30,960
want to show that same information to

1751
01:07:27,640 --> 01:07:32,720
the models the I models um and you want

1752
01:07:30,960 --> 01:07:34,160
to do that in a way that doesn't affect

1753
01:07:32,720 --> 01:07:36,480
the user because you wanted to do it in

1754
01:07:34,160 --> 01:07:39,319
background and so the idea behind the

1755
01:07:36,480 --> 01:07:43,160
chadow workspace was okay like one way

1756
01:07:39,319 --> 01:07:46,920
we can do this is um we spawn a separate

1757
01:07:43,160 --> 01:07:48,480
window of cursor that's hidden and so

1758
01:07:46,920 --> 01:07:49,920
you can set this flag and electron is

1759
01:07:48,480 --> 01:07:51,680
hidden there is a window but you don't

1760
01:07:49,920 --> 01:07:54,520
actually see it and inside of this

1761
01:07:51,680 --> 01:07:56,480
window uh the AI agents can modify code

1762
01:07:54,520 --> 01:07:57,720
however they want um as long as they

1763
01:07:56,480 --> 01:08:00,720
don't save it because it's still the

1764
01:07:57,720 --> 01:08:02,559
same folder um and then can get feedback

1765
01:08:00,720 --> 01:08:04,359
from from the lters and go to definition

1766
01:08:02,559 --> 01:08:06,079
and and iterate on their code so like

1767
01:08:04,359 --> 01:08:09,400
literally run everything in the

1768
01:08:06,079 --> 01:08:12,480
background like as if right yeah maybe

1769
01:08:09,400 --> 01:08:14,279
even run the code so that's the eventual

1770
01:08:12,480 --> 01:08:16,319
version okay that's what you want and a

1771
01:08:14,279 --> 01:08:19,480
lot of the blog post is actually about

1772
01:08:16,319 --> 01:08:21,520
how do you make that happen because it's

1773
01:08:19,480 --> 01:08:23,839
a little bit tricky you want it to be on

1774
01:08:21,520 --> 01:08:25,960
the user's machine so that it exactly

1775
01:08:23,839 --> 01:08:28,480
mirrors the user's environment

1776
01:08:25,960 --> 01:08:30,520
and then on Linux you can do this cool

1777
01:08:28,480 --> 01:08:34,759
thing where you can actually mirror the

1778
01:08:30,520 --> 01:08:36,920
file system and have the AI make changes

1779
01:08:34,759 --> 01:08:40,000
to the files and and it thinks that it's

1780
01:08:36,920 --> 01:08:43,520
operating on the file level but actually

1781
01:08:40,000 --> 01:08:45,799
that's stored in in memory and you you

1782
01:08:43,520 --> 01:08:49,480
can uh create this kernel extension to

1783
01:08:45,799 --> 01:08:52,319
to make it work um whereas on Mac and

1784
01:08:49,480 --> 01:08:55,480
windows it's a little bit more difficult

1785
01:08:52,319 --> 01:08:57,600
uh and and uh but it's it's a fun

1786
01:08:55,480 --> 01:08:59,400
technical problems that's way one one

1787
01:08:57,600 --> 01:09:02,960
maybe hacky but interesting idea that I

1788
01:08:59,400 --> 01:09:04,480
like is holding a lock on saving and so

1789
01:09:02,960 --> 01:09:06,719
basically you can then have the language

1790
01:09:04,480 --> 01:09:08,640
model kind of hold the lock on on saving

1791
01:09:06,719 --> 01:09:10,400
to disk and then instead of you

1792
01:09:08,640 --> 01:09:12,359
operating in the ground truth version of

1793
01:09:10,400 --> 01:09:13,719
the files uh that are save to dis you

1794
01:09:12,359 --> 01:09:15,000
you actually are operating what was the

1795
01:09:13,719 --> 01:09:16,560
shadow workspace before and these

1796
01:09:15,000 --> 01:09:17,880
unsaved things that only exist in memory

1797
01:09:16,560 --> 01:09:19,920
that you still get Lind erors for and

1798
01:09:17,880 --> 01:09:22,279
you can code in and then when you try to

1799
01:09:19,920 --> 01:09:24,120
maybe run code it's just like there's a

1800
01:09:22,279 --> 01:09:25,839
small warning that there's a lock and

1801
01:09:24,120 --> 01:09:27,120
then you kind of will take back the lock

1802
01:09:25,839 --> 01:09:28,839
from the language server if you're

1803
01:09:27,120 --> 01:09:29,880
trying to do things concurrently or from

1804
01:09:28,839 --> 01:09:31,839
the the shadow workspace if you're

1805
01:09:29,880 --> 01:09:33,920
trying to do things concurrently that's

1806
01:09:31,839 --> 01:09:36,080
such an exciting feuture by the way it's

1807
01:09:33,920 --> 01:09:39,560
a bit of a tangent but like to allow a

1808
01:09:36,080 --> 01:09:42,279
model to change files it's scary for

1809
01:09:39,560 --> 01:09:45,279
people but like it's really cool to be

1810
01:09:42,279 --> 01:09:47,960
able to just like let the agent do a set

1811
01:09:45,279 --> 01:09:50,080
of tasks and you come back the next day

1812
01:09:47,960 --> 01:09:52,199
and kind of observe like it's a

1813
01:09:50,080 --> 01:09:53,480
colleague or something like that yeah

1814
01:09:52,199 --> 01:09:55,800
yeah and I think there may be different

1815
01:09:53,480 --> 01:09:58,199
versions of like runability

1816
01:09:55,800 --> 01:09:59,520
where for the simple things where you're

1817
01:09:58,199 --> 01:10:01,199
doing things in the span of a few

1818
01:09:59,520 --> 01:10:03,920
minutes on behalf of the user as they're

1819
01:10:01,199 --> 01:10:05,719
programming it makes sense to make

1820
01:10:03,920 --> 01:10:07,120
something work locally in their machine

1821
01:10:05,719 --> 01:10:08,760
I think for the more aggressive things

1822
01:10:07,120 --> 01:10:10,520
where you're making larger changes that

1823
01:10:08,760 --> 01:10:12,440
take longer periods of time you'll

1824
01:10:10,520 --> 01:10:14,320
probably want to do this in some sandbox

1825
01:10:12,440 --> 01:10:17,760
remote environment and that's another

1826
01:10:14,320 --> 01:10:20,239
incredibly tricky problem of how do you

1827
01:10:17,760 --> 01:10:22,040
exactly reproduce or mostly reproduce to

1828
01:10:20,239 --> 01:10:24,040
the point of it being effectively

1829
01:10:22,040 --> 01:10:26,400
equivalent for running code the user's

1830
01:10:24,040 --> 01:10:28,480
environment which is remote remote

1831
01:10:26,400 --> 01:10:32,080
sandbox I'm curious what kind of Agents

1832
01:10:28,480 --> 01:10:33,840
you want for for coding oh do you want

1833
01:10:32,080 --> 01:10:35,960
them to find bugs do you want them to

1834
01:10:33,840 --> 01:10:37,760
like Implement new features like what

1835
01:10:35,960 --> 01:10:39,480
agents do you want so by the way when I

1836
01:10:37,760 --> 01:10:42,880
think about agents I don't think just

1837
01:10:39,480 --> 01:10:45,280
about coding uh I think so for the

1838
01:10:42,880 --> 01:10:47,199
practic this particular podcast there's

1839
01:10:45,280 --> 01:10:50,239
video editing and a lot of if you look

1840
01:10:47,199 --> 01:10:52,320
in Adobe a lot there's code behind uh

1841
01:10:50,239 --> 01:10:55,280
it's very poorly documented code but you

1842
01:10:52,320 --> 01:10:57,880
can interact with premiere for example

1843
01:10:55,280 --> 01:10:59,679
using code and basically all the

1844
01:10:57,880 --> 01:11:01,440
uploading everything I do on YouTube

1845
01:10:59,679 --> 01:11:03,800
everything as you could probably imagine

1846
01:11:01,440 --> 01:11:05,679
I do all of that through code and so and

1847
01:11:03,800 --> 01:11:09,560
including translation and overdubbing

1848
01:11:05,679 --> 01:11:11,800
all this so I Envision all those kinds

1849
01:11:09,560 --> 01:11:13,239
of tasks so automating many of the tasks

1850
01:11:11,800 --> 01:11:16,520
that don't have to do directly with the

1851
01:11:13,239 --> 01:11:19,640
editing so that okay that's what I was

1852
01:11:16,520 --> 01:11:22,840
thinking about but in terms of coding I

1853
01:11:19,640 --> 01:11:24,080
would be fundamentally thinking about

1854
01:11:22,840 --> 01:11:27,080
bug

1855
01:11:24,080 --> 01:11:28,760
finding like many levels of kind of bug

1856
01:11:27,080 --> 01:11:31,480
finding and also bug finding like

1857
01:11:28,760 --> 01:11:33,239
logical bugs not logical like spiritual

1858
01:11:31,480 --> 01:11:35,800
bugs or

1859
01:11:33,239 --> 01:11:37,679
something one's like sort of big

1860
01:11:35,800 --> 01:11:40,199
directions of implementation that kind

1861
01:11:37,679 --> 01:11:42,120
of stuff that's Bine on Buck finding

1862
01:11:40,199 --> 01:11:45,560
yeah I mean it's really interesting that

1863
01:11:42,120 --> 01:11:48,440
these models are so bad at bug finding

1864
01:11:45,560 --> 01:11:51,400
uh when just naively prompted to find a

1865
01:11:48,440 --> 01:11:53,360
bug they're incredibly poorly calibrated

1866
01:11:51,400 --> 01:11:56,400
even the the smartest models exactly

1867
01:11:53,360 --> 01:11:57,760
even o even 01 how do you explain that

1868
01:11:56,400 --> 01:12:00,280
is there a good

1869
01:11:57,760 --> 01:12:02,719
intuition I think these models are a

1870
01:12:00,280 --> 01:12:05,600
really strong reflection of the

1871
01:12:02,719 --> 01:12:07,080
pre-training distribution and you know I

1872
01:12:05,600 --> 01:12:08,920
do think they they generalize as the

1873
01:12:07,080 --> 01:12:11,000
loss gets lower and lower but I don't

1874
01:12:08,920 --> 01:12:13,480
think the the loss and the scale is

1875
01:12:11,000 --> 01:12:15,480
quite or the loss is low enough such

1876
01:12:13,480 --> 01:12:16,719
that they're like really fully

1877
01:12:15,480 --> 01:12:18,679
generalizing in code like the things

1878
01:12:16,719 --> 01:12:21,000
that we use these things for uh the

1879
01:12:18,679 --> 01:12:23,800
frontier models that that they're quite

1880
01:12:21,000 --> 01:12:27,480
good at are really code generation and

1881
01:12:23,800 --> 01:12:29,760
question answering these things exist in

1882
01:12:27,480 --> 01:12:31,199
massive quantities and pre-training with

1883
01:12:29,760 --> 01:12:34,400
all of the code on GitHub on the scale

1884
01:12:31,199 --> 01:12:36,040
of many many trillions of tokens and

1885
01:12:34,400 --> 01:12:39,239
questions and answers on things like

1886
01:12:36,040 --> 01:12:41,440
stack Overflow and maybe GitHub issues

1887
01:12:39,239 --> 01:12:44,719
and so when you try to push some of

1888
01:12:41,440 --> 01:12:47,719
these things that really don't exist uh

1889
01:12:44,719 --> 01:12:49,159
very much online like for example the

1890
01:12:47,719 --> 01:12:51,880
cursor tap objective of predicting the

1891
01:12:49,159 --> 01:12:53,760
next edit given the edit's done so far

1892
01:12:51,880 --> 01:12:55,199
uh the brittleness kind of shows and

1893
01:12:53,760 --> 01:12:57,239
then bug detection is another great

1894
01:12:55,199 --> 01:12:59,080
example where there aren't really that

1895
01:12:57,239 --> 01:13:02,719
many examples of like actually detecting

1896
01:12:59,080 --> 01:13:04,600
real bugs and then proposing fixes um

1897
01:13:02,719 --> 01:13:06,920
and the models just kind of like really

1898
01:13:04,600 --> 01:13:08,639
struggle at it but I think it's a

1899
01:13:06,920 --> 01:13:09,920
question of transferring the model like

1900
01:13:08,639 --> 01:13:12,719
in the same way that you get this

1901
01:13:09,920 --> 01:13:15,280
fantastic transfer um from pre-trained

1902
01:13:12,719 --> 01:13:17,520
Models uh just on code in general to the

1903
01:13:15,280 --> 01:13:20,120
cursor tab objective uh you'll see a

1904
01:13:17,520 --> 01:13:21,719
very very similar thing with generalized

1905
01:13:20,120 --> 01:13:23,239
models that are really good to code to

1906
01:13:21,719 --> 01:13:24,560
bug detection it just takes like a

1907
01:13:23,239 --> 01:13:26,280
little bit of kind of nudging in that

1908
01:13:24,560 --> 01:13:28,840
direction like to be clear I think they

1909
01:13:26,280 --> 01:13:31,719
sort of understand code really well like

1910
01:13:28,840 --> 01:13:33,480
while they're being pre-trained like the

1911
01:13:31,719 --> 01:13:35,920
representation that's being built up

1912
01:13:33,480 --> 01:13:38,199
like almost certainly like you know

1913
01:13:35,920 --> 01:13:40,320
Somewhere In The Stream there's the

1914
01:13:38,199 --> 01:13:42,040
model knows that maybe there's there's

1915
01:13:40,320 --> 01:13:44,360
some SK something sketchy going on right

1916
01:13:42,040 --> 01:13:46,840
it sort of has some sketchiness but

1917
01:13:44,360 --> 01:13:51,360
actually eliciting this the sketchiness

1918
01:13:46,840 --> 01:13:53,120
to uh like actually like part part of it

1919
01:13:51,360 --> 01:13:55,560
is that humans are really calibrated on

1920
01:13:53,120 --> 01:13:56,880
which bugs are really important it's not

1921
01:13:55,560 --> 01:13:58,080
just actually it's not just actually

1922
01:13:56,880 --> 01:14:00,639
saying like there's something sketchy

1923
01:13:58,080 --> 01:14:01,880
it's like it's just sketchy trivial it's

1924
01:14:00,639 --> 01:14:04,280
the sketchy like you're going to take

1925
01:14:01,880 --> 01:14:07,040
the server down it's like like part of

1926
01:14:04,280 --> 01:14:08,800
it is maybe the cultural knowledge of uh

1927
01:14:07,040 --> 01:14:10,760
like why is a staff engineer a staff

1928
01:14:08,800 --> 01:14:12,960
engineer a staff engineer is is good

1929
01:14:10,760 --> 01:14:15,080
because they know that three years ago

1930
01:14:12,960 --> 01:14:17,000
like someone wrote a really you know

1931
01:14:15,080 --> 01:14:20,400
sketchy piece of code that took took the

1932
01:14:17,000 --> 01:14:22,840
server down and as opposed to like as

1933
01:14:20,400 --> 01:14:26,199
supposed to maybe it's like you know you

1934
01:14:22,840 --> 01:14:27,719
just this thing is like an experiment so

1935
01:14:26,199 --> 01:14:29,199
like a few bugs are fine like you're

1936
01:14:27,719 --> 01:14:31,040
just trying to experiment and get the

1937
01:14:29,199 --> 01:14:32,440
feel of the thing and so if the model

1938
01:14:31,040 --> 01:14:34,760
gets really annoying when you're writing

1939
01:14:32,440 --> 01:14:36,520
an experiment that's really bad but if

1940
01:14:34,760 --> 01:14:37,600
you're writing something for super

1941
01:14:36,520 --> 01:14:38,920
production you're like writing a

1942
01:14:37,600 --> 01:14:40,360
database right you're you're writing

1943
01:14:38,920 --> 01:14:42,239
code in post scripts or Linux or

1944
01:14:40,360 --> 01:14:44,199
whatever like your lineus tals you're

1945
01:14:42,239 --> 01:14:46,520
you're it's sort of unacceptable to have

1946
01:14:44,199 --> 01:14:48,239
even a edge case and just having the

1947
01:14:46,520 --> 01:14:51,960
calibration of

1948
01:14:48,239 --> 01:14:53,520
like how paranoid is the user like but

1949
01:14:51,960 --> 01:14:56,239
even then like if you're putting in a

1950
01:14:53,520 --> 01:14:58,960
maximum paranoia it still just like

1951
01:14:56,239 --> 01:15:01,800
doesn't quite get it yeah yeah yeah I

1952
01:14:58,960 --> 01:15:03,800
mean but this is hard for humans too to

1953
01:15:01,800 --> 01:15:06,199
understand what which line of code is

1954
01:15:03,800 --> 01:15:07,520
important which is not it's like you I

1955
01:15:06,199 --> 01:15:09,760
think one of your principles on a

1956
01:15:07,520 --> 01:15:10,639
website says if if if a code can do a

1957
01:15:09,760 --> 01:15:13,719
lot of

1958
01:15:10,639 --> 01:15:16,040
damage one should add a comment that say

1959
01:15:13,719 --> 01:15:18,400
this this this line of code is is

1960
01:15:16,040 --> 01:15:23,159
dangerous and all

1961
01:15:18,400 --> 01:15:25,520
caps 10 times no you say like for every

1962
01:15:23,159 --> 01:15:28,080
single line of code inside the function

1963
01:15:25,520 --> 01:15:30,199
you have to and that's quite profound

1964
01:15:28,080 --> 01:15:33,679
that says something about human beings

1965
01:15:30,199 --> 01:15:36,639
because the the engineers move on even

1966
01:15:33,679 --> 01:15:38,480
the same person might just forget how it

1967
01:15:36,639 --> 01:15:40,480
can sync the Titanic a single function

1968
01:15:38,480 --> 01:15:42,120
like you don't you might not in it that

1969
01:15:40,480 --> 01:15:44,000
quite clearly by looking at the single

1970
01:15:42,120 --> 01:15:46,920
piece of code yeah and I think that that

1971
01:15:44,000 --> 01:15:49,880
one is also uh partially also for

1972
01:15:46,920 --> 01:15:51,360
today's AI models where uh if you

1973
01:15:49,880 --> 01:15:54,440
actually write dangerous dangerous

1974
01:15:51,360 --> 01:15:56,960
dangerous in every single line like uh

1975
01:15:54,440 --> 01:15:59,400
the models will pay more attention to

1976
01:15:56,960 --> 01:16:01,199
that and will be more likely to find

1977
01:15:59,400 --> 01:16:03,679
bucks in that region that's actually

1978
01:16:01,199 --> 01:16:07,040
just straight up a really good practice

1979
01:16:03,679 --> 01:16:08,960
of a labeling code of how much damage

1980
01:16:07,040 --> 01:16:10,760
this can do yeah I mean it's

1981
01:16:08,960 --> 01:16:13,719
controversial like some people think

1982
01:16:10,760 --> 01:16:15,960
it's ugly uh swall well I actually think

1983
01:16:13,719 --> 01:16:17,560
it's it's like in fact I actually think

1984
01:16:15,960 --> 01:16:21,080
this one of the things I learned from AR

1985
01:16:17,560 --> 01:16:23,480
is you know like I sort of aesthetically

1986
01:16:21,080 --> 01:16:25,080
I don't like it but I think there's

1987
01:16:23,480 --> 01:16:27,320
certainly something where like it's it's

1988
01:16:25,080 --> 01:16:29,440
useful for the models and and humans

1989
01:16:27,320 --> 01:16:32,040
just forget a lot and it's really easy

1990
01:16:29,440 --> 01:16:34,520
to make a small mistake and cause

1991
01:16:32,040 --> 01:16:37,560
like bring down you know like just bring

1992
01:16:34,520 --> 01:16:39,040
down the server and like you like of

1993
01:16:37,560 --> 01:16:41,120
course we we like test a lot and

1994
01:16:39,040 --> 01:16:42,639
whatever but there there's always these

1995
01:16:41,120 --> 01:16:44,360
things that you have to be very careful

1996
01:16:42,639 --> 01:16:46,280
yeah like with just normal dock strings

1997
01:16:44,360 --> 01:16:48,320
I think people will often just skim it

1998
01:16:46,280 --> 01:16:51,520
when making a change and think oh this I

1999
01:16:48,320 --> 01:16:53,480
I know how to do this um and you kind of

2000
01:16:51,520 --> 01:16:55,880
really need to point it out to them so

2001
01:16:53,480 --> 01:16:57,199
that that doesn't slip through

2002
01:16:55,880 --> 01:16:58,639
yeah you have to be reminded that you

2003
01:16:57,199 --> 01:17:00,679
could do a lot of

2004
01:16:58,639 --> 01:17:02,719
damage that's like we don't really think

2005
01:17:00,679 --> 01:17:04,920
about that like yeah you think about

2006
01:17:02,719 --> 01:17:06,199
okay how do I figure out how this work

2007
01:17:04,920 --> 01:17:08,920
so I can improve it you don't think

2008
01:17:06,199 --> 01:17:11,520
about the other direction that could

2009
01:17:08,920 --> 01:17:13,760
until until we have formal verification

2010
01:17:11,520 --> 01:17:16,560
for everything then you can do whatever

2011
01:17:13,760 --> 01:17:17,920
you want and you you know for certain

2012
01:17:16,560 --> 01:17:19,679
that you have not introduced a bug if

2013
01:17:17,920 --> 01:17:22,400
the proof passes but concretely what do

2014
01:17:19,679 --> 01:17:25,639
you think that future would look like I

2015
01:17:22,400 --> 01:17:29,960
think um people will just write tests

2016
01:17:25,639 --> 01:17:31,800
anymore and um the model will suggest

2017
01:17:29,960 --> 01:17:34,280
like you write a function the model will

2018
01:17:31,800 --> 01:17:37,719
suggest a spec and you review the spec

2019
01:17:34,280 --> 01:17:39,840
and uh in the meantime a smart reasoning

2020
01:17:37,719 --> 01:17:42,320
model computes appr proof that the

2021
01:17:39,840 --> 01:17:43,600
implementation follows the spec um and I

2022
01:17:42,320 --> 01:17:45,800
think that happens for for most

2023
01:17:43,600 --> 01:17:47,000
functions don't you think this gets at a

2024
01:17:45,800 --> 01:17:48,320
little bit some of the stuff you were

2025
01:17:47,000 --> 01:17:49,600
talking about earlier with the

2026
01:17:48,320 --> 01:17:52,199
difficulty of specifying intent for what

2027
01:17:49,600 --> 01:17:53,920
you want with software um where

2028
01:17:52,199 --> 01:17:55,440
sometimes it might be because the intent

2029
01:17:53,920 --> 01:17:56,760
is really hard to specify it's also then

2030
01:17:55,440 --> 01:17:57,880
going to be really hard to prove that

2031
01:17:56,760 --> 01:17:59,679
it's actually matching whatever your

2032
01:17:57,880 --> 01:18:00,920
intent is like you think that spec is

2033
01:17:59,679 --> 01:18:06,239
hard to

2034
01:18:00,920 --> 01:18:08,440
generate yeah or just like for a given

2035
01:18:06,239 --> 01:18:09,600
spec maybe you can I think there is a

2036
01:18:08,440 --> 01:18:12,080
question of like can you actually do the

2037
01:18:09,600 --> 01:18:13,719
formal verification like that's like is

2038
01:18:12,080 --> 01:18:15,960
that possible I think that there's like

2039
01:18:13,719 --> 01:18:17,800
more to dig into there but then also

2040
01:18:15,960 --> 01:18:19,760
even if you have this spe if you have

2041
01:18:17,800 --> 01:18:21,480
this spe how do you you have the spec is

2042
01:18:19,760 --> 01:18:24,840
the spec written in natural

2043
01:18:21,480 --> 01:18:26,320
language the spec spec would be formal

2044
01:18:24,840 --> 01:18:28,080
but how easy would that be so then I

2045
01:18:26,320 --> 01:18:29,199
think that you care about things that

2046
01:18:28,080 --> 01:18:31,239
are not going to be easily well

2047
01:18:29,199 --> 01:18:33,920
specified in the spec language I see I

2048
01:18:31,239 --> 01:18:35,400
see would be um yeah maybe an argument

2049
01:18:33,920 --> 01:18:37,639
against formal verification is all you

2050
01:18:35,400 --> 01:18:39,159
need yeah the worry is there's this

2051
01:18:37,639 --> 01:18:43,360
massive document replacing replacing

2052
01:18:39,159 --> 01:18:45,600
something like unitest sure yeah yeah um

2053
01:18:43,360 --> 01:18:48,040
I think you can probably also evolve the

2054
01:18:45,600 --> 01:18:50,320
the spec languages to capture some of

2055
01:18:48,040 --> 01:18:53,239
the things that they don't really

2056
01:18:50,320 --> 01:18:55,120
capture right now um but yeah I don't

2057
01:18:53,239 --> 01:18:56,679
know I think it's very exciting and

2058
01:18:55,120 --> 01:18:58,719
you're speaking not just about like

2059
01:18:56,679 --> 01:19:00,920
single functions you're speaking about

2060
01:18:58,719 --> 01:19:03,080
entire code bases I think entire code

2061
01:19:00,920 --> 01:19:05,120
bases is harder but that that is what I

2062
01:19:03,080 --> 01:19:07,440
would love to have and I think it should

2063
01:19:05,120 --> 01:19:08,679
be possible and because you can even

2064
01:19:07,440 --> 01:19:12,280
there there's like a lot of work

2065
01:19:08,679 --> 01:19:14,199
recently where uh you can prove formally

2066
01:19:12,280 --> 01:19:16,400
verify down to the hardware so like

2067
01:19:14,199 --> 01:19:17,960
through the you formally verify the C

2068
01:19:16,400 --> 01:19:20,239
code and then you formally verify

2069
01:19:17,960 --> 01:19:22,719
through the GCC compiler and then

2070
01:19:20,239 --> 01:19:25,679
through the VAR log down to the hardware

2071
01:19:22,719 --> 01:19:27,400
um and that's like incredibly big system

2072
01:19:25,679 --> 01:19:29,040
but it actually works and I think big

2073
01:19:27,400 --> 01:19:31,159
code bases are are sort of similar in

2074
01:19:29,040 --> 01:19:33,840
that they're like multi-layered system

2075
01:19:31,159 --> 01:19:35,800
and um if you can decompose it and

2076
01:19:33,840 --> 01:19:36,920
formally verify each part then I think

2077
01:19:35,800 --> 01:19:38,560
it should be possible I think the

2078
01:19:36,920 --> 01:19:41,360
specification problem is a real problem

2079
01:19:38,560 --> 01:19:43,440
but how do you handle side effects or

2080
01:19:41,360 --> 01:19:46,280
how do you handle I guess external

2081
01:19:43,440 --> 01:19:48,440
dependencies like calling the stripe API

2082
01:19:46,280 --> 01:19:50,040
maybe stripe would write a spec for

2083
01:19:48,440 --> 01:19:51,760
their you can't do this for everything

2084
01:19:50,040 --> 01:19:54,239
like can you do this for everything you

2085
01:19:51,760 --> 01:19:56,120
use like how do you how do you do it for

2086
01:19:54,239 --> 01:19:57,480
if there's language mod like maybe maybe

2087
01:19:56,120 --> 01:19:59,480
like people use language models as

2088
01:19:57,480 --> 01:20:00,800
Primitives in the programs they write

2089
01:19:59,480 --> 01:20:02,800
and there's like a dependence on it and

2090
01:20:00,800 --> 01:20:04,719
like how how do you now include that I

2091
01:20:02,800 --> 01:20:06,840
think you might be able to prove prove

2092
01:20:04,719 --> 01:20:09,480
that still prove what about language

2093
01:20:06,840 --> 01:20:11,520
models I think it it feels possible that

2094
01:20:09,480 --> 01:20:15,280
you could actually prove that a language

2095
01:20:11,520 --> 01:20:18,120
model is aligned for example or like you

2096
01:20:15,280 --> 01:20:21,560
can prove that it actually gives the the

2097
01:20:18,120 --> 01:20:24,800
right answer um that's the dream yeah

2098
01:20:21,560 --> 01:20:26,480
that is I mean that's if it's possible

2099
01:20:24,800 --> 01:20:28,600
your I Have a Dream speech if it's

2100
01:20:26,480 --> 01:20:31,280
possible that that will certainly help

2101
01:20:28,600 --> 01:20:33,400
with you know uh making sure your code

2102
01:20:31,280 --> 01:20:34,480
doesn't have bugs and making sure AI

2103
01:20:33,400 --> 01:20:37,040
doesn't destroy all of human

2104
01:20:34,480 --> 01:20:40,679
civilization so the the full spectrum of

2105
01:20:37,040 --> 01:20:42,280
AI safety to just bug finding uh so you

2106
01:20:40,679 --> 01:20:44,560
said the models struggle with bug

2107
01:20:42,280 --> 01:20:47,760
finding what's the Hope You Know My Hope

2108
01:20:44,560 --> 01:20:49,480
initially is and and I can let Michael

2109
01:20:47,760 --> 01:20:51,000
Michael chime into to it but was like

2110
01:20:49,480 --> 01:20:53,440
this

2111
01:20:51,000 --> 01:20:55,480
um it should you know first help with

2112
01:20:53,440 --> 01:20:57,440
the stupid bugs like it should very

2113
01:20:55,480 --> 01:20:59,560
quickly catch the stupid bugs like off

2114
01:20:57,440 --> 01:21:01,040
by one erors like sometimes you write

2115
01:20:59,560 --> 01:21:03,360
something in a comment and do the other

2116
01:21:01,040 --> 01:21:05,080
way it's like very common like I do this

2117
01:21:03,360 --> 01:21:06,679
I write like less than in a comment and

2118
01:21:05,080 --> 01:21:08,840
like I maybe write it greater than or

2119
01:21:06,679 --> 01:21:10,880
something like that and the model is

2120
01:21:08,840 --> 01:21:13,679
like yeah it looks sketchy like you sure

2121
01:21:10,880 --> 01:21:16,239
you want to do that uh but eventually it

2122
01:21:13,679 --> 01:21:18,480
should be able to catch 100 bucks too

2123
01:21:16,239 --> 01:21:20,880
yeah and I think that it's also

2124
01:21:18,480 --> 01:21:23,400
important to note that this is having

2125
01:21:20,880 --> 01:21:25,400
good bug finding models feels necessary

2126
01:21:23,400 --> 01:21:27,880
to get to the highest reaches of having

2127
01:21:25,400 --> 01:21:29,639
AI do more and more programming for you

2128
01:21:27,880 --> 01:21:30,880
where you're going to you know if the AI

2129
01:21:29,639 --> 01:21:32,320
is building more and more of the system

2130
01:21:30,880 --> 01:21:35,480
for you you need to not just generate

2131
01:21:32,320 --> 01:21:36,679
but also verify and without that some of

2132
01:21:35,480 --> 01:21:38,400
the problems that we've talked about

2133
01:21:36,679 --> 01:21:42,360
before with programming with these

2134
01:21:38,400 --> 01:21:45,040
models um will just become untenable um

2135
01:21:42,360 --> 01:21:46,800
so it's not just for humans like you

2136
01:21:45,040 --> 01:21:49,120
write a bug I write a bug find the bug

2137
01:21:46,800 --> 01:21:51,840
for me but it's also being able to to

2138
01:21:49,120 --> 01:21:53,239
verify the AI code and check it um is

2139
01:21:51,840 --> 01:21:54,719
really important yeah and then how do

2140
01:21:53,239 --> 01:21:56,360
you actually do this like we have had a

2141
01:21:54,719 --> 01:21:57,760
lot of contentious dinner discussions of

2142
01:21:56,360 --> 01:22:00,880
how do you actually train a bug model

2143
01:21:57,760 --> 01:22:03,080
but one very popular idea is you know

2144
01:22:00,880 --> 01:22:04,840
it's kind of potentially easy to

2145
01:22:03,080 --> 01:22:07,159
introduce a bug than actually finding

2146
01:22:04,840 --> 01:22:10,159
the bug and so you can train a model to

2147
01:22:07,159 --> 01:22:13,400
introduce bugs in existing code um and

2148
01:22:10,159 --> 01:22:16,199
then you can train a reverse bug model

2149
01:22:13,400 --> 01:22:18,159
then that uh can find find bugs using

2150
01:22:16,199 --> 01:22:21,199
this synthetic data so that's like one

2151
01:22:18,159 --> 01:22:24,000
example um but yeah there are lots of

2152
01:22:21,199 --> 01:22:25,320
ideas for how to also um you can also do

2153
01:22:24,000 --> 01:22:27,560
a bunch of work not even at the model

2154
01:22:25,320 --> 01:22:30,159
level of taking the biggest models and

2155
01:22:27,560 --> 01:22:32,320
then maybe giving them access to a lot

2156
01:22:30,159 --> 01:22:33,679
of information that's not just the code

2157
01:22:32,320 --> 01:22:35,000
like it's kind of a hard problem to like

2158
01:22:33,679 --> 01:22:37,120
stare at a file and be like where's the

2159
01:22:35,000 --> 01:22:38,800
bug and you know that's that's hard for

2160
01:22:37,120 --> 01:22:40,560
humans often right and so often you have

2161
01:22:38,800 --> 01:22:41,840
to to run the code and being able to see

2162
01:22:40,560 --> 01:22:43,920
things like traces and step through a

2163
01:22:41,840 --> 01:22:45,239
debugger um there's another whole

2164
01:22:43,920 --> 01:22:46,840
another Direction where it like kind of

2165
01:22:45,239 --> 01:22:47,719
tends toward that and it could also be

2166
01:22:46,840 --> 01:22:48,960
that there are kind of two different

2167
01:22:47,719 --> 01:22:50,600
product form factors here it could be

2168
01:22:48,960 --> 01:22:51,880
that you have a really specialty model

2169
01:22:50,600 --> 01:22:53,520
that's quite fast that's kind of running

2170
01:22:51,880 --> 01:22:55,760
in the background and trying to spot

2171
01:22:53,520 --> 01:22:57,520
bugs and it might be that sometimes sort

2172
01:22:55,760 --> 01:22:59,800
of to arvid's earlier example about you

2173
01:22:57,520 --> 01:23:01,000
know some nefarious input box bug might

2174
01:22:59,800 --> 01:23:02,280
be that sometimes you want to like

2175
01:23:01,000 --> 01:23:04,040
there's you know there's a bug you're

2176
01:23:02,280 --> 01:23:05,719
not just like checking hypothesis free

2177
01:23:04,040 --> 01:23:07,600
you're like this is a problem I really

2178
01:23:05,719 --> 01:23:08,880
want to solve it and you zap that with

2179
01:23:07,600 --> 01:23:10,280
tons and tons and tons of compute and

2180
01:23:08,880 --> 01:23:12,880
you're willing to put in like $50 to

2181
01:23:10,280 --> 01:23:14,679
solve that bug or something even more

2182
01:23:12,880 --> 01:23:16,040
have you thought about integrating money

2183
01:23:14,679 --> 01:23:17,840
into this whole thing like I would pay

2184
01:23:16,040 --> 01:23:20,239
probably a large amount of money for if

2185
01:23:17,840 --> 01:23:21,920
you found a bug or even generated a code

2186
01:23:20,239 --> 01:23:24,000
that I really appreciated like I had a

2187
01:23:21,920 --> 01:23:26,679
moment a few days ago when I started

2188
01:23:24,000 --> 01:23:29,920
using C were

2189
01:23:26,679 --> 01:23:33,040
generated uh

2190
01:23:29,920 --> 01:23:36,840
perfect uh like perfect three functions

2191
01:23:33,040 --> 01:23:40,480
for interacting with the YouTube API to

2192
01:23:36,840 --> 01:23:42,360
update captions and uh for localization

2193
01:23:40,480 --> 01:23:45,159
like different in different languages

2194
01:23:42,360 --> 01:23:47,679
the API documentation is not very good

2195
01:23:45,159 --> 01:23:49,480
and the code across like if I I Googled

2196
01:23:47,679 --> 01:23:51,239
it for a while I couldn't find exactly

2197
01:23:49,480 --> 01:23:53,600
there's a lot of confusing information

2198
01:23:51,239 --> 01:23:55,560
and cursor generated perfectly and I was

2199
01:23:53,600 --> 01:23:57,080
like I just said back I read the code I

2200
01:23:55,560 --> 01:24:00,239
was like this is correct I tested it

2201
01:23:57,080 --> 01:24:03,880
it's correct I was like I want a tip on

2202
01:24:00,239 --> 01:24:05,400
a on a button that goes yeah here's $5

2203
01:24:03,880 --> 01:24:07,040
one that's really good just to support

2204
01:24:05,400 --> 01:24:08,920
the company and support what the the

2205
01:24:07,040 --> 01:24:12,840
interface is and the other is that

2206
01:24:08,920 --> 01:24:15,520
probably sends a strong signal like good

2207
01:24:12,840 --> 01:24:17,120
job right so there much stronger signal

2208
01:24:15,520 --> 01:24:19,320
than just accepting the code right you

2209
01:24:17,120 --> 01:24:22,600
just actually send like a strong good

2210
01:24:19,320 --> 01:24:25,520
job that and for bug finding obviously

2211
01:24:22,600 --> 01:24:27,800
like there's a lot of people

2212
01:24:25,520 --> 01:24:30,480
you know that would pay a huge amount of

2213
01:24:27,800 --> 01:24:33,400
money for a bug like a bug bug Bounty

2214
01:24:30,480 --> 01:24:35,440
thing right is that you guys think about

2215
01:24:33,400 --> 01:24:37,679
that yeah it's a controversial idea

2216
01:24:35,440 --> 01:24:40,760
inside the the company I think it sort

2217
01:24:37,679 --> 01:24:44,600
of depends on how much uh you believe in

2218
01:24:40,760 --> 01:24:47,199
humanity almost you know like uh I think

2219
01:24:44,600 --> 01:24:49,199
it would be really cool if like uh you

2220
01:24:47,199 --> 01:24:51,600
spend nothing to try to find a bug and

2221
01:24:49,199 --> 01:24:53,719
if it doesn't find a bug you you spend Z

2222
01:24:51,600 --> 01:24:55,760
and then if it does find a bug uh and

2223
01:24:53,719 --> 01:24:58,560
you click accept then it also shows like

2224
01:24:55,760 --> 01:25:01,159
in parenthesis like $1 and so you spend

2225
01:24:58,560 --> 01:25:02,920
$1 to accept a bug uh and then of course

2226
01:25:01,159 --> 01:25:04,440
there's worry like okay we spent a lot

2227
01:25:02,920 --> 01:25:07,119
of computation like maybe people will

2228
01:25:04,440 --> 01:25:09,440
just copy paste um I think that's a

2229
01:25:07,119 --> 01:25:11,719
worry um and then there is also the

2230
01:25:09,440 --> 01:25:14,440
worry that like introducing money into

2231
01:25:11,719 --> 01:25:16,239
the product makes it like kind of you

2232
01:25:14,440 --> 01:25:18,159
know like it doesn't feel as fun anymore

2233
01:25:16,239 --> 01:25:19,760
like you have to like think about money

2234
01:25:18,159 --> 01:25:21,840
and and you all you want to think about

2235
01:25:19,760 --> 01:25:23,320
is like the code and so maybe it

2236
01:25:21,840 --> 01:25:26,480
actually makes more sense to separate it

2237
01:25:23,320 --> 01:25:28,440
out and like you pay some fee like every

2238
01:25:26,480 --> 01:25:29,880
month and then you get all of these

2239
01:25:28,440 --> 01:25:32,280
things for free but there could be a

2240
01:25:29,880 --> 01:25:34,679
tipping component which is not like it

2241
01:25:32,280 --> 01:25:36,480
it it still has that like dollar symbol

2242
01:25:34,679 --> 01:25:39,360
I think it's fine but I I also see the

2243
01:25:36,480 --> 01:25:40,719
point where like maybe you don't want to

2244
01:25:39,360 --> 01:25:42,400
introduce it yeah I was going to say the

2245
01:25:40,719 --> 01:25:43,880
moment that feels like people do this is

2246
01:25:42,400 --> 01:25:45,600
when they share it when they have this

2247
01:25:43,880 --> 01:25:47,159
fantastic example they just kind of

2248
01:25:45,600 --> 01:25:48,520
share it with their friends there is

2249
01:25:47,159 --> 01:25:50,400
also a potential world where there's a

2250
01:25:48,520 --> 01:25:52,320
technical solution to this like honor

2251
01:25:50,400 --> 01:25:54,280
System problem too where if we can get

2252
01:25:52,320 --> 01:25:56,440
to a place where we understand the

2253
01:25:54,280 --> 01:25:57,800
output of the system more I mean to the

2254
01:25:56,440 --> 01:25:59,480
stuff we were talking about with like

2255
01:25:57,800 --> 01:26:00,960
you know error checking with the LSP and

2256
01:25:59,480 --> 01:26:01,960
then also running the code but if you

2257
01:26:00,960 --> 01:26:04,199
could get to a place where you could

2258
01:26:01,960 --> 01:26:07,159
actually somehow verify oh I have fixed

2259
01:26:04,199 --> 01:26:08,440
the bug maybe then the the bounty system

2260
01:26:07,159 --> 01:26:10,440
doesn't need to rely on the honor System

2261
01:26:08,440 --> 01:26:12,480
Too how much interaction is there

2262
01:26:10,440 --> 01:26:14,440
between the terminal and the code like

2263
01:26:12,480 --> 01:26:17,119
how much information is gained from if

2264
01:26:14,440 --> 01:26:20,719
you if you run the code in the terminal

2265
01:26:17,119 --> 01:26:23,520
like can you use can you do like a a

2266
01:26:20,719 --> 01:26:25,239
loop where it runs runs the code and

2267
01:26:23,520 --> 01:26:28,000
suggests how to change the code if if

2268
01:26:25,239 --> 01:26:29,760
the code and runtime gives an error is

2269
01:26:28,000 --> 01:26:32,280
right now there're separate worlds

2270
01:26:29,760 --> 01:26:34,360
completely like I know you can like do

2271
01:26:32,280 --> 01:26:35,800
control K inside the terminal to help

2272
01:26:34,360 --> 01:26:39,119
you write the code you you can use

2273
01:26:35,800 --> 01:26:42,159
terminal contacts as well uh inside of

2274
01:26:39,119 --> 01:26:45,239
Jack man kind of everything um we don't

2275
01:26:42,159 --> 01:26:46,520
have the looping part yet though we

2276
01:26:45,239 --> 01:26:48,000
suspect something like this could make a

2277
01:26:46,520 --> 01:26:49,639
lot of sense there's a question of

2278
01:26:48,000 --> 01:26:51,639
whether it happens in the foreground too

2279
01:26:49,639 --> 01:26:53,280
or if it happens in the background like

2280
01:26:51,639 --> 01:26:54,760
what we've been discussing sure the

2281
01:26:53,280 --> 01:26:56,800
background is pretty cool like we do

2282
01:26:54,760 --> 01:26:59,159
running the code in different ways plus

2283
01:26:56,800 --> 01:27:00,560
there's a database side to this which

2284
01:26:59,159 --> 01:27:02,239
how do you protect it from not modifying

2285
01:27:00,560 --> 01:27:04,480
the database but

2286
01:27:02,239 --> 01:27:07,239
okay I mean there's there's certainly

2287
01:27:04,480 --> 01:27:10,600
cool Solutions there uh there's this new

2288
01:27:07,239 --> 01:27:14,600
API that is being developed for it's

2289
01:27:10,600 --> 01:27:16,119
it's not in AWS uh but you know it's it

2290
01:27:14,600 --> 01:27:17,480
certainly it's I think it's in Planet

2291
01:27:16,119 --> 01:27:19,760
scale I don't know if Planet scale was

2292
01:27:17,480 --> 01:27:22,760
the first one you added it's the ability

2293
01:27:19,760 --> 01:27:25,080
sort of add branches to a database uh

2294
01:27:22,760 --> 01:27:26,960
which is uh like if you're working on a

2295
01:27:25,080 --> 01:27:28,360
feature and you want to test against the

2296
01:27:26,960 --> 01:27:30,040
prod database but you don't actually

2297
01:27:28,360 --> 01:27:31,520
want to test against the pr database you

2298
01:27:30,040 --> 01:27:33,000
could sort of add a branch to the

2299
01:27:31,520 --> 01:27:35,440
database in the way to do that is to add

2300
01:27:33,000 --> 01:27:36,880
a branch to the WR ahead log uh and

2301
01:27:35,440 --> 01:27:38,760
there's obviously a lot of technical

2302
01:27:36,880 --> 01:27:40,600
complexity in doing it correctly I I

2303
01:27:38,760 --> 01:27:44,960
guess database companies need need need

2304
01:27:40,600 --> 01:27:47,119
new things to do uh because they have

2305
01:27:44,960 --> 01:27:49,400
they have they have good databases now

2306
01:27:47,119 --> 01:27:50,719
uh and and I I think like you know turbo

2307
01:27:49,400 --> 01:27:53,119
buffer which is which is one of the

2308
01:27:50,719 --> 01:27:58,159
databases we use as is is going to add

2309
01:27:53,119 --> 01:28:00,840
hope maybe braning to the to the rad log

2310
01:27:58,159 --> 01:28:03,440
and and so so maybe maybe the the AI

2311
01:28:00,840 --> 01:28:05,520
agents will use we'll use branching

2312
01:28:03,440 --> 01:28:06,880
they'll like test against some branch

2313
01:28:05,520 --> 01:28:09,320
and it's sort of going to be a

2314
01:28:06,880 --> 01:28:10,719
requirement for the database to like

2315
01:28:09,320 --> 01:28:11,639
support branching or something it would

2316
01:28:10,719 --> 01:28:14,320
be really interesting if you could

2317
01:28:11,639 --> 01:28:15,880
Branch a file system right yeah I feel

2318
01:28:14,320 --> 01:28:18,280
like everything needs branching it's

2319
01:28:15,880 --> 01:28:19,590
like that yeah yeah like that's the

2320
01:28:18,280 --> 01:28:21,119
problem with the Multiverse

2321
01:28:19,590 --> 01:28:23,280
[Music]

2322
01:28:21,119 --> 01:28:25,040
right like if you branch on everything

2323
01:28:23,280 --> 01:28:26,320
that's like a lot I mean there's there's

2324
01:28:25,040 --> 01:28:27,639
obviously these like super clever

2325
01:28:26,320 --> 01:28:30,719
algorithms to make sure that you don't

2326
01:28:27,639 --> 01:28:33,119
actually sort of use a lot of space or

2327
01:28:30,719 --> 01:28:35,119
CPU or whatever okay this is a good

2328
01:28:33,119 --> 01:28:37,480
place to ask about infrastructure so you

2329
01:28:35,119 --> 01:28:38,560
guys mostly use AWS what what are some

2330
01:28:37,480 --> 01:28:40,520
interesting details what are some

2331
01:28:38,560 --> 01:28:44,119
interesting challenges why' you choose

2332
01:28:40,520 --> 01:28:48,239
AWS why is why is AWS still winning

2333
01:28:44,119 --> 01:28:53,239
hashtag AWS is just really really good

2334
01:28:48,239 --> 01:28:55,760
it's really good like um whenever you

2335
01:28:53,239 --> 01:28:58,480
use an AWS product you just know that

2336
01:28:55,760 --> 01:29:00,639
it's going to work like it might be

2337
01:28:58,480 --> 01:29:03,280
absolute hell to go through the steps to

2338
01:29:00,639 --> 01:29:06,280
set it up um why is the interface so

2339
01:29:03,280 --> 01:29:08,000
horrible because it's just so good it

2340
01:29:06,280 --> 01:29:10,199
doesn't need to the nature of

2341
01:29:08,000 --> 01:29:13,119
winning I think it's exactly it's just

2342
01:29:10,199 --> 01:29:14,520
nature they winning yeah yeah but AWS

2343
01:29:13,119 --> 01:29:17,400
you can always trust like it will always

2344
01:29:14,520 --> 01:29:19,080
work and if there is a problem it's

2345
01:29:17,400 --> 01:29:21,760
probably your

2346
01:29:19,080 --> 01:29:23,840
problem yeah okay is there some

2347
01:29:21,760 --> 01:29:26,800
interesting like challenges to you guys

2348
01:29:23,840 --> 01:29:29,560
have pretty new startup to get scaling

2349
01:29:26,800 --> 01:29:33,199
to like to so many people and yeah I

2350
01:29:29,560 --> 01:29:35,639
think that they're uh it has been an

2351
01:29:33,199 --> 01:29:38,080
interesting Journey adding you know each

2352
01:29:35,639 --> 01:29:39,480
extra zero to the request per second you

2353
01:29:38,080 --> 01:29:40,920
run into all of these with like you know

2354
01:29:39,480 --> 01:29:42,520
the general components you're using for

2355
01:29:40,920 --> 01:29:43,960
for caching and databases run into

2356
01:29:42,520 --> 01:29:45,119
issues as you make things bigger and

2357
01:29:43,960 --> 01:29:46,480
bigger and now we're at the scale where

2358
01:29:45,119 --> 01:29:48,840
we get like you know int overflows on

2359
01:29:46,480 --> 01:29:51,320
our tables and things like that um and

2360
01:29:48,840 --> 01:29:52,880
then also there have been some custom

2361
01:29:51,320 --> 01:29:56,159
systems that we've built like for

2362
01:29:52,880 --> 01:29:58,040
instance our Ral system for um Computing

2363
01:29:56,159 --> 01:30:00,360
a semantic index of your codebase and

2364
01:29:58,040 --> 01:30:02,520
answering questions about a codebase

2365
01:30:00,360 --> 01:30:04,440
that have continually I feel like been

2366
01:30:02,520 --> 01:30:05,920
one of the the trickier things to scale

2367
01:30:04,440 --> 01:30:07,960
I I have a few friends who are who are

2368
01:30:05,920 --> 01:30:09,520
super super senior engineers and one of

2369
01:30:07,960 --> 01:30:11,199
their sort of lines is like it's it's

2370
01:30:09,520 --> 01:30:13,880
very hard to predict where systems will

2371
01:30:11,199 --> 01:30:16,520
break when when you scale them you you

2372
01:30:13,880 --> 01:30:18,040
you can sort of try to predict in

2373
01:30:16,520 --> 01:30:19,239
advance but like there's there's always

2374
01:30:18,040 --> 01:30:21,280
something something weird that's going

2375
01:30:19,239 --> 01:30:23,400
to happen when when you add this extra Z

2376
01:30:21,280 --> 01:30:24,960
and you you thought you thought through

2377
01:30:23,400 --> 01:30:27,199
everything but you didn't actually think

2378
01:30:24,960 --> 01:30:31,199
through everything uh but I think for

2379
01:30:27,199 --> 01:30:34,199
that particular system

2380
01:30:31,199 --> 01:30:36,520
we've so what the the for concrete

2381
01:30:34,199 --> 01:30:40,040
details the thing we do is obviously we

2382
01:30:36,520 --> 01:30:43,159
upload um when like we chunk up all of

2383
01:30:40,040 --> 01:30:45,400
your code and then we send up sort of

2384
01:30:43,159 --> 01:30:47,239
the code for for embedding and we embed

2385
01:30:45,400 --> 01:30:49,520
the code and then we store the

2386
01:30:47,239 --> 01:30:51,920
embeddings uh in a in a database but we

2387
01:30:49,520 --> 01:30:53,679
don't actually store any of the code and

2388
01:30:51,920 --> 01:30:54,600
then there's reasons around making sure

2389
01:30:53,679 --> 01:30:56,600
that

2390
01:30:54,600 --> 01:30:58,360
we don't introduce client bugs because

2391
01:30:56,600 --> 01:31:02,560
we're very very paranoid about client

2392
01:30:58,360 --> 01:31:05,840
bugs we store uh uh much of the details

2393
01:31:02,560 --> 01:31:07,080
on the server uh like everything is sort

2394
01:31:05,840 --> 01:31:09,360
of

2395
01:31:07,080 --> 01:31:11,239
encrypted so one one of the technical

2396
01:31:09,360 --> 01:31:14,840
challenges is is always making sure that

2397
01:31:11,239 --> 01:31:17,080
the local index the local codebase state

2398
01:31:14,840 --> 01:31:19,600
is the same as the state that is on the

2399
01:31:17,080 --> 01:31:22,199
server and and the way sort of

2400
01:31:19,600 --> 01:31:24,119
technically we ended up doing that is so

2401
01:31:22,199 --> 01:31:26,560
for every single file you can you can

2402
01:31:24,119 --> 01:31:28,679
sort of keep this hash and then for

2403
01:31:26,560 --> 01:31:31,159
every folder you can sort of keep a hash

2404
01:31:28,679 --> 01:31:32,639
which is the hash of all of its children

2405
01:31:31,159 --> 01:31:35,639
and you can sort of recursively do that

2406
01:31:32,639 --> 01:31:38,199
until the top and why why do something

2407
01:31:35,639 --> 01:31:39,880
something complicated uh one thing you

2408
01:31:38,199 --> 01:31:41,960
could do is you could keep a hash for

2409
01:31:39,880 --> 01:31:44,239
every file then every minute you could

2410
01:31:41,960 --> 01:31:46,199
try to download the hashes that are on

2411
01:31:44,239 --> 01:31:47,639
the server figure out what are the files

2412
01:31:46,199 --> 01:31:49,360
that don't exist on the server maybe

2413
01:31:47,639 --> 01:31:51,199
just created a new file maybe you just

2414
01:31:49,360 --> 01:31:54,199
deleted a file maybe you checked out a

2415
01:31:51,199 --> 01:31:56,159
new branch and try to reconcile the

2416
01:31:54,199 --> 01:31:58,440
state between the client and the

2417
01:31:56,159 --> 01:32:01,280
server but that introduces like

2418
01:31:58,440 --> 01:32:04,080
absolutely ginormous Network overhead

2419
01:32:01,280 --> 01:32:06,520
both uh both on the client side I mean

2420
01:32:04,080 --> 01:32:08,159
nobody really wants us to hammer their

2421
01:32:06,520 --> 01:32:10,560
Wi-Fi all the time if you're using

2422
01:32:08,159 --> 01:32:12,880
cursor uh but also like I mean it would

2423
01:32:10,560 --> 01:32:15,280
introduce like ginormous overhead in the

2424
01:32:12,880 --> 01:32:20,679
database it would sort of be reading

2425
01:32:15,280 --> 01:32:23,239
this uh tens of terabyte database sort

2426
01:32:20,679 --> 01:32:25,679
of approaching like 20 terabyt or

2427
01:32:23,239 --> 01:32:28,280
something database like every second

2428
01:32:25,679 --> 01:32:30,760
that's just just kind of crazy you

2429
01:32:28,280 --> 01:32:32,880
definitely don't want to do that so what

2430
01:32:30,760 --> 01:32:34,679
you do you sort of you just try to

2431
01:32:32,880 --> 01:32:36,360
reconcile the single hash which is at

2432
01:32:34,679 --> 01:32:37,960
the root of the project and then if if

2433
01:32:36,360 --> 01:32:39,800
something mismatches then you go you

2434
01:32:37,960 --> 01:32:41,360
find where all the things disagree maybe

2435
01:32:39,800 --> 01:32:42,760
you look at the children and see if the

2436
01:32:41,360 --> 01:32:44,239
hashes match and if the hashes don't

2437
01:32:42,760 --> 01:32:46,320
match go look at their children and so

2438
01:32:44,239 --> 01:32:47,880
on but you only do that in the scenario

2439
01:32:46,320 --> 01:32:50,000
where things don't match and for most

2440
01:32:47,880 --> 01:32:52,400
people most of the time the hashes match

2441
01:32:50,000 --> 01:32:55,000
so it's a kind of like hierarchical

2442
01:32:52,400 --> 01:32:56,880
reconciliation yeah something like that

2443
01:32:55,000 --> 01:32:59,760
yeah it's called the Merkel tree yeah

2444
01:32:56,880 --> 01:33:00,800
Merkel yeah I mean so yeah it's cool to

2445
01:32:59,760 --> 01:33:02,480
see that you kind of have to think

2446
01:33:00,800 --> 01:33:04,040
through all these problems and I mean

2447
01:33:02,480 --> 01:33:06,000
the the point of like the reason it's

2448
01:33:04,040 --> 01:33:07,920
gotten hard is just because like the

2449
01:33:06,000 --> 01:33:10,679
number of people using it and you know

2450
01:33:07,920 --> 01:33:14,480
if some of your customers have really

2451
01:33:10,679 --> 01:33:16,520
really large code bases uh to the point

2452
01:33:14,480 --> 01:33:17,960
where we you know we we originally

2453
01:33:16,520 --> 01:33:19,920
reordered our code base which is which

2454
01:33:17,960 --> 01:33:22,239
is big but I mean just just not the size

2455
01:33:19,920 --> 01:33:24,119
of some company that's been there for 20

2456
01:33:22,239 --> 01:33:26,199
years and sort of has to train enormous

2457
01:33:24,119 --> 01:33:28,119
number of files and you sort of want to

2458
01:33:26,199 --> 01:33:29,880
scale that across programmers there's

2459
01:33:28,119 --> 01:33:32,000
there's all these details where like

2460
01:33:29,880 --> 01:33:33,760
building the simple thing is easy but

2461
01:33:32,000 --> 01:33:35,800
scaling it to a lot of people like a lot

2462
01:33:33,760 --> 01:33:37,320
of companies is is obviously a difficult

2463
01:33:35,800 --> 01:33:38,639
problem which is sort of you know

2464
01:33:37,320 --> 01:33:40,040
independent of actually so that's

2465
01:33:38,639 --> 01:33:42,280
there's part of this scaling our current

2466
01:33:40,040 --> 01:33:44,320
solution is also you know coming up with

2467
01:33:42,280 --> 01:33:46,600
new ideas that obviously we're working

2468
01:33:44,320 --> 01:33:48,960
on uh but then but then scaling all of

2469
01:33:46,600 --> 01:33:50,800
that in the last few weeks once yeah and

2470
01:33:48,960 --> 01:33:52,360
there are a lot of clever things like

2471
01:33:50,800 --> 01:33:54,280
additional things that that go into this

2472
01:33:52,360 --> 01:33:56,360
indexing system

2473
01:33:54,280 --> 01:33:58,239
um for example the bottleneck in terms

2474
01:33:56,360 --> 01:33:59,639
of costs is not storing things in the

2475
01:33:58,239 --> 01:34:01,199
vector database or the database it's

2476
01:33:59,639 --> 01:34:03,119
actually embedding the code and you

2477
01:34:01,199 --> 01:34:05,360
don't want to Reed the code base for

2478
01:34:03,119 --> 01:34:07,880
every single person in a company that is

2479
01:34:05,360 --> 01:34:09,040
using the same exact code except for

2480
01:34:07,880 --> 01:34:10,719
maybe they're in a different branch with

2481
01:34:09,040 --> 01:34:13,639
a few different files or they've made a

2482
01:34:10,719 --> 01:34:15,000
few local changes and so because again

2483
01:34:13,639 --> 01:34:16,800
embeddings are the bottleneck you can do

2484
01:34:15,000 --> 01:34:18,520
this one clever trick and not have to

2485
01:34:16,800 --> 01:34:20,000
worry about like the complexity of like

2486
01:34:18,520 --> 01:34:23,440
dealing with branches and and the other

2487
01:34:20,000 --> 01:34:24,560
databases where you just have some cash

2488
01:34:23,440 --> 01:34:28,360
on

2489
01:34:24,560 --> 01:34:31,440
the actual vectors uh computed from the

2490
01:34:28,360 --> 01:34:33,400
hash of a given chunk MH and so this

2491
01:34:31,440 --> 01:34:35,119
means that when the nth person at a

2492
01:34:33,400 --> 01:34:37,199
company goes into their code base it's

2493
01:34:35,119 --> 01:34:39,159
it's really really fast and you do all

2494
01:34:37,199 --> 01:34:40,800
this without actually storing any code

2495
01:34:39,159 --> 01:34:42,600
on our servers at all no code data

2496
01:34:40,800 --> 01:34:45,520
stored we just store the vectors in the

2497
01:34:42,600 --> 01:34:49,360
vector database and the vector cache

2498
01:34:45,520 --> 01:34:51,760
what's the biggest gains at this time

2499
01:34:49,360 --> 01:34:54,600
you get from indexing the code base like

2500
01:34:51,760 --> 01:34:56,520
just out of curiosity like what

2501
01:34:54,600 --> 01:34:58,199
what benefit users have it seems like

2502
01:34:56,520 --> 01:34:59,840
longer term there'll be more and more

2503
01:34:58,199 --> 01:35:01,719
benefit but in the short term just

2504
01:34:59,840 --> 01:35:04,760
asking questions of the code

2505
01:35:01,719 --> 01:35:06,679
base uh what what's the use what's the

2506
01:35:04,760 --> 01:35:11,400
usefulness of that I think the most

2507
01:35:06,679 --> 01:35:13,360
obvious one is um just you want to find

2508
01:35:11,400 --> 01:35:15,760
out where something is happening in your

2509
01:35:13,360 --> 01:35:17,920
large code base and you sort of have a

2510
01:35:15,760 --> 01:35:20,880
fuzzy memory of okay I want to find the

2511
01:35:17,920 --> 01:35:22,440
place where we do X um but you don't

2512
01:35:20,880 --> 01:35:25,239
exactly know what to search for in a

2513
01:35:22,440 --> 01:35:27,239
normal text search and to ask a chat uh

2514
01:35:25,239 --> 01:35:29,360
you hit command enter to ask with with

2515
01:35:27,239 --> 01:35:31,280
the codebase chat and then uh very often

2516
01:35:29,360 --> 01:35:33,920
it finds the the right place that you

2517
01:35:31,280 --> 01:35:35,760
were thinking of I think like you like

2518
01:35:33,920 --> 01:35:38,320
you mentioned in the future I think this

2519
01:35:35,760 --> 01:35:40,360
only going to get more and more powerful

2520
01:35:38,320 --> 01:35:42,560
where we're working a lot on improving

2521
01:35:40,360 --> 01:35:43,719
the quality of our retrieval um and I

2522
01:35:42,560 --> 01:35:44,880
think the cealing for that is really

2523
01:35:43,719 --> 01:35:47,239
really much higher than people give a

2524
01:35:44,880 --> 01:35:49,239
credit for one question that's good to

2525
01:35:47,239 --> 01:35:51,560
ask here have you considered and why

2526
01:35:49,239 --> 01:35:54,320
haven't you much done sort of local

2527
01:35:51,560 --> 01:35:55,880
stuff to where you can do the it seems

2528
01:35:54,320 --> 01:35:57,880
like everything we just discussed is

2529
01:35:55,880 --> 01:35:59,199
exceptionally difficult to do to go to

2530
01:35:57,880 --> 01:36:01,280
go to the cloud you have to think about

2531
01:35:59,199 --> 01:36:02,840
all these things with the caching and

2532
01:36:01,280 --> 01:36:05,760
the

2533
01:36:02,840 --> 01:36:07,119
uh you know large code Bas with a large

2534
01:36:05,760 --> 01:36:08,280
number of programmers are using the same

2535
01:36:07,119 --> 01:36:10,840
code base you have to figure out the

2536
01:36:08,280 --> 01:36:14,440
puzzle of that a lot of it you know

2537
01:36:10,840 --> 01:36:16,800
most software just does stuff this heavy

2538
01:36:14,440 --> 01:36:18,080
computational stuff locally so if you

2539
01:36:16,800 --> 01:36:20,520
consider doing sort of embeddings

2540
01:36:18,080 --> 01:36:22,719
locally yeah we thought about it and I

2541
01:36:20,520 --> 01:36:25,040
think it would be cool to do it locally

2542
01:36:22,719 --> 01:36:27,040
I think it's just really hard and and

2543
01:36:25,040 --> 01:36:30,000
one thing to keep in mind is that you

2544
01:36:27,040 --> 01:36:33,199
know uh some of our users use the latest

2545
01:36:30,000 --> 01:36:35,000
MacBook Pro uh and but most of our users

2546
01:36:33,199 --> 01:36:38,000
like more than 80% of our users are in

2547
01:36:35,000 --> 01:36:40,159
Windows machines which uh and and many

2548
01:36:38,000 --> 01:36:42,719
of them are are not very powerful and

2549
01:36:40,159 --> 01:36:44,920
and so local models really only works on

2550
01:36:42,719 --> 01:36:48,239
the on the latest computers and it's

2551
01:36:44,920 --> 01:36:50,080
also a big overhead to to to build that

2552
01:36:48,239 --> 01:36:52,920
in and so even if we would like to do

2553
01:36:50,080 --> 01:36:54,840
that um it's currently not something

2554
01:36:52,920 --> 01:36:57,080
that we are able to focus on and I think

2555
01:36:54,840 --> 01:37:00,040
there there are some uh people that that

2556
01:36:57,080 --> 01:37:02,280
that do that and I think that's great um

2557
01:37:00,040 --> 01:37:04,760
but especially as models get bigger and

2558
01:37:02,280 --> 01:37:06,440
bigger and you want to do fancier things

2559
01:37:04,760 --> 01:37:09,000
with like bigger models it becomes even

2560
01:37:06,440 --> 01:37:11,560
harder to do it locally yeah and it's

2561
01:37:09,000 --> 01:37:13,719
not a problem of like weaker computers

2562
01:37:11,560 --> 01:37:16,800
it's just that for example if you're

2563
01:37:13,719 --> 01:37:18,840
some big company you have big company

2564
01:37:16,800 --> 01:37:20,480
code base it's just really hard to

2565
01:37:18,840 --> 01:37:22,800
process big company code based even on

2566
01:37:20,480 --> 01:37:24,639
the beefiest MacBook Pros so even if

2567
01:37:22,800 --> 01:37:27,199
it's not even a matter matter of like if

2568
01:37:24,639 --> 01:37:29,840
you're if you're just like uh a student

2569
01:37:27,199 --> 01:37:31,679
or something I think if you're like the

2570
01:37:29,840 --> 01:37:33,360
best programmer at at a big company

2571
01:37:31,679 --> 01:37:35,679
you're still going to have a horrible

2572
01:37:33,360 --> 01:37:37,840
experience if you do everything locally

2573
01:37:35,679 --> 01:37:39,960
when you could you could do it and sort

2574
01:37:37,840 --> 01:37:41,719
of scrape by but like again it wouldn't

2575
01:37:39,960 --> 01:37:43,159
be fun anymore yeah like at approximate

2576
01:37:41,719 --> 01:37:44,880
nearest neighbors and this massive code

2577
01:37:43,159 --> 01:37:49,159
base is going to just eat up your memory

2578
01:37:44,880 --> 01:37:51,239
and your CPU and and and that's and

2579
01:37:49,159 --> 01:37:53,840
that's just that like let's talk about

2580
01:37:51,239 --> 01:37:55,840
like also the modeling side where said

2581
01:37:53,840 --> 01:37:59,520
there are these massive headwinds

2582
01:37:55,840 --> 01:38:02,199
against uh local models where one uh

2583
01:37:59,520 --> 01:38:04,280
things seem to move towards Moes which

2584
01:38:02,199 --> 01:38:06,040
like one benefit is maybe they're more

2585
01:38:04,280 --> 01:38:10,199
memory bandwidth bound which plays in

2586
01:38:06,040 --> 01:38:13,960
favor of local uh versus uh using gpus

2587
01:38:10,199 --> 01:38:16,639
um or using Nvidia gpus but the downside

2588
01:38:13,960 --> 01:38:18,239
is these models are just bigger in total

2589
01:38:16,639 --> 01:38:20,159
and you know they're going to need to

2590
01:38:18,239 --> 01:38:22,679
fit often not even on a single node but

2591
01:38:20,159 --> 01:38:25,560
multiple nodes um there's no way that's

2592
01:38:22,679 --> 01:38:27,880
going to fit inside of even really good

2593
01:38:25,560 --> 01:38:31,199
MacBooks um and I think especially for

2594
01:38:27,880 --> 01:38:33,360
coding it's not a question as much of

2595
01:38:31,199 --> 01:38:35,920
like does it clear some bar of like the

2596
01:38:33,360 --> 01:38:37,920
model's good enough to do these things

2597
01:38:35,920 --> 01:38:39,639
and then like we're satisfied which may

2598
01:38:37,920 --> 01:38:41,760
may be the case for other other problems

2599
01:38:39,639 --> 01:38:43,480
and maybe where local models shine but

2600
01:38:41,760 --> 01:38:45,400
people are always going to want the best

2601
01:38:43,480 --> 01:38:47,560
the most intelligent the most capable

2602
01:38:45,400 --> 01:38:50,360
things and that's going to be really

2603
01:38:47,560 --> 01:38:52,840
really hard to run for almost all people

2604
01:38:50,360 --> 01:38:55,040
locally don't you want the the most

2605
01:38:52,840 --> 01:38:58,440
capable model like you want you want

2606
01:38:55,040 --> 01:38:59,639
Sonet you and also with o I like how

2607
01:38:58,440 --> 01:39:02,080
you're pitching

2608
01:38:59,639 --> 01:39:04,960
me1 would you be satisfied with an

2609
01:39:02,080 --> 01:39:06,239
inferior model listen I yeah I'm yes I'm

2610
01:39:04,960 --> 01:39:08,440
one of those but there's some people

2611
01:39:06,239 --> 01:39:11,119
that like to do stuff locally especially

2612
01:39:08,440 --> 01:39:12,639
like yeah really there's a whole

2613
01:39:11,119 --> 01:39:15,199
obviously open source movement that kind

2614
01:39:12,639 --> 01:39:17,960
of resists and it's good that they exist

2615
01:39:15,199 --> 01:39:20,080
actually because you want to resist the

2616
01:39:17,960 --> 01:39:21,920
power centers that are growing are

2617
01:39:20,080 --> 01:39:25,400
there's actually an alternative to local

2618
01:39:21,920 --> 01:39:27,560
models uh that I particularly fond of uh

2619
01:39:25,400 --> 01:39:30,480
I think it's still very much in the

2620
01:39:27,560 --> 01:39:33,040
research stage but you could imagine um

2621
01:39:30,480 --> 01:39:35,440
to do homomorphic encryption for

2622
01:39:33,040 --> 01:39:36,960
language model inference so you encrypt

2623
01:39:35,440 --> 01:39:40,639
your input on your local machine then

2624
01:39:36,960 --> 01:39:43,159
you send that up and then um the server

2625
01:39:40,639 --> 01:39:44,960
uh can use lots of computation they can

2626
01:39:43,159 --> 01:39:47,080
run models that you cannot run locally

2627
01:39:44,960 --> 01:39:48,679
on this encrypted data um but they

2628
01:39:47,080 --> 01:39:49,920
cannot see what the data is and then

2629
01:39:48,679 --> 01:39:51,360
they send back the answer and you

2630
01:39:49,920 --> 01:39:54,199
decrypt the answer and only you can see

2631
01:39:51,360 --> 01:39:57,560
the answer uh so I think uh that's still

2632
01:39:54,199 --> 01:40:00,679
very much research and all of it is

2633
01:39:57,560 --> 01:40:02,000
about trying to make the overhead lower

2634
01:40:00,679 --> 01:40:04,520
because right now the overhead is really

2635
01:40:02,000 --> 01:40:07,159
big uh but if you can make that happen I

2636
01:40:04,520 --> 01:40:08,639
think that would be really really cool

2637
01:40:07,159 --> 01:40:10,920
and I think it would be really really

2638
01:40:08,639 --> 01:40:12,320
impactful um because I think one thing

2639
01:40:10,920 --> 01:40:13,880
that's actually kind of worrisome is

2640
01:40:12,320 --> 01:40:15,920
that as these models get better and

2641
01:40:13,880 --> 01:40:18,320
better uh they're going to become more

2642
01:40:15,920 --> 01:40:20,119
and more economically useful and so more

2643
01:40:18,320 --> 01:40:23,679
and more of the world's information and

2644
01:40:20,119 --> 01:40:26,840
data uh will th flow through you know

2645
01:40:23,679 --> 01:40:29,480
one or two centralized actors um and

2646
01:40:26,840 --> 01:40:31,400
then there are worries about you know

2647
01:40:29,480 --> 01:40:34,679
there can be traditional hacker attempts

2648
01:40:31,400 --> 01:40:36,920
but it also creates this kind of scary

2649
01:40:34,679 --> 01:40:38,840
part where if all of the world's

2650
01:40:36,920 --> 01:40:43,000
information is flowing through one node

2651
01:40:38,840 --> 01:40:45,280
in PL text um you can have surveillance

2652
01:40:43,000 --> 01:40:48,960
in very bad ways and sometimes that will

2653
01:40:45,280 --> 01:40:50,560
happen for you know in initially will be

2654
01:40:48,960 --> 01:40:53,000
like good reasons like people will want

2655
01:40:50,560 --> 01:40:55,920
to try to prot protect against like bad

2656
01:40:53,000 --> 01:40:57,520
Act using AI models in bad ways and then

2657
01:40:55,920 --> 01:40:59,320
you will add in some surveillance code

2658
01:40:57,520 --> 01:41:00,760
and then someone else will come in and

2659
01:40:59,320 --> 01:41:05,080
you know you're in a slippery slope and

2660
01:41:00,760 --> 01:41:08,000
then you start uh doing bad things with

2661
01:41:05,080 --> 01:41:10,400
a lot of the world's data and so I I'm

2662
01:41:08,000 --> 01:41:13,320
very hopeful that uh we can solve

2663
01:41:10,400 --> 01:41:14,719
homomorphic encryption for doing privacy

2664
01:41:13,320 --> 01:41:16,239
preserving machine learning but I would

2665
01:41:14,719 --> 01:41:19,719
say like that's the challenge we have

2666
01:41:16,239 --> 01:41:21,719
with all software these days it's

2667
01:41:19,719 --> 01:41:23,960
like there's so many features that can

2668
01:41:21,719 --> 01:41:25,719
be provided from the cloud and all of us

2669
01:41:23,960 --> 01:41:27,880
increasingly rely on it and make our

2670
01:41:25,719 --> 01:41:29,040
life awesome but there's downsides and

2671
01:41:27,880 --> 01:41:30,639
that's that's why you rely on really

2672
01:41:29,040 --> 01:41:34,199
good security to protect from basic

2673
01:41:30,639 --> 01:41:36,080
attacks but there's also only a small

2674
01:41:34,199 --> 01:41:39,040
set of companies that are controlling

2675
01:41:36,080 --> 01:41:40,400
that data you know and they they

2676
01:41:39,040 --> 01:41:42,000
obviously have leverage and they could

2677
01:41:40,400 --> 01:41:44,719
be infiltrated in all kinds of ways

2678
01:41:42,000 --> 01:41:46,320
that's the world we live in yeah I mean

2679
01:41:44,719 --> 01:41:48,400
the thing I'm just actually quite

2680
01:41:46,320 --> 01:41:50,159
worried about is sort of the world where

2681
01:41:48,400 --> 01:41:53,280
mean entropic has this responsible

2682
01:41:50,159 --> 01:41:55,440
scaling policy and so where we're on

2683
01:41:53,280 --> 01:41:57,760
like the low low asls which is the

2684
01:41:55,440 --> 01:41:59,679
entropic security level or whatever uh

2685
01:41:57,760 --> 01:42:02,679
of like of the models but as we get your

2686
01:41:59,679 --> 01:42:05,599
like cod and code ASL 3L 4 whatever

2687
01:42:02,679 --> 01:42:07,320
models uh which are sort of very

2688
01:42:05,599 --> 01:42:10,679
powerful

2689
01:42:07,320 --> 01:42:12,199
but for for mostly reasonable security

2690
01:42:10,679 --> 01:42:14,639
reasons you would want to monitor all

2691
01:42:12,199 --> 01:42:16,760
the prompts uh but I think I think

2692
01:42:14,639 --> 01:42:18,000
that's that's sort reasonable and

2693
01:42:16,760 --> 01:42:20,560
understandable where where everyone is

2694
01:42:18,000 --> 01:42:22,199
coming from but man it'd be really

2695
01:42:20,560 --> 01:42:24,199
horrible if if sort of like all the

2696
01:42:22,199 --> 01:42:27,040
world's information is sort of monitor

2697
01:42:24,199 --> 01:42:28,760
that heavily it's way too centralized

2698
01:42:27,040 --> 01:42:32,040
it's like it's like sort of this like

2699
01:42:28,760 --> 01:42:33,960
really fine line you're walking where on

2700
01:42:32,040 --> 01:42:35,920
the one side like you don't want the

2701
01:42:33,960 --> 01:42:39,080
models to go Rogue on the other side

2702
01:42:35,920 --> 01:42:40,599
like man humans like I I don't know if I

2703
01:42:39,080 --> 01:42:42,280
if I trust like all the world's

2704
01:42:40,599 --> 01:42:44,960
information to pass through like three

2705
01:42:42,280 --> 01:42:46,679
three model providers yeah why do you

2706
01:42:44,960 --> 01:42:48,880
think it's different than Cloud

2707
01:42:46,679 --> 01:42:52,440
providers because I

2708
01:42:48,880 --> 01:42:54,719
think the this is a lot of this data

2709
01:42:52,440 --> 01:42:58,639
would never have gone to the cloud

2710
01:42:54,719 --> 01:43:00,920
providers in the in the first place um

2711
01:42:58,639 --> 01:43:02,560
where this is often like you want to

2712
01:43:00,920 --> 01:43:04,639
give more data to the eio models you

2713
01:43:02,560 --> 01:43:06,360
want to give personal data that you

2714
01:43:04,639 --> 01:43:09,400
would never have put online in the first

2715
01:43:06,360 --> 01:43:13,920
place uh to these companies or or or to

2716
01:43:09,400 --> 01:43:18,639
these models um and it also centralizes

2717
01:43:13,920 --> 01:43:20,320
control uh where right now um for for

2718
01:43:18,639 --> 01:43:23,440
cloud you can often use your own

2719
01:43:20,320 --> 01:43:28,280
encryption keys and it like it can't

2720
01:43:23,440 --> 01:43:30,280
really do much um but here it's just

2721
01:43:28,280 --> 01:43:31,560
centralized actors that see the exact

2722
01:43:30,280 --> 01:43:34,360
plain text of

2723
01:43:31,560 --> 01:43:36,040
everything on the topic of context that

2724
01:43:34,360 --> 01:43:38,000
that's actually been a friction for me

2725
01:43:36,040 --> 01:43:40,119
when I'm writing code you know in Python

2726
01:43:38,000 --> 01:43:42,800
there's a bunch of stuff imported

2727
01:43:40,119 --> 01:43:44,199
there's a you could probably int it the

2728
01:43:42,800 --> 01:43:47,760
kind of stuff I would like to include in

2729
01:43:44,199 --> 01:43:50,119
the context is there like how how hard

2730
01:43:47,760 --> 01:43:53,440
is it to Auto figure out the

2731
01:43:50,119 --> 01:43:57,000
context It's Tricky um I think we can do

2732
01:43:53,440 --> 01:43:59,040
a lot better um at uh Computing the

2733
01:43:57,000 --> 01:44:00,320
context automatically in the future one

2734
01:43:59,040 --> 01:44:02,679
thing that's important to not is there

2735
01:44:00,320 --> 01:44:04,960
are trade-offs with including automatic

2736
01:44:02,679 --> 01:44:07,480
context so the more context you include

2737
01:44:04,960 --> 01:44:10,960
for these models um first of all the

2738
01:44:07,480 --> 01:44:12,520
slower they are and um the more

2739
01:44:10,960 --> 01:44:14,320
expensive those requests are which means

2740
01:44:12,520 --> 01:44:16,599
you can then do less model calls and do

2741
01:44:14,320 --> 01:44:17,760
less fancy stuff in the background also

2742
01:44:16,599 --> 01:44:18,840
for a lot of these models they get

2743
01:44:17,760 --> 01:44:22,040
confused if you have a lot of

2744
01:44:18,840 --> 01:44:23,920
information in the prompt so the bar for

2745
01:44:22,040 --> 01:44:26,880
um accuracy and for relevance of the

2746
01:44:23,920 --> 01:44:30,800
context you include should be quite High

2747
01:44:26,880 --> 01:44:32,400
um but this is already we do some

2748
01:44:30,800 --> 01:44:33,760
automatic context in some places within

2749
01:44:32,400 --> 01:44:37,119
the product it's definitely something we

2750
01:44:33,760 --> 01:44:39,400
want to get a lot better at and um I

2751
01:44:37,119 --> 01:44:44,119
think that there are a lot of cool ideas

2752
01:44:39,400 --> 01:44:46,440
to try there um both on the learning

2753
01:44:44,119 --> 01:44:48,719
better retrieval systems like better

2754
01:44:46,440 --> 01:44:51,679
edding models better rankers I think

2755
01:44:48,719 --> 01:44:53,040
that there are also cool academic ideas

2756
01:44:51,679 --> 01:44:54,080
you know stuff we've tried out

2757
01:44:53,040 --> 01:44:56,960
internally but also the field is

2758
01:44:54,080 --> 01:44:58,760
grappling with RIT large about can you

2759
01:44:56,960 --> 01:45:00,320
get language models to a place where you

2760
01:44:58,760 --> 01:45:01,800
can actually just have the model itself

2761
01:45:00,320 --> 01:45:04,560
like understand a new Corpus of

2762
01:45:01,800 --> 01:45:06,000
information and the most popular talked

2763
01:45:04,560 --> 01:45:07,880
about version of this is can you make

2764
01:45:06,000 --> 01:45:09,119
the context Windows infinite then if you

2765
01:45:07,880 --> 01:45:10,560
make the context Windows infinite can

2766
01:45:09,119 --> 01:45:12,440
make the model actually pay attention to

2767
01:45:10,560 --> 01:45:13,280
the infinite context and then after you

2768
01:45:12,440 --> 01:45:15,320
can make it pay attention to the

2769
01:45:13,280 --> 01:45:17,159
infinite context to make it somewhat

2770
01:45:15,320 --> 01:45:18,880
feasible to actually do it can you then

2771
01:45:17,159 --> 01:45:20,040
do caching for that infinite context you

2772
01:45:18,880 --> 01:45:22,320
don't have to recompute that all the

2773
01:45:20,040 --> 01:45:24,320
time but there are other cool ideas that

2774
01:45:22,320 --> 01:45:26,000
are being tried that are a little bit

2775
01:45:24,320 --> 01:45:27,159
more analogous to fine-tuning of

2776
01:45:26,000 --> 01:45:30,080
actually learning this information and

2777
01:45:27,159 --> 01:45:31,480
the weights of the model and it might be

2778
01:45:30,080 --> 01:45:34,280
that you actually get sort of a

2779
01:45:31,480 --> 01:45:35,560
qualitatively different type of

2780
01:45:34,280 --> 01:45:36,719
understanding if you do it more at the

2781
01:45:35,560 --> 01:45:38,000
weight level than if you do it at the

2782
01:45:36,719 --> 01:45:40,239
Inc context learning level I think the

2783
01:45:38,000 --> 01:45:42,199
journey the jury is still a little bit

2784
01:45:40,239 --> 01:45:44,360
out on how this is all going to work in

2785
01:45:42,199 --> 01:45:46,159
the end uh but in the interm US us as a

2786
01:45:44,360 --> 01:45:48,320
company we are really excited about

2787
01:45:46,159 --> 01:45:49,560
better retrieval systems and um picking

2788
01:45:48,320 --> 01:45:51,199
the parts of the code base that are most

2789
01:45:49,560 --> 01:45:53,159
relevant to what you're doing uh we

2790
01:45:51,199 --> 01:45:55,280
could do that a lot better like one

2791
01:45:53,159 --> 01:45:57,520
interesting proof of concept for the

2792
01:45:55,280 --> 01:46:01,440
learning this knowledge directly in the

2793
01:45:57,520 --> 01:46:04,119
weights is with vs code so we're in a vs

2794
01:46:01,440 --> 01:46:06,719
code fork and vs code the code is all

2795
01:46:04,119 --> 01:46:09,119
public so these models in pre-training

2796
01:46:06,719 --> 01:46:11,080
have seen all the code um they probably

2797
01:46:09,119 --> 01:46:12,960
also seen questions and answers about it

2798
01:46:11,080 --> 01:46:14,679
and then they've been fine tuned and RL

2799
01:46:12,960 --> 01:46:17,040
Chef to to be able to answer questions

2800
01:46:14,679 --> 01:46:19,080
about code in general so when you ask it

2801
01:46:17,040 --> 01:46:20,480
a question about vs code you know

2802
01:46:19,080 --> 01:46:22,119
sometimes it'll hallucinate but

2803
01:46:20,480 --> 01:46:25,159
sometimes it actually does a pretty good

2804
01:46:22,119 --> 01:46:28,960
job at answering the question and I

2805
01:46:25,159 --> 01:46:30,280
think like this is just by it happens to

2806
01:46:28,960 --> 01:46:32,360
be okay at it but what if you could

2807
01:46:30,280 --> 01:46:35,159
actually like specifically train or Post

2808
01:46:32,360 --> 01:46:38,679
train a model such that it really was

2809
01:46:35,159 --> 01:46:40,280
built to understand this code base um

2810
01:46:38,679 --> 01:46:41,760
it's an open research question one that

2811
01:46:40,280 --> 01:46:43,159
we're quite interested in and then

2812
01:46:41,760 --> 01:46:45,040
there's also uncertainty of like do you

2813
01:46:43,159 --> 01:46:47,679
want the model to be the thing that end

2814
01:46:45,040 --> 01:46:49,800
to end is doing everything I.E it's

2815
01:46:47,679 --> 01:46:51,119
doing the retrieval in its internals and

2816
01:46:49,800 --> 01:46:53,360
then kind of answering your question

2817
01:46:51,119 --> 01:46:56,520
creating the code or do you want to

2818
01:46:53,360 --> 01:46:58,480
separate the retrieval from the Frontier

2819
01:46:56,520 --> 01:46:59,920
Model where maybe you know you'll get

2820
01:46:58,480 --> 01:47:01,280
some really capable models that are much

2821
01:46:59,920 --> 01:47:04,719
better than like the best open source

2822
01:47:01,280 --> 01:47:07,440
ones in a handful of months um and then

2823
01:47:04,719 --> 01:47:08,960
you'll want to separately train a really

2824
01:47:07,440 --> 01:47:10,760
good open source model to be the

2825
01:47:08,960 --> 01:47:14,239
retriever to be the thing that feeds in

2826
01:47:10,760 --> 01:47:16,119
the context um to these larger models

2827
01:47:14,239 --> 01:47:17,800
can you speak a little more to the post

2828
01:47:16,119 --> 01:47:19,639
trining a model to understand the code

2829
01:47:17,800 --> 01:47:21,840
base like what do you what do you mean

2830
01:47:19,639 --> 01:47:23,800
by that with is this synthetic data

2831
01:47:21,840 --> 01:47:26,639
direction is this yeah I mean there are

2832
01:47:23,800 --> 01:47:29,080
many possible ways you could try doing

2833
01:47:26,639 --> 01:47:31,119
it there's certainly no shortage of

2834
01:47:29,080 --> 01:47:32,800
ideas um it's just a question of going

2835
01:47:31,119 --> 01:47:36,000
in and like trying all of them and being

2836
01:47:32,800 --> 01:47:38,119
empirical about which one works best um

2837
01:47:36,000 --> 01:47:40,679
you know one one very naive thing is to

2838
01:47:38,119 --> 01:47:43,840
try to replicate What's Done uh with

2839
01:47:40,679 --> 01:47:45,920
vscode uh and these Frontier models so

2840
01:47:43,840 --> 01:47:47,000
let's like continue pre-training some

2841
01:47:45,920 --> 01:47:48,360
kind of continued pre-training that

2842
01:47:47,000 --> 01:47:51,040
includes General code data but also

2843
01:47:48,360 --> 01:47:52,440
throws in a lot of the data of some

2844
01:47:51,040 --> 01:47:55,360
particular repository that you care

2845
01:47:52,440 --> 01:47:57,480
about and then in post trainining um

2846
01:47:55,360 --> 01:47:59,040
meaning in let's just start with

2847
01:47:57,480 --> 01:48:00,400
instruction fine tuning you have like a

2848
01:47:59,040 --> 01:48:02,560
normal instruction fine tuning data set

2849
01:48:00,400 --> 01:48:06,719
about code then you throw in a lot of

2850
01:48:02,560 --> 01:48:09,400
questions about code in that repository

2851
01:48:06,719 --> 01:48:10,760
um so you could either get ground truth

2852
01:48:09,400 --> 01:48:12,320
ones which might be difficult or you

2853
01:48:10,760 --> 01:48:16,000
could do what you kind of hinted at or

2854
01:48:12,320 --> 01:48:19,239
suggested using synthetic data um I.E

2855
01:48:16,000 --> 01:48:21,920
kind of having the model uh ask

2856
01:48:19,239 --> 01:48:23,880
questions about various re pieces of the

2857
01:48:21,920 --> 01:48:25,679
code um so you kind of take the pieces

2858
01:48:23,880 --> 01:48:28,119
of the code then prompt the model or

2859
01:48:25,679 --> 01:48:30,760
have a model propose a question for that

2860
01:48:28,119 --> 01:48:32,760
piece of code and then add those as

2861
01:48:30,760 --> 01:48:35,520
instruction find Uni data points and

2862
01:48:32,760 --> 01:48:37,679
then in theory this might unlock the

2863
01:48:35,520 --> 01:48:41,360
models ability to answer questions about

2864
01:48:37,679 --> 01:48:43,560
that code base let me ask you about open

2865
01:48:41,360 --> 01:48:46,480
ai1 what do you think is the role of

2866
01:48:43,560 --> 01:48:49,239
that kind of test time compute system in

2867
01:48:46,480 --> 01:48:51,239
programming I think test time compute is

2868
01:48:49,239 --> 01:48:54,400
really really interesting so there's

2869
01:48:51,239 --> 01:48:56,320
been the pre-training regime which will

2870
01:48:54,400 --> 01:48:58,320
kind of as you scale up the amount of

2871
01:48:56,320 --> 01:48:59,840
data and the size of your model get you

2872
01:48:58,320 --> 01:49:02,760
better and better performance both on

2873
01:48:59,840 --> 01:49:04,199
loss and then on Downstream benchmarks

2874
01:49:02,760 --> 01:49:08,920
um and just general performance when we

2875
01:49:04,199 --> 01:49:11,679
use it for coding or or other tasks um

2876
01:49:08,920 --> 01:49:14,040
we're starting to hit uh a bit of a data

2877
01:49:11,679 --> 01:49:16,760
wall meaning it's going to be hard to

2878
01:49:14,040 --> 01:49:18,599
continue scaling up this regime and so

2879
01:49:16,760 --> 01:49:20,159
scaling up 10 test time compute is an

2880
01:49:18,599 --> 01:49:23,040
interesting way of now you know

2881
01:49:20,159 --> 01:49:26,520
increasing the number of inference time

2882
01:49:23,040 --> 01:49:28,080
flops that we use but still getting like

2883
01:49:26,520 --> 01:49:29,920
uh like yeah as you increase the number

2884
01:49:28,080 --> 01:49:32,560
of flops use inference time getting

2885
01:49:29,920 --> 01:49:33,400
corresponding uh improvements in in the

2886
01:49:32,560 --> 01:49:34,679
performance of these models

2887
01:49:33,400 --> 01:49:37,159
traditionally we just had to literally

2888
01:49:34,679 --> 01:49:38,880
train a bigger model that always uses uh

2889
01:49:37,159 --> 01:49:40,480
that always used that many more flops

2890
01:49:38,880 --> 01:49:43,400
but now we could perhaps use the same

2891
01:49:40,480 --> 01:49:45,520
siiz model um and run it for longer to

2892
01:49:43,400 --> 01:49:47,000
be able to get uh an answer at the

2893
01:49:45,520 --> 01:49:48,480
quality of a much larger model and so

2894
01:49:47,000 --> 01:49:50,960
the really interesting thing I like

2895
01:49:48,480 --> 01:49:53,360
about this is there are some problems

2896
01:49:50,960 --> 01:49:54,679
that perhaps require

2897
01:49:53,360 --> 01:49:56,360
100 trillion parameter model

2898
01:49:54,679 --> 01:50:00,520
intelligence trained on 100 trillion

2899
01:49:56,360 --> 01:50:03,360
tokens um but that's like maybe 1% maybe

2900
01:50:00,520 --> 01:50:05,800
like 0.1% of all queries so are you

2901
01:50:03,360 --> 01:50:08,400
going to spend all of this effort all

2902
01:50:05,800 --> 01:50:11,080
this compute training a model uh that

2903
01:50:08,400 --> 01:50:13,320
cost that much and then run it so

2904
01:50:11,080 --> 01:50:15,080
infrequently it feels completely

2905
01:50:13,320 --> 01:50:17,040
wasteful when instead you get the model

2906
01:50:15,080 --> 01:50:19,440
that can that is that you train the

2907
01:50:17,040 --> 01:50:21,760
model that's capable of doing the 99.9%

2908
01:50:19,440 --> 01:50:23,880
of queries then you have a way of

2909
01:50:21,760 --> 01:50:25,800
inference time running it longer for

2910
01:50:23,880 --> 01:50:27,040
those few people that really really want

2911
01:50:25,800 --> 01:50:30,199
Max

2912
01:50:27,040 --> 01:50:32,199
intelligence how do you figure out which

2913
01:50:30,199 --> 01:50:34,000
problem requires what level of

2914
01:50:32,199 --> 01:50:36,360
intelligence is that possible to

2915
01:50:34,000 --> 01:50:38,520
dynamically figure out when to use GPT 4

2916
01:50:36,360 --> 01:50:42,280
when to use like when to use a small

2917
01:50:38,520 --> 01:50:45,679
model and when you need the the

2918
01:50:42,280 --> 01:50:47,679
01 I mean yeah that's that's an open

2919
01:50:45,679 --> 01:50:48,960
research problem certainly uh I don't

2920
01:50:47,679 --> 01:50:51,320
think anyone's actually cracked this

2921
01:50:48,960 --> 01:50:53,639
model routing problem quite well uh we'd

2922
01:50:51,320 --> 01:50:55,760
like to we we have like kind of initial

2923
01:50:53,639 --> 01:50:58,520
implementations of this for things for

2924
01:50:55,760 --> 01:51:02,360
something like cursor tab um but at the

2925
01:50:58,520 --> 01:51:04,920
level of like going between 40 Sonet

2926
01:51:02,360 --> 01:51:06,239
to1 uh it's a bit trickier perh like

2927
01:51:04,920 --> 01:51:07,920
there's also a question of like what

2928
01:51:06,239 --> 01:51:12,199
level of intelligence do you need to

2929
01:51:07,920 --> 01:51:14,079
determine if the thing is uh too hard

2930
01:51:12,199 --> 01:51:18,079
for for the the four level model maybe

2931
01:51:14,079 --> 01:51:20,480
you need the 01 level model um it's

2932
01:51:18,079 --> 01:51:22,880
really unclear but but you mentioned so

2933
01:51:20,480 --> 01:51:25,199
there's a there's there's a pre-training

2934
01:51:22,880 --> 01:51:27,119
process then there's Pro post training

2935
01:51:25,199 --> 01:51:28,960
and then there's like test time compute

2936
01:51:27,119 --> 01:51:32,280
that fair does sort of separate where's

2937
01:51:28,960 --> 01:51:33,840
the biggest gains um well it's weird

2938
01:51:32,280 --> 01:51:36,280
because like test time compute there's

2939
01:51:33,840 --> 01:51:38,400
like a whole training strategy needed to

2940
01:51:36,280 --> 01:51:40,239
get test time compute to work and the

2941
01:51:38,400 --> 01:51:43,880
Really the other really weird thing

2942
01:51:40,239 --> 01:51:46,119
about this is no one like outside of the

2943
01:51:43,880 --> 01:51:47,920
big labs and maybe even just open AI no

2944
01:51:46,119 --> 01:51:50,119
one really knows how it works like there

2945
01:51:47,920 --> 01:51:52,880
have been some really interesting papers

2946
01:51:50,119 --> 01:51:56,280
that uh show hints of what they might be

2947
01:51:52,880 --> 01:51:58,760
doing and so perhaps they're doing

2948
01:51:56,280 --> 01:52:01,280
something with research using process

2949
01:51:58,760 --> 01:52:04,320
reward models but yeah I just I think

2950
01:52:01,280 --> 01:52:05,679
the issue is we don't quite know exactly

2951
01:52:04,320 --> 01:52:07,800
what it looks like so it would be hard

2952
01:52:05,679 --> 01:52:09,560
to kind of comment on like where it fits

2953
01:52:07,800 --> 01:52:11,760
in I I would put it in post training but

2954
01:52:09,560 --> 01:52:13,679
maybe like the compute spent for this

2955
01:52:11,760 --> 01:52:16,280
kind of for getting test time compute to

2956
01:52:13,679 --> 01:52:17,760
work for a model is going to dwarf

2957
01:52:16,280 --> 01:52:20,800
pre-training

2958
01:52:17,760 --> 01:52:23,880
eventually so we don't even know if 0an

2959
01:52:20,800 --> 01:52:25,239
is using just like Chain of Thought RL

2960
01:52:23,880 --> 01:52:29,599
we don't know how they're using any of

2961
01:52:25,239 --> 01:52:32,639
these we don't know anything it's fun to

2962
01:52:29,599 --> 01:52:35,960
speculate like if you were to uh build a

2963
01:52:32,639 --> 01:52:38,760
competing model what would you do yeah

2964
01:52:35,960 --> 01:52:40,079
so one thing to do would be I I think

2965
01:52:38,760 --> 01:52:42,719
you probably need to train a process

2966
01:52:40,079 --> 01:52:44,159
reward model which is so maybe we can

2967
01:52:42,719 --> 01:52:45,599
get into reward models and outcome

2968
01:52:44,159 --> 01:52:47,760
reward models versus process reward

2969
01:52:45,599 --> 01:52:49,840
models outcome reward models are the

2970
01:52:47,760 --> 01:52:51,800
kind of traditional reward models that

2971
01:52:49,840 --> 01:52:54,280
people are trained for these for for

2972
01:52:51,800 --> 01:52:55,480
language models language modeling and

2973
01:52:54,280 --> 01:52:56,719
it's just looking at the final thing so

2974
01:52:55,480 --> 01:52:58,360
if you're doing some math problem let's

2975
01:52:56,719 --> 01:53:01,760
look at that final thing you've done

2976
01:52:58,360 --> 01:53:03,840
everything and let's assign a grade to

2977
01:53:01,760 --> 01:53:05,840
it How likely we think uh like what's

2978
01:53:03,840 --> 01:53:07,880
the reward for this this this outcome

2979
01:53:05,840 --> 01:53:09,760
process reward models Instead try to

2980
01:53:07,880 --> 01:53:11,840
grade The Chain of Thought and so open

2981
01:53:09,760 --> 01:53:16,040
AI had some preliminary paper on this I

2982
01:53:11,840 --> 01:53:18,639
think uh last summer where they use

2983
01:53:16,040 --> 01:53:20,760
human labelers to get this pretty large

2984
01:53:18,639 --> 01:53:23,840
several hundred thousand data set of

2985
01:53:20,760 --> 01:53:25,679
creating chains of thought um um

2986
01:53:23,840 --> 01:53:27,440
ultimately it feels like I haven't seen

2987
01:53:25,679 --> 01:53:29,840
anything interesting in the ways that

2988
01:53:27,440 --> 01:53:34,159
people use process reward models outside

2989
01:53:29,840 --> 01:53:35,920
of just using it as a means of uh

2990
01:53:34,159 --> 01:53:38,280
affecting how we choose between a bunch

2991
01:53:35,920 --> 01:53:40,400
of samples so like what people do uh in

2992
01:53:38,280 --> 01:53:42,400
all these papers is they sample a bunch

2993
01:53:40,400 --> 01:53:44,679
of outputs from the language model and

2994
01:53:42,400 --> 01:53:47,840
then use the process reward models to

2995
01:53:44,679 --> 01:53:49,719
grade uh all those Generations alongside

2996
01:53:47,840 --> 01:53:51,840
maybe some other heuristics and then use

2997
01:53:49,719 --> 01:53:53,800
that to choose the best answer the

2998
01:53:51,840 --> 01:53:56,560
really interesting thing that people

2999
01:53:53,800 --> 01:53:58,520
think might work and people want to work

3000
01:53:56,560 --> 01:54:00,800
is Tre search with these processor re

3001
01:53:58,520 --> 01:54:02,960
models because if you really can grade

3002
01:54:00,800 --> 01:54:05,840
every single step of the Chain of

3003
01:54:02,960 --> 01:54:08,040
Thought then you can kind of Branch out

3004
01:54:05,840 --> 01:54:09,639
and you know explore multiple Paths of

3005
01:54:08,040 --> 01:54:11,719
this Chain of Thought and then use these

3006
01:54:09,639 --> 01:54:13,159
process word models to evaluate how good

3007
01:54:11,719 --> 01:54:15,560
is this branch that you're

3008
01:54:13,159 --> 01:54:17,760
taking yeah when the when the quality of

3009
01:54:15,560 --> 01:54:18,960
the branch is somehow strongly

3010
01:54:17,760 --> 01:54:20,880
correlated with the quality of the

3011
01:54:18,960 --> 01:54:22,760
outcome at the very end so like you have

3012
01:54:20,880 --> 01:54:24,880
a good model of knowing which should

3013
01:54:22,760 --> 01:54:26,719
take so not just this in the short term

3014
01:54:24,880 --> 01:54:27,800
and like in the long term yeah and like

3015
01:54:26,719 --> 01:54:29,199
the interesting work that I think has

3016
01:54:27,800 --> 01:54:31,079
been done is figuring out how to

3017
01:54:29,199 --> 01:54:33,159
properly train the process or the

3018
01:54:31,079 --> 01:54:35,520
interesting work that has been open-

3019
01:54:33,159 --> 01:54:37,679
sourced and people I think uh talk about

3020
01:54:35,520 --> 01:54:40,679
is uh how to train the process reward

3021
01:54:37,679 --> 01:54:42,679
models um maybe in a more automated way

3022
01:54:40,679 --> 01:54:43,920
um I I could be wrong here could not be

3023
01:54:42,679 --> 01:54:46,679
mentioning some papers I haven't seen

3024
01:54:43,920 --> 01:54:49,920
anything super uh that seems to work

3025
01:54:46,679 --> 01:54:51,560
really well for using the process reward

3026
01:54:49,920 --> 01:54:54,079
models creatively to do tree search and

3027
01:54:51,560 --> 01:54:56,280
code um this is kind of an AI safety

3028
01:54:54,079 --> 01:54:57,880
maybe a bit of a philosophy question so

3029
01:54:56,280 --> 01:55:00,119
open AI says that they're hiding the

3030
01:54:57,880 --> 01:55:01,639
Chain of Thought from the user and

3031
01:55:00,119 --> 01:55:04,960
they've said that that was a difficult

3032
01:55:01,639 --> 01:55:06,800
decision to make they instead of showing

3033
01:55:04,960 --> 01:55:09,239
the Chain of Thought they're asking the

3034
01:55:06,800 --> 01:55:10,480
model to summarize the Chain of Thought

3035
01:55:09,239 --> 01:55:12,560
they're also in the background saying

3036
01:55:10,480 --> 01:55:14,040
they're going to monitor the Chain of

3037
01:55:12,560 --> 01:55:16,159
Thought to make sure the model is not

3038
01:55:14,040 --> 01:55:18,840
trying to manipulate the user which is a

3039
01:55:16,159 --> 01:55:20,360
fascinating possibility but anyway what

3040
01:55:18,840 --> 01:55:22,719
do you think about hiding the Chain of

3041
01:55:20,360 --> 01:55:24,800
Thought one consideration for open Ai

3042
01:55:22,719 --> 01:55:26,520
and this is completely speculative could

3043
01:55:24,800 --> 01:55:28,159
be that they want to make it hard for

3044
01:55:26,520 --> 01:55:30,360
people to distill these capabilities out

3045
01:55:28,159 --> 01:55:32,199
of their model it might actually be

3046
01:55:30,360 --> 01:55:34,840
easier if you had access to that hidden

3047
01:55:32,199 --> 01:55:36,480
Chain of Thought uh to replicate the

3048
01:55:34,840 --> 01:55:37,960
technology um because that's pretty

3049
01:55:36,480 --> 01:55:39,119
important data like seeing seeing the

3050
01:55:37,960 --> 01:55:40,760
steps that the model took to get to the

3051
01:55:39,119 --> 01:55:43,079
final result so you can probably train

3052
01:55:40,760 --> 01:55:45,760
on that also and there was sort of a

3053
01:55:43,079 --> 01:55:47,320
mirror situation with this with some of

3054
01:55:45,760 --> 01:55:50,440
the large language model providers and

3055
01:55:47,320 --> 01:55:54,239
also this is speculation but um some of

3056
01:55:50,440 --> 01:55:56,360
these apis um used to offer easy access

3057
01:55:54,239 --> 01:55:58,840
to log probabilities for the tokens that

3058
01:55:56,360 --> 01:56:00,040
they're generating um and also log

3059
01:55:58,840 --> 01:56:02,440
probabilities over the promp tokens and

3060
01:56:00,040 --> 01:56:05,960
then some of these apis took those away

3061
01:56:02,440 --> 01:56:07,400
uh and again complete speculation but um

3062
01:56:05,960 --> 01:56:09,040
one of the thoughts is that the the

3063
01:56:07,400 --> 01:56:11,040
reason those were taken away is if you

3064
01:56:09,040 --> 01:56:12,520
have access to log probabilities um

3065
01:56:11,040 --> 01:56:13,840
similar to this hidden train of thought

3066
01:56:12,520 --> 01:56:15,800
that can give you even more information

3067
01:56:13,840 --> 01:56:17,520
to to try and distill these capabilities

3068
01:56:15,800 --> 01:56:20,320
out of the apis out of these biggest

3069
01:56:17,520 --> 01:56:22,800
models into models you control as an

3070
01:56:20,320 --> 01:56:26,280
asteris on also the the previous

3071
01:56:22,800 --> 01:56:28,560
discussion about uh us integrating 01 I

3072
01:56:26,280 --> 01:56:30,599
think that we're still learning how to

3073
01:56:28,560 --> 01:56:33,320
use this model so we made o1 available

3074
01:56:30,599 --> 01:56:34,760
in cursor because like we were when we

3075
01:56:33,320 --> 01:56:36,400
got the model we were really interested

3076
01:56:34,760 --> 01:56:37,960
in trying it out I think a lot of

3077
01:56:36,400 --> 01:56:41,719
programmers are going to be interested

3078
01:56:37,960 --> 01:56:43,599
in trying it out but um uh 01 is not

3079
01:56:41,719 --> 01:56:47,159
part of the default cursor experience in

3080
01:56:43,599 --> 01:56:50,000
any way up um and we still haven't found

3081
01:56:47,159 --> 01:56:52,040
a way to yet integrate it into an editor

3082
01:56:50,000 --> 01:56:54,199
in uh into the editor in a way that we

3083
01:56:52,040 --> 01:56:57,440
we we reach for sort of you know every

3084
01:56:54,199 --> 01:56:59,119
hour maybe even every day and so I think

3085
01:56:57,440 --> 01:57:03,119
that the jury's still out on how to how

3086
01:56:59,119 --> 01:57:05,360
to use the model um and uh I we haven't

3087
01:57:03,119 --> 01:57:07,560
seen examples yet of of people releasing

3088
01:57:05,360 --> 01:57:09,639
things where it seems really clear like

3089
01:57:07,560 --> 01:57:11,400
oh that's that's like now the use case

3090
01:57:09,639 --> 01:57:13,199
um the obvious one to to turn to is

3091
01:57:11,400 --> 01:57:15,000
maybe this can make it easier for you to

3092
01:57:13,199 --> 01:57:16,159
have these background things running

3093
01:57:15,000 --> 01:57:20,199
right to have these models in Loops to

3094
01:57:16,159 --> 01:57:23,000
have these models be atic um but we're

3095
01:57:20,199 --> 01:57:25,440
still um still discovering to be clear

3096
01:57:23,000 --> 01:57:28,320
we have ideas we just need to we need to

3097
01:57:25,440 --> 01:57:29,960
try and get something incredibly useful

3098
01:57:28,320 --> 01:57:33,079
before we we put it out there but it has

3099
01:57:29,960 --> 01:57:36,719
these significant limitations like even

3100
01:57:33,079 --> 01:57:39,679
like barring capabilities uh it does not

3101
01:57:36,719 --> 01:57:41,480
stream and that means it's really really

3102
01:57:39,679 --> 01:57:43,880
painful to use for things where you want

3103
01:57:41,480 --> 01:57:46,000
to supervise the output um and instead

3104
01:57:43,880 --> 01:57:48,520
you're just waiting for the wall text to

3105
01:57:46,000 --> 01:57:50,440
show up um also it does feel like the

3106
01:57:48,520 --> 01:57:52,480
early Innings of test time Computing

3107
01:57:50,440 --> 01:57:55,360
search where it's just like a very very

3108
01:57:52,480 --> 01:57:58,520
much of V zero um and there's so many

3109
01:57:55,360 --> 01:58:02,920
things that like like don't feel quite

3110
01:57:58,520 --> 01:58:04,760
right and I suspect um in parallel to

3111
01:58:02,920 --> 01:58:06,239
people increasing uh the amount of

3112
01:58:04,760 --> 01:58:07,360
pre-training data and the size of the

3113
01:58:06,239 --> 01:58:09,119
models and pre-training and finding

3114
01:58:07,360 --> 01:58:11,960
tricks there you'll now have this other

3115
01:58:09,119 --> 01:58:12,679
thread of getting search to work better

3116
01:58:11,960 --> 01:58:15,880
and

3117
01:58:12,679 --> 01:58:18,960
better so let me ask you

3118
01:58:15,880 --> 01:58:24,440
about strawberry tomorrow

3119
01:58:18,960 --> 01:58:27,360
eyes so it looks like GitHub um co-pilot

3120
01:58:24,440 --> 01:58:29,639
might be integrating 01 in some kind of

3121
01:58:27,360 --> 01:58:32,119
way and I think some of the comments are

3122
01:58:29,639 --> 01:58:34,560
saying this this mean cursor is

3123
01:58:32,119 --> 01:58:37,159
done I think I saw one comment saying

3124
01:58:34,560 --> 01:58:38,480
that I saw time to shut down cursory

3125
01:58:37,159 --> 01:58:41,440
time to shut down

3126
01:58:38,480 --> 01:58:42,760
cursor so is it time to shut down cursor

3127
01:58:41,440 --> 01:58:45,760
I think this space is a little bit

3128
01:58:42,760 --> 01:58:48,520
different from past software spaces over

3129
01:58:45,760 --> 01:58:50,199
the the 2010s um where I think that the

3130
01:58:48,520 --> 01:58:52,400
ceiling here is really really really

3131
01:58:50,199 --> 01:58:54,520
incredibly high and so I think that the

3132
01:58:52,400 --> 01:58:55,960
best product in 3 to four years will

3133
01:58:54,520 --> 01:58:59,840
just be so much more useful than the

3134
01:58:55,960 --> 01:59:03,280
best product today and you can like Wax

3135
01:58:59,840 --> 01:59:05,239
potic about Moes this and brand that and

3136
01:59:03,280 --> 01:59:07,679
you know this is our uh Advantage but I

3137
01:59:05,239 --> 01:59:08,920
think in the end just if you don't have

3138
01:59:07,679 --> 01:59:11,320
like if you stop innovating on the

3139
01:59:08,920 --> 01:59:13,560
product you will you will lose and

3140
01:59:11,320 --> 01:59:15,119
that's also great for startups um that's

3141
01:59:13,560 --> 01:59:16,800
great for people trying to to enter this

3142
01:59:15,119 --> 01:59:18,920
Market um because it means you have an

3143
01:59:16,800 --> 01:59:21,800
opportunity um to win against people who

3144
01:59:18,920 --> 01:59:24,880
have you know lots of users already by

3145
01:59:21,800 --> 01:59:26,119
just building something better um and so

3146
01:59:24,880 --> 01:59:28,480
I think yeah over the next few years

3147
01:59:26,119 --> 01:59:30,000
it's just about building the best

3148
01:59:28,480 --> 01:59:32,800
product building the best system and

3149
01:59:30,000 --> 01:59:35,320
that both comes down to the modeling

3150
01:59:32,800 --> 01:59:37,560
engine side of things and it also comes

3151
01:59:35,320 --> 01:59:39,880
down to the to the editing experience

3152
01:59:37,560 --> 01:59:41,760
yeah I think most of the additional

3153
01:59:39,880 --> 01:59:44,800
value from cursor versus everything else

3154
01:59:41,760 --> 01:59:47,760
out there is not just integrating the

3155
01:59:44,800 --> 01:59:50,079
new model fast like o1 it comes from all

3156
01:59:47,760 --> 01:59:52,119
of the kind of depth that goes into

3157
01:59:50,079 --> 01:59:53,960
these custom models that you don't

3158
01:59:52,119 --> 01:59:55,960
realize are working for you in kind of

3159
01:59:53,960 --> 01:59:59,599
every facet of the product as well as

3160
01:59:55,960 --> 02:00:00,760
like the really uh thoughtful ux with

3161
01:59:59,599 --> 02:00:03,440
every single

3162
02:00:00,760 --> 02:00:05,159
feature all right uh from that profound

3163
02:00:03,440 --> 02:00:06,679
answer let's descend back down to the

3164
02:00:05,159 --> 02:00:09,719
technical you mentioned you have a

3165
02:00:06,679 --> 02:00:12,400
taxonomy of synthetic data oh yeah uh

3166
02:00:09,719 --> 02:00:14,400
can you please explain yeah I think uh

3167
02:00:12,400 --> 02:00:16,960
there are three main kinds of synthetic

3168
02:00:14,400 --> 02:00:18,840
data the first is so so what is

3169
02:00:16,960 --> 02:00:20,800
synthetic data first so there's normal

3170
02:00:18,840 --> 02:00:24,599
data like non- synthetic data which is

3171
02:00:20,800 --> 02:00:26,639
just data that's naturally created I.E

3172
02:00:24,599 --> 02:00:29,239
usually it'll be from humans having done

3173
02:00:26,639 --> 02:00:32,560
things so uh from some human process you

3174
02:00:29,239 --> 02:00:35,000
get this data synthetic data uh the

3175
02:00:32,560 --> 02:00:37,360
first one would be distillation so

3176
02:00:35,000 --> 02:00:40,360
having a language model kind of output

3177
02:00:37,360 --> 02:00:43,119
tokens or probability distributions over

3178
02:00:40,360 --> 02:00:45,760
tokens um and then you can train some

3179
02:00:43,119 --> 02:00:47,920
less capable model on this uh this

3180
02:00:45,760 --> 02:00:49,239
approach is not going to get you a net

3181
02:00:47,920 --> 02:00:50,639
like more capable model than the

3182
02:00:49,239 --> 02:00:52,639
original one that has produced The

3183
02:00:50,639 --> 02:00:54,480
Tokens um

3184
02:00:52,639 --> 02:00:56,520
but it's really useful for if there's

3185
02:00:54,480 --> 02:00:59,159
some capability you want to elicit from

3186
02:00:56,520 --> 02:01:01,520
some really expensive High latency model

3187
02:00:59,159 --> 02:01:05,079
you can then that distill that down into

3188
02:01:01,520 --> 02:01:08,400
some smaller task specific model um the

3189
02:01:05,079 --> 02:01:11,040
second kind is when like One Direction

3190
02:01:08,400 --> 02:01:14,840
of the problem is easier than the

3191
02:01:11,040 --> 02:01:16,599
reverse and so a great example of this

3192
02:01:14,840 --> 02:01:20,040
is bug detection like we mentioned

3193
02:01:16,599 --> 02:01:22,840
earlier where it's a lot easier to

3194
02:01:20,040 --> 02:01:25,079
introduce reasonable looking bugs

3195
02:01:22,840 --> 02:01:26,280
than it is to actually detect them and

3196
02:01:25,079 --> 02:01:30,320
this is this is probably the case for

3197
02:01:26,280 --> 02:01:32,440
humans too um and so what you can do is

3198
02:01:30,320 --> 02:01:34,400
you can get a model that's not training

3199
02:01:32,440 --> 02:01:35,920
that much data that's not that smart to

3200
02:01:34,400 --> 02:01:38,400
introduce a bunch of bugs and code and

3201
02:01:35,920 --> 02:01:39,920
then you can use that to then train use

3202
02:01:38,400 --> 02:01:42,239
a synthetic data to train a model that

3203
02:01:39,920 --> 02:01:44,719
can be really good at detecting bugs um

3204
02:01:42,239 --> 02:01:47,360
the last category I think is I guess the

3205
02:01:44,719 --> 02:01:51,920
main one that it feels like the big labs

3206
02:01:47,360 --> 02:01:53,679
are doing for synthetic data which is um

3207
02:01:51,920 --> 02:01:58,440
producing texts with language models

3208
02:01:53,679 --> 02:02:00,000
that can then be verified easily um so

3209
02:01:58,440 --> 02:02:01,599
like you know extreme example of this is

3210
02:02:00,000 --> 02:02:05,400
if you have a verification system that

3211
02:02:01,599 --> 02:02:06,440
can detect if language is Shakespeare

3212
02:02:05,400 --> 02:02:08,840
level and then you have a bunch of

3213
02:02:06,440 --> 02:02:10,599
monkeys typing and typewriters like you

3214
02:02:08,840 --> 02:02:12,079
can eventually get enough training data

3215
02:02:10,599 --> 02:02:13,960
to train a Shakespeare level language

3216
02:02:12,079 --> 02:02:16,639
model and I mean this is the case like

3217
02:02:13,960 --> 02:02:18,599
very much the case for math where

3218
02:02:16,639 --> 02:02:21,599
verification is is is actually really

3219
02:02:18,599 --> 02:02:22,880
really easy for formal um formal

3220
02:02:21,599 --> 02:02:24,440
language

3221
02:02:22,880 --> 02:02:27,560
and then what you can do is you can have

3222
02:02:24,440 --> 02:02:30,280
an OKAY model uh generate a ton of roll

3223
02:02:27,560 --> 02:02:32,079
outs and then choose the ones that you

3224
02:02:30,280 --> 02:02:34,639
know have actually proved the ground

3225
02:02:32,079 --> 02:02:35,840
truth theorems and train that further uh

3226
02:02:34,639 --> 02:02:39,440
there's similar things you can do for

3227
02:02:35,840 --> 02:02:41,280
code with leode like problems or uh

3228
02:02:39,440 --> 02:02:43,000
where if you have some set of tests that

3229
02:02:41,280 --> 02:02:44,280
you know correspond to if if something

3230
02:02:43,000 --> 02:02:46,159
passes these tests it has actually

3231
02:02:44,280 --> 02:02:47,360
solved a problem you could do the same

3232
02:02:46,159 --> 02:02:48,880
thing where we verify that it's passed

3233
02:02:47,360 --> 02:02:51,719
the test and then train the model the

3234
02:02:48,880 --> 02:02:52,560
outputs that have passed the tests um I

3235
02:02:51,719 --> 02:02:55,920
think I think it's going to be a little

3236
02:02:52,560 --> 02:02:58,199
tricky getting this to work in all

3237
02:02:55,920 --> 02:03:00,239
domains or just in general like having

3238
02:02:58,199 --> 02:03:03,800
the perfect verifier feels really really

3239
02:03:00,239 --> 02:03:05,360
hard to do with just like open-ended

3240
02:03:03,800 --> 02:03:08,360
miscellaneous tasks you give the model

3241
02:03:05,360 --> 02:03:09,880
or more like long Horizon tasks even in

3242
02:03:08,360 --> 02:03:12,880
coding that's cuz you're not as

3243
02:03:09,880 --> 02:03:14,719
optimistic as Arvid but yeah uh so yeah

3244
02:03:12,880 --> 02:03:17,280
so that that that third category

3245
02:03:14,719 --> 02:03:18,880
requires having a verifier yeah

3246
02:03:17,280 --> 02:03:20,239
verification is it feels like it's best

3247
02:03:18,880 --> 02:03:22,400
when you know for a fact that it's

3248
02:03:20,239 --> 02:03:24,560
correct and like then like it wouldn't

3249
02:03:22,400 --> 02:03:27,760
be like using a language model to verify

3250
02:03:24,560 --> 02:03:30,800
it would be using tests or uh formal

3251
02:03:27,760 --> 02:03:32,360
systems or running the thing too doing

3252
02:03:30,800 --> 02:03:34,480
like the human form of verification

3253
02:03:32,360 --> 02:03:36,400
where you just do manual quality control

3254
02:03:34,480 --> 02:03:37,280
yeah yeah but like the the language

3255
02:03:36,400 --> 02:03:38,440
model version of that where it's like

3256
02:03:37,280 --> 02:03:40,800
running the thing it's actually

3257
02:03:38,440 --> 02:03:42,599
understands yeah but yeah no that's sort

3258
02:03:40,800 --> 02:03:45,280
of somewhere between yeah yeah I think

3259
02:03:42,599 --> 02:03:47,360
that that's the category that is um most

3260
02:03:45,280 --> 02:03:50,440
likely to to result in like massive

3261
02:03:47,360 --> 02:03:52,480
gains what about RL with feedback side

3262
02:03:50,440 --> 02:03:56,239
rhf versus RL

3263
02:03:52,480 --> 02:03:59,239
if um what's the role of that in um

3264
02:03:56,239 --> 02:04:01,520
getting better performance on the

3265
02:03:59,239 --> 02:04:06,159
models yeah so

3266
02:04:01,520 --> 02:04:09,480
rhf is when the reward model you use uh

3267
02:04:06,159 --> 02:04:11,239
is trained from some labels you've

3268
02:04:09,480 --> 02:04:14,040
collected from humans giving

3269
02:04:11,239 --> 02:04:17,760
feedback um I think this works if you

3270
02:04:14,040 --> 02:04:19,719
have the ability to get a ton of human

3271
02:04:17,760 --> 02:04:24,400
feedback for this kind of task that you

3272
02:04:19,719 --> 02:04:26,960
care about r r aif is interesting uh

3273
02:04:24,400 --> 02:04:30,040
because you're kind of depending on like

3274
02:04:26,960 --> 02:04:32,320
this is actually kind of uh going to

3275
02:04:30,040 --> 02:04:34,800
it's depending on the constraint that

3276
02:04:32,320 --> 02:04:37,400
verification is actually a decent bit

3277
02:04:34,800 --> 02:04:39,000
easier than generation because it feels

3278
02:04:37,400 --> 02:04:40,440
like okay like what are you doing you're

3279
02:04:39,000 --> 02:04:41,679
using this language model to look at the

3280
02:04:40,440 --> 02:04:43,559
language model outputs and then improve

3281
02:04:41,679 --> 02:04:46,960
the language model but no it actually

3282
02:04:43,559 --> 02:04:49,800
may work if the language model uh has a

3283
02:04:46,960 --> 02:04:51,159
much easier time verifying some solution

3284
02:04:49,800 --> 02:04:53,639
uh than it does generating it then you

3285
02:04:51,159 --> 02:04:54,679
actually could perhaps get this kind of

3286
02:04:53,639 --> 02:04:57,159
recursively but I don't think it's going

3287
02:04:54,679 --> 02:04:59,280
to look exactly like that um the other

3288
02:04:57,159 --> 02:05:01,880
the other thing you could do

3289
02:04:59,280 --> 02:05:05,920
is that we kind of do is like a little

3290
02:05:01,880 --> 02:05:07,239
bit of a mix of rif and rhf where

3291
02:05:05,920 --> 02:05:08,440
usually the model is actually quite

3292
02:05:07,239 --> 02:05:12,000
correct and this is in the case of

3293
02:05:08,440 --> 02:05:13,880
cursor tab at at picking uh between like

3294
02:05:12,000 --> 02:05:15,559
two possible generations of what is what

3295
02:05:13,880 --> 02:05:17,760
is what is the better one and then it

3296
02:05:15,559 --> 02:05:20,040
just needs like a hand a little bit of

3297
02:05:17,760 --> 02:05:24,599
human nudging with only like on the on

3298
02:05:20,040 --> 02:05:27,000
the order of 50 100 uh examples um to

3299
02:05:24,599 --> 02:05:29,119
like kind of align that prior the model

3300
02:05:27,000 --> 02:05:30,679
has with exactly with what what you want

3301
02:05:29,119 --> 02:05:32,559
it looks different than I think normal

3302
02:05:30,679 --> 02:05:34,719
RF we usually usually training these

3303
02:05:32,559 --> 02:05:36,920
reward models in tons of

3304
02:05:34,719 --> 02:05:40,040
examples what what's your intuition when

3305
02:05:36,920 --> 02:05:41,440
you compare generation and verification

3306
02:05:40,040 --> 02:05:44,880
or generation and

3307
02:05:41,440 --> 02:05:47,360
ranking is is ranking way easier than

3308
02:05:44,880 --> 02:05:50,440
generation my intuition would just say

3309
02:05:47,360 --> 02:05:52,840
yeah it should be like this is kind

3310
02:05:50,440 --> 02:05:55,800
of going going back

3311
02:05:52,840 --> 02:05:58,840
to like if you if you believe P does not

3312
02:05:55,800 --> 02:06:00,880
equal NP then there's this massive class

3313
02:05:58,840 --> 02:06:02,639
of problems that are much much easier to

3314
02:06:00,880 --> 02:06:05,199
verify given a proof than actually

3315
02:06:02,639 --> 02:06:07,760
proving it I wonder if the same thing

3316
02:06:05,199 --> 02:06:10,920
will prove P not equal to NP or P equal

3317
02:06:07,760 --> 02:06:14,599
to NP that would be that would be really

3318
02:06:10,920 --> 02:06:18,199
cool that'd be a whatever Fields

3319
02:06:14,599 --> 02:06:20,239
metal by AI who gets the credit another

3320
02:06:18,199 --> 02:06:23,559
open philosophical

3321
02:06:20,239 --> 02:06:23,559
question I'm

3322
02:06:24,000 --> 02:06:28,840
I'm I'm actually surprisingly curious

3323
02:06:25,599 --> 02:06:30,880
what what what like a good betat for one

3324
02:06:28,840 --> 02:06:33,199
uh one a will get the fields medal will

3325
02:06:30,880 --> 02:06:34,800
be actually don't is this mon specialty

3326
02:06:33,199 --> 02:06:37,480
uh I I don't know what a Mon's bed here

3327
02:06:34,800 --> 02:06:39,920
is oh sorry Nobel Prize or Fields medal

3328
02:06:37,480 --> 02:06:42,520
first F Metal Fields metal level Feld

3329
02:06:39,920 --> 02:06:44,920
metal I think Fields metal comes first

3330
02:06:42,520 --> 02:06:46,679
well you would say that of course but

3331
02:06:44,920 --> 02:06:49,360
it's also this like isolated system you

3332
02:06:46,679 --> 02:06:51,040
can verify and no sure like I don't even

3333
02:06:49,360 --> 02:06:53,520
know if I you don't need to do have much

3334
02:06:51,040 --> 02:06:55,400
more I felt like the path to get to IMO

3335
02:06:53,520 --> 02:06:57,880
was a little bit more clear because it

3336
02:06:55,400 --> 02:06:59,360
already could get a few IMO problems and

3337
02:06:57,880 --> 02:07:00,599
there are a bunch of like there's a

3338
02:06:59,360 --> 02:07:02,599
bunch of lwh hang fruit given the

3339
02:07:00,599 --> 02:07:04,719
literature at the time of like what what

3340
02:07:02,599 --> 02:07:06,800
tactics people could take I think I'm

3341
02:07:04,719 --> 02:07:10,360
one much less first in the space of the

3342
02:07:06,800 --> 02:07:12,440
improving now and to yeah less intuition

3343
02:07:10,360 --> 02:07:16,000
about how close we are to solving these

3344
02:07:12,440 --> 02:07:17,520
really really hard open problems so you

3345
02:07:16,000 --> 02:07:21,000
think you'll be feels mod first it won't

3346
02:07:17,520 --> 02:07:22,440
be like in U physics or in oh 100% I

3347
02:07:21,000 --> 02:07:24,800
think I I think I think that's probably

3348
02:07:22,440 --> 02:07:27,559
more likely like it's probably much more

3349
02:07:24,800 --> 02:07:28,800
likely that it'll get in yeah yeah yeah

3350
02:07:27,559 --> 02:07:31,159
well I think it goes to like I don't

3351
02:07:28,800 --> 02:07:33,719
know like BSD which is a bird when turn

3352
02:07:31,159 --> 02:07:36,280
di conjecture like remon hypothesis or

3353
02:07:33,719 --> 02:07:37,719
any one of these like hard hard math

3354
02:07:36,280 --> 02:07:39,880
problems which just like actually really

3355
02:07:37,719 --> 02:07:42,800
hard it's sort of unclear what the path

3356
02:07:39,880 --> 02:07:44,159
to to get even a solution looks like

3357
02:07:42,800 --> 02:07:46,800
like we we don't even know what a path

3358
02:07:44,159 --> 02:07:48,199
looks like let alone um and you don't

3359
02:07:46,800 --> 02:07:50,079
buy the idea that this is like an

3360
02:07:48,199 --> 02:07:52,320
isolated system and you can actually you

3361
02:07:50,079 --> 02:07:55,000
have a good reward system and

3362
02:07:52,320 --> 02:07:57,119
uh it feels like it's easier to train

3363
02:07:55,000 --> 02:08:01,440
for that I think we might get Fields

3364
02:07:57,119 --> 02:08:02,440
metal before AGI I think I mean I'd be

3365
02:08:01,440 --> 02:08:05,159
very

3366
02:08:02,440 --> 02:08:08,840
happy be very happy but I don't know if

3367
02:08:05,159 --> 02:08:13,000
I I think 202h

3368
02:08:08,840 --> 02:08:15,040
2030 feels metal feels metal all right

3369
02:08:13,000 --> 02:08:17,520
it's uh it feels like forever from now

3370
02:08:15,040 --> 02:08:18,760
given how fast things have been going um

3371
02:08:17,520 --> 02:08:21,719
speaking of how fast things have been

3372
02:08:18,760 --> 02:08:24,599
going let's talk about scaling laws so

3373
02:08:21,719 --> 02:08:27,639
for people who don't know uh maybe it's

3374
02:08:24,599 --> 02:08:30,480
good to talk about this

3375
02:08:27,639 --> 02:08:32,800
whole uh idea of scaling laws what are

3376
02:08:30,480 --> 02:08:34,480
they where do things stand and where do

3377
02:08:32,800 --> 02:08:35,679
you think things are going I think it

3378
02:08:34,480 --> 02:08:38,040
was interesting the original scaling

3379
02:08:35,679 --> 02:08:40,320
laws paper by open AI was slightly wrong

3380
02:08:38,040 --> 02:08:43,360
because I think of some uh issues they

3381
02:08:40,320 --> 02:08:45,040
did with uh learning right schedules uh

3382
02:08:43,360 --> 02:08:47,599
and then chinchilla showed a more

3383
02:08:45,040 --> 02:08:49,239
correct version and then from then

3384
02:08:47,599 --> 02:08:51,159
people have again kind of deviated from

3385
02:08:49,239 --> 02:08:53,199
doing the computer optimal thing because

3386
02:08:51,159 --> 02:08:55,840
people people start now optimizing more

3387
02:08:53,199 --> 02:08:59,719
so for uh making the thing work really

3388
02:08:55,840 --> 02:09:00,920
well given a given an inference budget

3389
02:08:59,719 --> 02:09:04,000
and I think there are a lot more

3390
02:09:00,920 --> 02:09:07,599
Dimensions to these curves than what we

3391
02:09:04,000 --> 02:09:11,119
originally used of just compute number

3392
02:09:07,599 --> 02:09:12,880
of uh parameters and data like inference

3393
02:09:11,119 --> 02:09:14,800
compute is is the obvious one I think

3394
02:09:12,880 --> 02:09:16,119
context length is another obvious one so

3395
02:09:14,800 --> 02:09:18,000
if you care like let's say you care

3396
02:09:16,119 --> 02:09:21,400
about the two things of inference

3397
02:09:18,000 --> 02:09:23,239
compute and and then uh context window

3398
02:09:21,400 --> 02:09:25,840
maybe the thing you want to train is

3399
02:09:23,239 --> 02:09:28,119
some kind of SSM because they're much

3400
02:09:25,840 --> 02:09:30,559
much cheaper and faster at super super

3401
02:09:28,119 --> 02:09:32,280
long context and even if maybe it is 10x

3402
02:09:30,559 --> 02:09:33,840
wor scaling properties during training

3403
02:09:32,280 --> 02:09:35,480
meaning you have to spend 10x more

3404
02:09:33,840 --> 02:09:38,119
compute to train the thing to get the

3405
02:09:35,480 --> 02:09:40,280
same same level of capabilities um it's

3406
02:09:38,119 --> 02:09:41,920
worth it because you care most about

3407
02:09:40,280 --> 02:09:44,079
that inference budget for really long

3408
02:09:41,920 --> 02:09:46,360
context windows so it'll be interesting

3409
02:09:44,079 --> 02:09:48,159
to see how people kind of play with all

3410
02:09:46,360 --> 02:09:49,400
these Dimensions so yeah I mean you

3411
02:09:48,159 --> 02:09:51,440
speak to the multiple Dimensions

3412
02:09:49,400 --> 02:09:53,360
obviously the original conception was

3413
02:09:51,440 --> 02:09:55,000
just looking at the variables of the

3414
02:09:53,360 --> 02:09:56,679
size of the model as measured by

3415
02:09:55,000 --> 02:09:58,360
parameters and the size of the data as

3416
02:09:56,679 --> 02:10:00,520
measured by the number of tokens and

3417
02:09:58,360 --> 02:10:02,520
looking at the ratio of the two yeah and

3418
02:10:00,520 --> 02:10:05,360
it's it's kind of a compelling notion

3419
02:10:02,520 --> 02:10:08,400
that there is a number or at least a

3420
02:10:05,360 --> 02:10:11,400
minimum and it seems like one was

3421
02:10:08,400 --> 02:10:14,760
emerging um do you still believe that

3422
02:10:11,400 --> 02:10:17,280
there is a kind of bigger is

3423
02:10:14,760 --> 02:10:20,239
better I mean I think bigger is

3424
02:10:17,280 --> 02:10:22,880
certainly better for just raw

3425
02:10:20,239 --> 02:10:24,559
performance and raw intelligence and raw

3426
02:10:22,880 --> 02:10:26,559
intelligence I think the the path that

3427
02:10:24,559 --> 02:10:28,960
people might take is I'm particularly

3428
02:10:26,559 --> 02:10:31,480
bullish on distillation and like yeah

3429
02:10:28,960 --> 02:10:34,040
how many knobs can you turn to if we

3430
02:10:31,480 --> 02:10:36,960
spend like a ton ton of money on

3431
02:10:34,040 --> 02:10:39,280
training like get the most capable uh

3432
02:10:36,960 --> 02:10:40,639
cheap model right like really really

3433
02:10:39,280 --> 02:10:42,400
caring as much as you can because like

3434
02:10:40,639 --> 02:10:43,599
the the the naive version of caring as

3435
02:10:42,400 --> 02:10:44,920
much as you can about inference time

3436
02:10:43,599 --> 02:10:46,880
Compu is what people have already done

3437
02:10:44,920 --> 02:10:50,280
with like the Llama models are just

3438
02:10:46,880 --> 02:10:53,280
overtraining the out of 7B models

3439
02:10:50,280 --> 02:10:54,880
um on way way way more tokens than isal

3440
02:10:53,280 --> 02:10:56,280
optimal right but if you really care

3441
02:10:54,880 --> 02:10:58,239
about it maybe thing to do is what Gemma

3442
02:10:56,280 --> 02:10:59,559
did which is let's just not let's not

3443
02:10:58,239 --> 02:11:01,760
just train on tokens let's literally

3444
02:10:59,559 --> 02:11:04,599
train on

3445
02:11:01,760 --> 02:11:08,320
uh minim minimizing the K Divergence

3446
02:11:04,599 --> 02:11:11,079
with uh the distribution of Gemma 27b

3447
02:11:08,320 --> 02:11:12,840
right so knowledge distillation there um

3448
02:11:11,079 --> 02:11:15,440
and you're spending the compute of

3449
02:11:12,840 --> 02:11:17,199
literally training this 27 billion model

3450
02:11:15,440 --> 02:11:19,280
uh billion parameter model on all these

3451
02:11:17,199 --> 02:11:21,480
tokens just to get out this I don't know

3452
02:11:19,280 --> 02:11:23,880
smaller model and the distillation gives

3453
02:11:21,480 --> 02:11:27,559
just a faster model smaller means faster

3454
02:11:23,880 --> 02:11:29,320
yeah distillation in theory is um I

3455
02:11:27,559 --> 02:11:30,880
think getting out more signal from the

3456
02:11:29,320 --> 02:11:32,440
data that you're training on and it's

3457
02:11:30,880 --> 02:11:34,599
like another it's it's perhaps another

3458
02:11:32,440 --> 02:11:36,719
way of getting over not like completely

3459
02:11:34,599 --> 02:11:38,480
over but like partially helping with the

3460
02:11:36,719 --> 02:11:39,920
data wall where like you only have so

3461
02:11:38,480 --> 02:11:41,400
much data to train on let's like train

3462
02:11:39,920 --> 02:11:43,079
this really really big model on all

3463
02:11:41,400 --> 02:11:44,559
these tokens and we'll distill it into

3464
02:11:43,079 --> 02:11:48,960
this smaller one and maybe we can get

3465
02:11:44,559 --> 02:11:50,320
more signal uh per token uh for this for

3466
02:11:48,960 --> 02:11:51,920
this much smaller model than we would

3467
02:11:50,320 --> 02:11:54,639
have originally if we trained it so if I

3468
02:11:51,920 --> 02:11:57,159
gave you1 trillion how would you how

3469
02:11:54,639 --> 02:11:59,000
would you spend it I mean you can't buy

3470
02:11:57,159 --> 02:12:02,360
an island or whatever um how would you

3471
02:11:59,000 --> 02:12:04,679
allocate it in terms of improving the

3472
02:12:02,360 --> 02:12:10,920
the big model

3473
02:12:04,679 --> 02:12:13,360
versus maybe paying for HF in the rhf or

3474
02:12:10,920 --> 02:12:15,920
yeah I think there's a lot of these

3475
02:12:13,360 --> 02:12:18,320
secrets and details about training these

3476
02:12:15,920 --> 02:12:20,040
large models that I I I just don't know

3477
02:12:18,320 --> 02:12:21,679
and are only priv to the large labs and

3478
02:12:20,040 --> 02:12:24,280
the issue is I would waste a lot of that

3479
02:12:21,679 --> 02:12:26,840
money if I even attempted this because I

3480
02:12:24,280 --> 02:12:29,559
wouldn't know those things uh suspending

3481
02:12:26,840 --> 02:12:30,480
a lot of disbelief and assuming like you

3482
02:12:29,559 --> 02:12:33,520
had the

3483
02:12:30,480 --> 02:12:35,400
knowhow um and operate or or if you're

3484
02:12:33,520 --> 02:12:37,000
saying like you have to operate with

3485
02:12:35,400 --> 02:12:39,960
like the The Limited information you

3486
02:12:37,000 --> 02:12:41,480
have now no no no actually I would say

3487
02:12:39,960 --> 02:12:42,840
you swoop in and you get all the

3488
02:12:41,480 --> 02:12:44,000
information all the little

3489
02:12:42,840 --> 02:12:47,159
characteristics all the little

3490
02:12:44,000 --> 02:12:50,559
parameters all the all the parameters

3491
02:12:47,159 --> 02:12:51,679
that Define how the thing is trained mhm

3492
02:12:50,559 --> 02:12:53,880
if we look

3493
02:12:51,679 --> 02:12:55,840
and how to invest money for the next 5

3494
02:12:53,880 --> 02:12:58,280
years in terms of maximizing what you

3495
02:12:55,840 --> 02:13:00,040
called raw intelligence I mean isn't the

3496
02:12:58,280 --> 02:13:01,719
answer like really simple you just you

3497
02:13:00,040 --> 02:13:03,520
just try to get as much compute as

3498
02:13:01,719 --> 02:13:06,040
possible like like at the end of the day

3499
02:13:03,520 --> 02:13:08,440
all all you need to buy is the gpus and

3500
02:13:06,040 --> 02:13:10,480
then the researchers can find find all

3501
02:13:08,440 --> 02:13:12,960
the all like they they can sort of you

3502
02:13:10,480 --> 02:13:15,360
you can tune whether you want between a

3503
02:13:12,960 --> 02:13:16,639
big model or a small model like well

3504
02:13:15,360 --> 02:13:18,800
this gets into the question of like are

3505
02:13:16,639 --> 02:13:21,280
you really limited by compute and money

3506
02:13:18,800 --> 02:13:24,000
or are you limited by these other things

3507
02:13:21,280 --> 02:13:25,440
and I'm more PR to arvid's arvid's

3508
02:13:24,000 --> 02:13:28,320
belief that we're we're sort of Ideal

3509
02:13:25,440 --> 02:13:30,880
limited but there's always that like but

3510
02:13:28,320 --> 02:13:33,119
if you have a lot of computes you can

3511
02:13:30,880 --> 02:13:36,360
run a lot of experiments so you would

3512
02:13:33,119 --> 02:13:38,880
run a lot of experiments versus like use

3513
02:13:36,360 --> 02:13:42,159
that compute to train a gigantic model I

3514
02:13:38,880 --> 02:13:44,800
would but I I do believe that we are

3515
02:13:42,159 --> 02:13:47,119
limited in terms of ideas that we have I

3516
02:13:44,800 --> 02:13:49,360
think yeah because even with all this

3517
02:13:47,119 --> 02:13:51,440
compute and like you know all the data

3518
02:13:49,360 --> 02:13:53,920
you could collect in the world than you

3519
02:13:51,440 --> 02:13:58,000
really are ultimately limited by not

3520
02:13:53,920 --> 02:14:00,320
even ideas but just like really good

3521
02:13:58,000 --> 02:14:01,559
engineering like even with all the

3522
02:14:00,320 --> 02:14:04,400
capital in the world would you really be

3523
02:14:01,559 --> 02:14:06,280
able to assemble like there aren't that

3524
02:14:04,400 --> 02:14:08,679
many people in the world who really can

3525
02:14:06,280 --> 02:14:10,800
like make the difference here um and and

3526
02:14:08,679 --> 02:14:13,360
there's so much work that goes into

3527
02:14:10,800 --> 02:14:16,280
research that is just like pure really

3528
02:14:13,360 --> 02:14:19,040
really hard engineering work um as like

3529
02:14:16,280 --> 02:14:20,599
a very kind of handwavy example if you

3530
02:14:19,040 --> 02:14:21,760
look at the original Transformer paper

3531
02:14:20,599 --> 02:14:24,320
you know how much work was kind of

3532
02:14:21,760 --> 02:14:26,000
joining together a lot of these really

3533
02:14:24,320 --> 02:14:28,880
interesting Concepts embedded in the

3534
02:14:26,000 --> 02:14:30,840
literature versus then going in and

3535
02:14:28,880 --> 02:14:32,079
writing all the code like maybe the Cuda

3536
02:14:30,840 --> 02:14:34,000
kernels maybe whatever else I don't know

3537
02:14:32,079 --> 02:14:36,480
if it ran on gpus or tpus originally

3538
02:14:34,000 --> 02:14:39,159
such that it actually saturated the GP

3539
02:14:36,480 --> 02:14:41,199
GPU performance right getting Gomes here

3540
02:14:39,159 --> 02:14:42,400
to go in and do do all this code right

3541
02:14:41,199 --> 02:14:44,320
and Nome is like probably one of the

3542
02:14:42,400 --> 02:14:45,639
best engineers in the world or maybe

3543
02:14:44,320 --> 02:14:47,719
going a step further like the next

3544
02:14:45,639 --> 02:14:49,719
generation of models having these things

3545
02:14:47,719 --> 02:14:51,679
like getting model Paralis to work and

3546
02:14:49,719 --> 02:14:54,520
scaling it on like you know thousands of

3547
02:14:51,679 --> 02:14:57,159
or maybe tens of thousands of like v100s

3548
02:14:54,520 --> 02:14:58,760
which I think gbd3 may have been um

3549
02:14:57,159 --> 02:15:00,880
there's just so much engineering effort

3550
02:14:58,760 --> 02:15:04,119
that has to go into all of these things

3551
02:15:00,880 --> 02:15:05,760
to make it work um if you really brought

3552
02:15:04,119 --> 02:15:08,559
that cost down

3553
02:15:05,760 --> 02:15:11,199
to like you know maybe not zero but just

3554
02:15:08,559 --> 02:15:13,559
made it 10x easier made it super easy

3555
02:15:11,199 --> 02:15:15,880
for someone with really fantastic ideas

3556
02:15:13,559 --> 02:15:17,360
to immediately get to the version of

3557
02:15:15,880 --> 02:15:21,159
like the new architecture they dreamed

3558
02:15:17,360 --> 02:15:23,159
up that is like getting 50 40% uh

3559
02:15:21,159 --> 02:15:27,719
utilization on the gpus I think that

3560
02:15:23,159 --> 02:15:29,040
would just speed up research by a ton I

3561
02:15:27,719 --> 02:15:31,000
mean I think I think if if you see a

3562
02:15:29,040 --> 02:15:32,199
clear path to Improvement you you should

3563
02:15:31,000 --> 02:15:34,239
always sort of take the low hanging

3564
02:15:32,199 --> 02:15:36,960
fruit first right and I think probably

3565
02:15:34,239 --> 02:15:38,360
open eye and and all the other labs it

3566
02:15:36,960 --> 02:15:39,960
did the right thing to pick off the low

3567
02:15:38,360 --> 02:15:42,199
hanging fruit where the low hanging

3568
02:15:39,960 --> 02:15:46,000
fruit is like sort

3569
02:15:42,199 --> 02:15:47,599
of you you could scale up to a GP

3570
02:15:46,000 --> 02:15:51,079
24.25

3571
02:15:47,599 --> 02:15:52,960
scale um and and you just keep scaling

3572
02:15:51,079 --> 02:15:55,800
and and like things things keep getting

3573
02:15:52,960 --> 02:15:57,079
better and as long as like you there's

3574
02:15:55,800 --> 02:15:58,159
there's no point of experimenting with

3575
02:15:57,079 --> 02:16:00,719
new ideas when like everything

3576
02:15:58,159 --> 02:16:02,559
everything is working and you should

3577
02:16:00,719 --> 02:16:04,159
sort of bang on and try try to get as

3578
02:16:02,559 --> 02:16:05,360
much as much juice out as the possible

3579
02:16:04,159 --> 02:16:07,440
and then and then maybe maybe when you

3580
02:16:05,360 --> 02:16:08,480
really need new ideas for I think I

3581
02:16:07,440 --> 02:16:10,960
think if you're if you're spending $10

3582
02:16:08,480 --> 02:16:12,880
trillion you probably want to spend some

3583
02:16:10,960 --> 02:16:14,360
you know then actually like reevaluate

3584
02:16:12,880 --> 02:16:16,280
your ideas like probably your idea

3585
02:16:14,360 --> 02:16:19,360
Limited at that point I think all of us

3586
02:16:16,280 --> 02:16:22,079
believe new ideas are probably needed to

3587
02:16:19,360 --> 02:16:24,040
get you know all the way way there to

3588
02:16:22,079 --> 02:16:27,239
Ai

3589
02:16:24,040 --> 02:16:29,320
and all of us also probably believe

3590
02:16:27,239 --> 02:16:31,399
there exist ways of testing out those

3591
02:16:29,320 --> 02:16:34,120
ideas at smaller

3592
02:16:31,399 --> 02:16:37,760
scales um and being fairly confident

3593
02:16:34,120 --> 02:16:39,679
that they'll play out it's just quite

3594
02:16:37,760 --> 02:16:43,080
difficult for the labs in their current

3595
02:16:39,679 --> 02:16:46,000
position to dedicate their very limited

3596
02:16:43,080 --> 02:16:47,559
research and Engineering talent to

3597
02:16:46,000 --> 02:16:50,200
exploring all these other ideas when

3598
02:16:47,559 --> 02:16:53,519
there's like this core thing that will

3599
02:16:50,200 --> 02:16:55,240
probably improve performance um for some

3600
02:16:53,519 --> 02:16:58,200
like decent amount of

3601
02:16:55,240 --> 02:17:03,760
time yeah but also these big Labs like

3602
02:16:58,200 --> 02:17:07,280
winning so they're just going wild

3603
02:17:03,760 --> 02:17:09,559
okay so how uh big question looking out

3604
02:17:07,280 --> 02:17:12,319
into the future you're now at the the

3605
02:17:09,559 --> 02:17:13,880
center of the programming world how do

3606
02:17:12,319 --> 02:17:16,479
you think programming the nature

3607
02:17:13,880 --> 02:17:18,200
programming changes in the next few

3608
02:17:16,479 --> 02:17:21,280
months in the next year in the next two

3609
02:17:18,200 --> 02:17:23,920
years the next 5 years 10 years I think

3610
02:17:21,280 --> 02:17:25,439
we're really excited about a future

3611
02:17:23,920 --> 02:17:29,000
where the programmer is in the driver's

3612
02:17:25,439 --> 02:17:30,840
seat for a long time and you've heard us

3613
02:17:29,000 --> 02:17:31,800
talk about this a little bit but one

3614
02:17:30,840 --> 02:17:34,519
that

3615
02:17:31,800 --> 02:17:37,319
emphasizes speed and agency for the

3616
02:17:34,519 --> 02:17:38,840
programmer and control the ability to

3617
02:17:37,319 --> 02:17:40,359
modify anything you want to modify the

3618
02:17:38,840 --> 02:17:41,000
ability to iterate really fast on what

3619
02:17:40,359 --> 02:17:42,599
you're

3620
02:17:41,000 --> 02:17:45,319
building

3621
02:17:42,599 --> 02:17:48,359
and this is a little different I think

3622
02:17:45,319 --> 02:17:52,439
than where some people um are are

3623
02:17:48,359 --> 02:17:54,639
jumping to uh in the space where I think

3624
02:17:52,439 --> 02:17:58,519
one idea that's captivated people is can

3625
02:17:54,639 --> 02:17:59,800
you talk to your um computer can you

3626
02:17:58,519 --> 02:18:00,960
have it build software for you as if

3627
02:17:59,800 --> 02:18:02,840
you're talking to like an engineering

3628
02:18:00,960 --> 02:18:04,080
department or an engineer over slack and

3629
02:18:02,840 --> 02:18:08,000
can it just be this this sort of

3630
02:18:04,080 --> 02:18:11,240
isolated text box and um part of the

3631
02:18:08,000 --> 02:18:12,200
reason we're not excited about that is

3632
02:18:11,240 --> 02:18:14,200
you know some of the stuff we've talked

3633
02:18:12,200 --> 02:18:16,359
about with latency but then a big piece

3634
02:18:14,200 --> 02:18:18,120
a reason we're not excited about that is

3635
02:18:16,359 --> 02:18:20,200
because that comes with giving up a lot

3636
02:18:18,120 --> 02:18:21,599
of control it's much harder to be really

3637
02:18:20,200 --> 02:18:25,000
specific when you're talking in the text

3638
02:18:21,599 --> 02:18:26,319
box and um if you're necessarily just

3639
02:18:25,000 --> 02:18:27,359
going to communicate with a thing like

3640
02:18:26,319 --> 02:18:28,359
you would be communicating with an

3641
02:18:27,359 --> 02:18:29,880
engineering department you're actually

3642
02:18:28,359 --> 02:18:33,559
abdicating tons of tons of really

3643
02:18:29,880 --> 02:18:35,880
important decisions um to the spot um

3644
02:18:33,559 --> 02:18:39,920
and this kind of gets at fundamentally

3645
02:18:35,880 --> 02:18:41,040
what engineering is um I think that some

3646
02:18:39,920 --> 02:18:42,200
some people who are a little bit more

3647
02:18:41,040 --> 02:18:44,080
removed from engineering might think of

3648
02:18:42,200 --> 02:18:46,120
it as you know the spec is completely

3649
02:18:44,080 --> 02:18:48,160
written out and then the engineers just

3650
02:18:46,120 --> 02:18:49,719
come and they just Implement and it's

3651
02:18:48,160 --> 02:18:53,120
just about making the thing happen in

3652
02:18:49,719 --> 02:18:54,719
code and making the thing um exists um

3653
02:18:53,120 --> 02:18:56,359
but I think a lot of the the best

3654
02:18:54,719 --> 02:18:59,080
engineering the engineering we

3655
02:18:56,359 --> 02:19:00,399
enjoy um involves tons of tiny micro

3656
02:18:59,080 --> 02:19:02,160
decisions about what exactly you're

3657
02:19:00,399 --> 02:19:04,800
building and about really hard

3658
02:19:02,160 --> 02:19:06,920
trade-offs between you know speed and

3659
02:19:04,800 --> 02:19:11,200
cost and all the other uh things

3660
02:19:06,920 --> 02:19:13,719
involved in a system and uh we want as

3661
02:19:11,200 --> 02:19:15,439
long as humans are actually the ones

3662
02:19:13,719 --> 02:19:17,840
making you know designing the software

3663
02:19:15,439 --> 02:19:19,080
and the ones um specifying what they

3664
02:19:17,840 --> 02:19:21,319
want to be built and it's not just like

3665
02:19:19,080 --> 02:19:22,960
company run by all AIS we think you'll

3666
02:19:21,319 --> 02:19:26,359
really want the humor the human in a

3667
02:19:22,960 --> 02:19:27,880
driver seat um dictating these decisions

3668
02:19:26,359 --> 02:19:31,200
and so there's the jury still out on

3669
02:19:27,880 --> 02:19:33,559
kind of what that looks like I think

3670
02:19:31,200 --> 02:19:35,120
that you know one weird idea for what

3671
02:19:33,559 --> 02:19:37,319
that could look like is it could look

3672
02:19:35,120 --> 02:19:39,000
like you kind of you can control the

3673
02:19:37,319 --> 02:19:42,639
level of abstraction you view a codebase

3674
02:19:39,000 --> 02:19:45,479
at and you can point at specific parts

3675
02:19:42,639 --> 02:19:47,719
of a codebase that um like maybe you

3676
02:19:45,479 --> 02:19:51,200
digest a code Base by looking at it in

3677
02:19:47,719 --> 02:19:52,720
the form of pseudo code and um you can

3678
02:19:51,200 --> 02:19:54,840
actually edit that pseudo code too and

3679
02:19:52,720 --> 02:19:56,760
then have changes get made down at the

3680
02:19:54,840 --> 02:19:58,720
the sort of formal programming level and

3681
02:19:56,760 --> 02:20:02,120
you keep the like you know you can

3682
02:19:58,720 --> 02:20:04,319
gestat any piece of logic uh in your

3683
02:20:02,120 --> 02:20:06,160
software component of programming you

3684
02:20:04,319 --> 02:20:08,600
keep the inflow text editing component

3685
02:20:06,160 --> 02:20:10,120
of programming you keep the control of

3686
02:20:08,600 --> 02:20:12,359
you can even go down into the code you

3687
02:20:10,120 --> 02:20:13,640
can go at higher levels of abstraction

3688
02:20:12,359 --> 02:20:15,240
while also giving you these big

3689
02:20:13,640 --> 02:20:17,200
productivity gains it would be nice if

3690
02:20:15,240 --> 02:20:19,160
you can go up and down the the

3691
02:20:17,200 --> 02:20:20,240
abstraction stack yeah and there are a

3692
02:20:19,160 --> 02:20:22,120
lot of details to figure out there

3693
02:20:20,240 --> 02:20:23,760
that's sort of a fuzzy idea time will

3694
02:20:22,120 --> 02:20:25,720
tell if it actually works but these

3695
02:20:23,760 --> 02:20:26,760
these principles of of control and speed

3696
02:20:25,720 --> 02:20:29,000
in the human and the driver seat we

3697
02:20:26,760 --> 02:20:30,640
think are really important um we think

3698
02:20:29,000 --> 02:20:32,399
for some things like Arvid mentioned

3699
02:20:30,640 --> 02:20:34,520
before for some styles of programming

3700
02:20:32,399 --> 02:20:35,880
you can kind of hand it off chapot style

3701
02:20:34,520 --> 02:20:38,800
you know if you have a bug that's really

3702
02:20:35,880 --> 02:20:40,920
well specified but that's not most of

3703
02:20:38,800 --> 02:20:42,640
programming and that's also not most of

3704
02:20:40,920 --> 02:20:44,960
the programming we think a lot of people

3705
02:20:42,640 --> 02:20:46,680
value uh what about like the fundamental

3706
02:20:44,960 --> 02:20:47,680
skill of programming there's a lot of

3707
02:20:46,680 --> 02:20:52,160
people

3708
02:20:47,680 --> 02:20:54,399
like young people right now kind of

3709
02:20:52,160 --> 02:20:55,840
scared like thinking because they like

3710
02:20:54,399 --> 02:20:57,240
love programming but they're scared

3711
02:20:55,840 --> 02:20:59,960
about like will I be able to have a

3712
02:20:57,240 --> 02:21:01,840
future if I pursue this career path do

3713
02:20:59,960 --> 02:21:04,479
you think the very skill of programming

3714
02:21:01,840 --> 02:21:06,399
will change fundamentally I actually

3715
02:21:04,479 --> 02:21:08,439
think this is a really really exciting

3716
02:21:06,399 --> 02:21:12,120
time to be building software yeah like

3717
02:21:08,439 --> 02:21:16,080
we remember what programming was like in

3718
02:21:12,120 --> 02:21:19,600
you know 2013 2012 whatever it was um

3719
02:21:16,080 --> 02:21:23,760
and there was just so much more Cru and

3720
02:21:19,600 --> 02:21:26,120
boilerplate and and you know looking up

3721
02:21:23,760 --> 02:21:27,600
something really gnarly and you know

3722
02:21:26,120 --> 02:21:30,520
that stuff still exists it's definitely

3723
02:21:27,600 --> 02:21:33,040
not at zero but programming today is way

3724
02:21:30,520 --> 02:21:35,040
more fun than back then um it's like

3725
02:21:33,040 --> 02:21:38,040
we're really getting down to the the

3726
02:21:35,040 --> 02:21:39,160
Delight concentration and all all the

3727
02:21:38,040 --> 02:21:40,399
things that really draw people to

3728
02:21:39,160 --> 02:21:41,600
programming like for instance this

3729
02:21:40,399 --> 02:21:44,880
element of being able to build things

3730
02:21:41,600 --> 02:21:46,479
really fast and um speed and also

3731
02:21:44,880 --> 02:21:49,479
individual control like all those are

3732
02:21:46,479 --> 02:21:50,600
just being turned up a ton um and so I

3733
02:21:49,479 --> 02:21:51,880
think it's just going to be I think it's

3734
02:21:50,600 --> 02:21:54,000
going to be a really really fun time for

3735
02:21:51,880 --> 02:21:55,600
people who build software um I think

3736
02:21:54,000 --> 02:21:58,000
that the skills will probably change too

3737
02:21:55,600 --> 02:21:59,920
I I think that people's taste and

3738
02:21:58,000 --> 02:22:01,160
creative ideas will be magnified and it

3739
02:21:59,920 --> 02:22:04,000
will be less

3740
02:22:01,160 --> 02:22:06,000
about maybe less a little bit about

3741
02:22:04,000 --> 02:22:07,960
boilerplate text editing maybe even a

3742
02:22:06,000 --> 02:22:10,720
little bit less about carefulness which

3743
02:22:07,960 --> 02:22:12,200
I think is really important today if

3744
02:22:10,720 --> 02:22:15,319
you're a programmer I think it'll be a

3745
02:22:12,200 --> 02:22:17,640
lot more fun what do you guys think I

3746
02:22:15,319 --> 02:22:21,920
agree I'm I'm very excited to be able to

3747
02:22:17,640 --> 02:22:23,840
change like just what one thing that

3748
02:22:21,920 --> 02:22:25,680
that happened recently was like we

3749
02:22:23,840 --> 02:22:28,520
wanted to do a relatively big migration

3750
02:22:25,680 --> 02:22:30,600
to our codebase we were using async

3751
02:22:28,520 --> 02:22:32,080
local storage in in no. JS which is

3752
02:22:30,600 --> 02:22:33,800
known to be not very performant and we

3753
02:22:32,080 --> 02:22:36,040
wanted to migrate to our context object

3754
02:22:33,800 --> 02:22:38,399
and this is a big migration it affects

3755
02:22:36,040 --> 02:22:41,680
the entire code base and swall and I

3756
02:22:38,399 --> 02:22:43,760
spent I don't know five days uh working

3757
02:22:41,680 --> 02:22:47,160
through this even with today's AI tools

3758
02:22:43,760 --> 02:22:49,479
and I am really excited for a future

3759
02:22:47,160 --> 02:22:53,080
where I can just show a couple of

3760
02:22:49,479 --> 02:22:54,720
examples and then the AI applies that to

3761
02:22:53,080 --> 02:22:57,120
all of the locations and then it

3762
02:22:54,720 --> 02:22:58,479
highlights oh this is a new example like

3763
02:22:57,120 --> 02:23:01,000
what should I do and then I show exactly

3764
02:22:58,479 --> 02:23:03,240
what to do there and then that can be

3765
02:23:01,000 --> 02:23:05,319
done in like 10 minutes uh and then you

3766
02:23:03,240 --> 02:23:07,680
can iterate much much faster then you

3767
02:23:05,319 --> 02:23:09,319
can then you don't have to think as much

3768
02:23:07,680 --> 02:23:11,399
up front and stay stand at the

3769
02:23:09,319 --> 02:23:12,720
Blackboard and like think exactly like

3770
02:23:11,399 --> 02:23:14,680
how are we going to do this because the

3771
02:23:12,720 --> 02:23:16,840
cost is so high but you can just try

3772
02:23:14,680 --> 02:23:18,520
something first and you realize oh this

3773
02:23:16,840 --> 02:23:20,560
is not actually exactly what I want and

3774
02:23:18,520 --> 02:23:23,399
then you can change it instantly again

3775
02:23:20,560 --> 02:23:25,680
after and so yeah I think being a

3776
02:23:23,399 --> 02:23:28,200
programmer in the future is going to be

3777
02:23:25,680 --> 02:23:30,560
a lot of fun yeah I I really like that

3778
02:23:28,200 --> 02:23:32,920
point about it feels like a lot of the

3779
02:23:30,560 --> 02:23:34,680
time with programming there are two ways

3780
02:23:32,920 --> 02:23:37,279
you can go about it one is like you

3781
02:23:34,680 --> 02:23:39,880
think really hard carefully upfront

3782
02:23:37,279 --> 02:23:41,520
about the best possible way to do it and

3783
02:23:39,880 --> 02:23:44,399
then you spend your limited time of

3784
02:23:41,520 --> 02:23:45,720
engineering to actually implement it uh

3785
02:23:44,399 --> 02:23:47,760
but I much prefer just getting in the

3786
02:23:45,720 --> 02:23:49,359
code and like you know taking a crack at

3787
02:23:47,760 --> 02:23:51,439
seeing how it how how it kind of lays

3788
02:23:49,359 --> 02:23:52,800
out and then

3789
02:23:51,439 --> 02:23:56,439
iterating really quickly on that that

3790
02:23:52,800 --> 02:23:58,600
feels more fun um yeah like just

3791
02:23:56,439 --> 02:24:01,279
speaking to generating the boiler plate

3792
02:23:58,600 --> 02:24:03,080
is great so you just focus on the

3793
02:24:01,279 --> 02:24:05,680
difficult design nuanced difficult

3794
02:24:03,080 --> 02:24:08,439
design decisions migration I feel like

3795
02:24:05,680 --> 02:24:10,399
this is this is a cool one like it seems

3796
02:24:08,439 --> 02:24:11,800
like large language models able to

3797
02:24:10,399 --> 02:24:14,560
basically translate from one programm

3798
02:24:11,800 --> 02:24:16,279
language to another or like translate

3799
02:24:14,560 --> 02:24:19,120
like migrate in the general sense of

3800
02:24:16,279 --> 02:24:21,920
what migrate is um but that's in the

3801
02:24:19,120 --> 02:24:23,600
current moment so I mean the fear has to

3802
02:24:21,920 --> 02:24:25,840
do with like okay as these models get

3803
02:24:23,600 --> 02:24:27,479
better and better then you're doing less

3804
02:24:25,840 --> 02:24:29,920
and less creative decisions and is it

3805
02:24:27,479 --> 02:24:32,640
going to kind of move to a place where

3806
02:24:29,920 --> 02:24:34,399
it's uh you're operating in the design

3807
02:24:32,640 --> 02:24:36,399
space of natural language where natural

3808
02:24:34,399 --> 02:24:38,560
language is the main programming

3809
02:24:36,399 --> 02:24:39,920
language and I guess I could ask that by

3810
02:24:38,560 --> 02:24:41,600
way of advice like if somebody's

3811
02:24:39,920 --> 02:24:43,439
interested in programming now what do

3812
02:24:41,600 --> 02:24:46,120
you think they should

3813
02:24:43,439 --> 02:24:47,600
learn like to say you guys started in

3814
02:24:46,120 --> 02:24:53,080
some

3815
02:24:47,600 --> 02:24:56,319
Java and uh I forget the oh some PHP PHP

3816
02:24:53,080 --> 02:24:57,960
Objective C Objective C there you go um

3817
02:24:56,319 --> 02:25:00,319
I mean in the end we all know JavaScript

3818
02:24:57,960 --> 02:25:02,880
is going to

3819
02:25:00,319 --> 02:25:04,800
win uh and not typescript it's just it's

3820
02:25:02,880 --> 02:25:07,160
going to be like vanilla JavaScript it's

3821
02:25:04,800 --> 02:25:09,240
just going to eat the world and maybe a

3822
02:25:07,160 --> 02:25:11,160
little bit of PHP and I mean it also

3823
02:25:09,240 --> 02:25:14,720
brings up the question of like I think

3824
02:25:11,160 --> 02:25:17,120
Don can has a this idea that some per of

3825
02:25:14,720 --> 02:25:20,359
the population is Geeks and like there's

3826
02:25:17,120 --> 02:25:22,680
a particular kind of psychology in mind

3827
02:25:20,359 --> 02:25:25,880
required for programming and it feels

3828
02:25:22,680 --> 02:25:27,920
like more and more that's expands the

3829
02:25:25,880 --> 02:25:31,640
kind of person that should be able to

3830
02:25:27,920 --> 02:25:34,399
can do great programming might

3831
02:25:31,640 --> 02:25:36,800
expand I think different people do

3832
02:25:34,399 --> 02:25:39,600
programming for different reasons but I

3833
02:25:36,800 --> 02:25:43,720
think the true maybe like the best

3834
02:25:39,600 --> 02:25:46,120
programmers um are the ones that really

3835
02:25:43,720 --> 02:25:47,560
love just like absolutely love

3836
02:25:46,120 --> 02:25:50,359
programming for example there folks in

3837
02:25:47,560 --> 02:25:54,600
our team who

3838
02:25:50,359 --> 02:25:57,920
literally when they're they get back

3839
02:25:54,600 --> 02:25:59,680
from work they go and then they boot up

3840
02:25:57,920 --> 02:26:01,279
cursor and then they start coding on

3841
02:25:59,680 --> 02:26:03,760
their side projects for the entire night

3842
02:26:01,279 --> 02:26:07,040
and they stay till 3:00 a.m. doing that

3843
02:26:03,760 --> 02:26:10,200
um and when they're sad they they

3844
02:26:07,040 --> 02:26:14,000
said I just really need to

3845
02:26:10,200 --> 02:26:15,520
code and I I I think like you know

3846
02:26:14,000 --> 02:26:17,600
there's there's that level of programmer

3847
02:26:15,520 --> 02:26:21,560
where like this Obsession and love of

3848
02:26:17,600 --> 02:26:23,800
programming um I think makes really the

3849
02:26:21,560 --> 02:26:25,520
best programmers and I think the these

3850
02:26:23,800 --> 02:26:28,120
types of people

3851
02:26:25,520 --> 02:26:30,319
will really get into the details of how

3852
02:26:28,120 --> 02:26:32,200
things work I guess the question I'm

3853
02:26:30,319 --> 02:26:33,800
asking that exact program I think about

3854
02:26:32,200 --> 02:26:36,279
that

3855
02:26:33,800 --> 02:26:39,439
person when you're when the super tab

3856
02:26:36,279 --> 02:26:42,600
the super awesome praise be the tab is

3857
02:26:39,439 --> 02:26:44,600
succeeds you keep PR pressing tab that

3858
02:26:42,600 --> 02:26:46,120
person in the team loves to cursor tab

3859
02:26:44,600 --> 02:26:48,560
more than anybody else right yeah and

3860
02:26:46,120 --> 02:26:50,760
it's also not just like like pressing

3861
02:26:48,560 --> 02:26:52,279
tab is like the just pressing tab that's

3862
02:26:50,760 --> 02:26:54,640
like the easy way to say it in the The

3863
02:26:52,279 --> 02:26:55,920
Catch catchphrase you know uh but what

3864
02:26:54,640 --> 02:26:57,880
you're actually doing when you're

3865
02:26:55,920 --> 02:27:00,560
pressing tab is that you're you're

3866
02:26:57,880 --> 02:27:02,479
injecting intent uh all the time while

3867
02:27:00,560 --> 02:27:03,600
you're doing it you're you're uh

3868
02:27:02,479 --> 02:27:05,960
sometimes you're rejecting it sometimes

3869
02:27:03,600 --> 02:27:09,640
you're typing a few more characters um

3870
02:27:05,960 --> 02:27:11,359
and and that's the way that you're um

3871
02:27:09,640 --> 02:27:14,000
you're sort of shaping the things that's

3872
02:27:11,359 --> 02:27:16,760
being created and I I think programming

3873
02:27:14,000 --> 02:27:18,160
will change a lot to just what is it

3874
02:27:16,760 --> 02:27:19,680
that you want to make it's sort of

3875
02:27:18,160 --> 02:27:21,000
higher bandwidth the communication to

3876
02:27:19,680 --> 02:27:23,960
the computer just becomes higher and

3877
02:27:21,000 --> 02:27:26,160
higher bandwidth as opposed to like like

3878
02:27:23,960 --> 02:27:28,160
just typing is much lower bandwidth than

3879
02:27:26,160 --> 02:27:30,279
than communicating intent I mean this

3880
02:27:28,160 --> 02:27:34,040
goes to your uh

3881
02:27:30,279 --> 02:27:36,160
Manifesto titled engineering genius we

3882
02:27:34,040 --> 02:27:37,960
are an applied research lab building

3883
02:27:36,160 --> 02:27:41,000
extraordinary productive human AI

3884
02:27:37,960 --> 02:27:43,479
systems So speaking to this like hybrid

3885
02:27:41,000 --> 02:27:46,040
element mhm uh to start we're building

3886
02:27:43,479 --> 02:27:48,200
the engineer of the future a human AI

3887
02:27:46,040 --> 02:27:50,680
programmer that's an order of magnitude

3888
02:27:48,200 --> 02:27:52,200
more effective than any one engineer

3889
02:27:50,680 --> 02:27:54,520
this hybrid engineer will have

3890
02:27:52,200 --> 02:27:57,680
effortless control over their code base

3891
02:27:54,520 --> 02:27:59,840
and no low entropy keystrokes they will

3892
02:27:57,680 --> 02:28:02,560
iterate at the speed of their judgment

3893
02:27:59,840 --> 02:28:05,200
even in the most complex systems using a

3894
02:28:02,560 --> 02:28:07,560
combination of AI and human Ingenuity

3895
02:28:05,200 --> 02:28:10,479
they will outsmart and out engineer the

3896
02:28:07,560 --> 02:28:12,479
best pure AI systems we are a group of

3897
02:28:10,479 --> 02:28:14,640
researchers and Engineers we build

3898
02:28:12,479 --> 02:28:15,800
software and models to invent at the

3899
02:28:14,640 --> 02:28:17,479
edge of what's useful and what's

3900
02:28:15,800 --> 02:28:19,720
possible our work has already improved

3901
02:28:17,479 --> 02:28:21,279
the lives of hundreds of thousands of

3902
02:28:19,720 --> 02:28:23,359
program

3903
02:28:21,279 --> 02:28:25,760
and on the way to that will at least

3904
02:28:23,359 --> 02:28:27,520
make programming more fun so thank you

3905
02:28:25,760 --> 02:28:30,200
for talking today thank you thanks for

3906
02:28:27,520 --> 02:28:31,479
having us thank you thank you thanks for

3907
02:28:30,200 --> 02:28:34,960
listening to this conversation with

3908
02:28:31,479 --> 02:28:36,160
Michael swall Arvid and Aman to support

3909
02:28:34,960 --> 02:28:38,800
this podcast please check out our

3910
02:28:36,160 --> 02:28:42,960
sponsors in the description and now let

3911
02:28:38,800 --> 02:28:44,840
me leave you with a random funny and

3912
02:28:42,960 --> 02:28:45,560
perhaps profound programming code I saw

3913
02:28:44,840 --> 02:28:48,880
on

3914
02:28:45,560 --> 02:28:51,279
Reddit nothing is as permanent as a

3915
02:28:48,880 --> 02:28:53,680
temporary solution that

3916
02:28:51,279 --> 02:28:57,960
works thank you for listening and hope

3917
02:28:53,680 --> 02:28:57,960
to see you next time